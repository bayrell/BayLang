/*!
 *  Bayrell Language
 *
 *  (c) Copyright 2016-2023 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Bayrell.Lang.Compiler;

use Runtime.fs;
use Runtime.BaseObject;
use Runtime.Exceptions.RuntimeException;
use Bayrell.Lang.Compiler.Module;


class SettingsProvider extends BaseObject
{
	string project_path = "";
	Dict config = {};
	Dict<Module> modules = {};
	
	
	/**
	 * Read settings from file located in @.base_path
	 */
	async void readSettings()
	{
		await this.readSettingsFromFile( fs::join([ @.base_path, "project.json" ]) );
	}
	
	
	
	/**
     * Read settings from file
     */
    async void readSettingsFromFile(string file_name)
    {
        bool is_file = await fs::isFile(file_name);
		if (!is_file)
		{
			throw new RuntimeException("File '" + file_name + "' does not exists");
		}
		
		string file_content = await fs::readFile(file_name);
		this.config = rtl::json_decode(file_content);
		this.project_path = rs::dirname(file_name);
		
		/* Load modules */
		this.modules = await this.readModules();
    }
	
	
	
	/**
	 * Returns modules from config
	 */
	async Dict readModules()
	{
		Map<Module> modules = new Map();
		Dict config = this.config;
		
		Collection modules_info = config["modules"] |> default Collection [];
		for (int i = 0; i<modules_info.count(); i++)
		{
			Dict module_info = modules_info[i] |> default Dict {};
			string module_src = module_info["src"] |> default string "";
			string module_type = module_info["type"] |> default string "";
			
			if (module_type == "module")
			{
				string module_path = fs::join([ this.project_path, module_src ]);
				Module module = await this.readModule(module_path);
				if (module and not modules.has(module.name))
				{
					modules.setValue(module.name, module);
				}
			}
			else if (module_type == "folder")
			{
				string folder_path = fs::join([ this.project_path, module_src ]);
				Collection<Module> folder_modules =
					await this.readModulesFromFolder(folder_path)
				;
				for (int j=0; j<folder_modules.count(); j++)
				{
					Module module = folder_modules[j];
					if (module and not modules.has(module.name))
					{
						modules.setValue(module.name, module);
					}
				}
			}
		}
		
		return modules.toDict();
	}
	
	
	
	/**
	 * Read module from folder
	 */
	async Module readModule(string module_path)
	{		
		string module_json_path = fs::join([ module_path, "module.json" ]);
		bool is_file = await fs::isFile(module_json_path);
		if (!is_file)
			return null;
		
		string module_json_content = await fs::readFile(module_json_path);
		string module_json = rtl::json_decode(module_json_content);
		if (!module_json)
			return null;
		
		string module_name = module_json["name"] |> default string "";
		if (module_name == "")
			return null;
		
		Module module = new Module
		{
			"name": module_name,
			"config": module_json,
			"path": module_path,
		};
		
		return module;
	}
	
	
	
	/**
	 * Read modules from folder
	 */
	async Collection<Module> readModulesFromFolder(string folder_path)
	{
		Vector<Module> modules = new Vector();
		
		Collection<string> file_names = await fs::listDir(folder_path);
		for (int i=0; i<file_names.count(); i++)
		{
			string file_name = file_names[i];
			string module_path = fs::join([ folder_path, file_name ]);
			Module module = await this.readModule(module_path);
			if (module)
			{
				modules.pushValue(module);
			}
		}
		
		return modules.toCollection();
	}
}