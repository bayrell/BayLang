/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2025 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang.Helper;

use Runtime.fs;
use Runtime.lib;
use Runtime.BaseObject;
use Runtime.Serialize.SerializeInterface;
use Runtime.Serialize.Serializer;
use Runtime.Serialize.SerializerJson;
use BayLang.Compiler.Module;


class Project extends BaseObject implements SerializeInterface
{
	string path = "";
	Dict info = {};
	Dict<Module> modules = null;
	
	
	/**
	 * Constructor
	 */
	void constructor()
	{
		parent();
	}
	
	
	/**
	 * Read project
	 */
	static async Project readProject(string project_path)
	{
		Project project = new Project();
		await project.read(project_path);
		if (not this.exists()) return null;
		await project.readModules();
		return project;
	}
	
	
	/**
	 * Read project
	 */
	async void read(string project_path)
	{
		this.info = null;
		this.path = project_path;
		string project_json_path = fs::join([this.path, "project.json"]);
		if (not(await fs::isFolder(this.path))) return;
		if (not(await fs::isFile(project_json_path))) return;
		
		/* Read file */
		string content = await fs::readFile(project_json_path);
		this.info = rtl::json_decode(content);
	}
	
	
	/**
	 * Save project
	 */
	async void save()
	{
		string project_json_path = fs::join([this.path, "project.json"]);
		string content = rtl::json_encode(this.info, rtl::JSON_PRETTY);
		await fs::saveFile(project_json_path, content);
	}
	
	
	/**
	 * Process project cache
	 */
	void serialize(Serializer serializer, Map data)
	{
		serializer.processItems(
			this, "modules", data,
			Module (Serializer serializer, Dict module) =>
				new Module(this, module.get("path"))
		);
	}
	
	
	/**
	 * Returns true if project is exists
	 */
	bool exists()
	{
		if (not this.info) return false;
		if (not this.info.has("name")) return false;
		return true;
	}
	
	
	/**
	 * Returns project path
	 */
	string getPath() => this.exists() ? this.path : "";
	
	
	/**
	 * Returns project file_name
	 */
	string getID() => this.exists() ? rs::basename(this.path) : "";
	
	
	/**
	 * Returns project name
	 */
	string getName() => this.exists() ? this.info.get("name") : "";
	
	
	/**
	 * Set project name
	 */
	void setName(string name)
	{
		this.info.set("name", name);
	}
	
	
	/**
	 * Returns project description
	 */
	string getDescription() => this.exists() ? this.info.get("description") : "";
	
	
	/**
	 * Set project description
	 */
	void setDescription(string description)
	{
		this.info.set("description", description);
	}
	
	
	/**
	 * Returns project type
	 */
	string getType() => this.exists() ? this.info.get("type") : "";
	
	
	/**
	 * Set project type
	 */
	void setType(string project_type)
	{
		this.info.set("type", project_type);
	}
	
	
	/**
	 * Returns assets
	 */
	Collection<Dict> getAssets() => this.exists() ? this.info.get("assets") : [];
	
	
	/**
	 * Returns languages
	 */
	Collection<string> getLanguages() => this.exists() ? this.info.get("languages") : [];
	
	
	/**
	 * Returns modules
	 */
	Collection<Module> getModules() => this.modules.copy();
	
	
	/**
	 * Returns module
	 */
	Module getModule(string module_name) => this.modules.get(module_name);
	
	
	/**
	 * Returns modules by group name
	 */
	Collection getModulesByGroupName(string group_name)
	{
		/* Get modules */
		Collection<Module> modules = this.modules.transition(
			Module (Module module, string module_name) => module
		);
		
		/* Filter modules by group */
		modules = modules.filter(
			bool (Module module) use (group_name) =>
				module.hasGroup(group_name)
		);
		
		/* Get names */
		modules = modules.map(string (Module item) => item.name);
		
		/* Return modules */
		return modules;
	}
	
	
	/**
	 * Find module by file name
	 */
	Module findModuleByFileName(string file_name)
	{
		Module res = null;
		int module_path_sz = -1;
		Collection<string> module_names = this.modules.keys();
		for (int i=0; i<module_names.count(); i++)
		{
			string module_name = module_names.get(i);
			Module module = this.modules.get(module_name);
			if (module.checkFile(file_name))
			{
				int sz = rs::strlen(module.path);
				if (module_path_sz < sz)
				{
					module_path_sz = sz;
					res = module;
				}
			}
		}
		return res;
	}
	
	
	/**
	 * Read modules
	 */
	async void readModules()
	{
		this.modules = {};
		
		/* Read sub modules */
		await this.readSubModules(this.path, this.info.get("modules"));
	}
	
	
	/**
	 * Read module
	 */
	async void readModule(string folder_path)
	{
		Module module = new Module(this);
		await module.read(folder_path);
		if (module.exists())
		{
			/* Set module */
			this.modules.set(module.getName(), module);
			
			/* Read sub modules */
			await this.readSubModules(module.getPath(), module.submodules);
		}
	}
	
	
	/**
	 * Read sub modules
	 */
	async void readSubModules(string path, Collection<Dict> items)
	{
		if (not items) return;
		for (int i=0; i<items.count(); i++)
		{
			Dict item = items.get(i);
			string module_src = item.get("src");
			string module_type = item.get("type");
			string folder_path = fs::join([ path, module_src ]);
			
			/* Read from folder */
			if (module_type == "folder")
			{
				await this.readModuleFromFolder(folder_path);
			}
			
			/* Read module */
			else
			{
				await this.readModule(folder_path);
			}
		}
	}
	
	
	/**
	 * Read sub modules
	 */
	async void readModuleFromFolder(string folder_path)
	{
		if (not(await fs::isFolder(folder_path))) return;
		
		Collection<string> items = await fs::listDir(folder_path);
		for (int i=0; i<items.count(); i++)
		{
			string file_name = items.get(i);
			if (file_name == ".") continue;
			if (file_name == "..") continue;
			
			/* Read module */
			await this.readModule(fs::join([folder_path, file_name]));
		}
	}
	
	
	/**
	 * Sort modules
	 */
	Collection<string> sortRequiredModules(Collection<string> modules)
	{
		Vector result = [];
		
		fn add_module;
		add_module = void (string module_name) use (modules, result, add_module)
		{
			if (modules.indexOf(module_name) == -1) return;
			
			/* Get module by name */
			Module module = this.modules.get(module_name);
			if (not module) return;
			
			/* Add required modules */
			if (module.required_modules != null)
			{
				for (int i=0; i<module.required_modules.count(); i++)
				{
					add_module(module.required_modules.get(i));
				}
			}
			
			/* Add module if not exists */
			if (result.indexOf(module_name) == -1)
			{
				result.push(module_name);
			}
		};
		
		for (int i=0; i<modules.count(); i++)
		{
			add_module(modules.get(i));
		}
		
		return result;
	}
	
	
	/**
	 * Returns assets modules
	 */
	Collection<string> getAssetModules(Dict asset)
	{
		Collection modules = asset.get("modules");
		
		/* Extends modules */
		Vector new_modules = [];
		modules.each(
			void (string module_name) use (new_modules)
			{
				if (rs::substr(module_name, 0, 1) == "@")
				{
					/* Get group modules by name */
					Collection group_modules = this.getModulesByGroupName(module_name);
					
					/* Append group modules */
					new_modules.appendItems(group_modules);
				}
				else
				{
					new_modules.push(module_name);
				}
			}
		);
		modules = new_modules.removeDuplicates();
		
		/* Sort modules by requires */
		modules = this.sortRequiredModules(modules);
		
		return modules;
	}
	
	
	/**
	 * Build asset
	 */
	async void buildAsset(Dict asset)
	{
		string asset_path_relative = asset["dest"] |> default string "";
		if (asset_path_relative == "") return;
		
		/* Get asset dest path */
		string asset_path = fs::join([ this.path, asset_path_relative ]);
		string asset_content = "";
		
		/* Get modules names in asset */
		Collection modules = this.getAssetModules(asset);
		for (int i=0; i<modules.count(); i++)
		{
			string module_name = modules.get(i);
			Module module = this.modules.get(module_name);
			if (not module) continue;
			
			/* Get files */
			for (int j=0; j<module.assets.count(); j++)
			{
				string file_name = module.assets.get(j);
				string file_source_path = module.resolveSourceFilePath(file_name);
				string file_dest_path = module.resolveDestFilePath(file_name, "es6");
				
				if (file_dest_path)
				{
					if (await fs::isFile(file_dest_path))
					{
						string content = await fs::readFile(file_dest_path);
						asset_content ~= content ~ "\n";
					}
					else if (
						await fs::isFile(file_source_path) and
						rs::extname(file_source_path) == "js"
					)
					{
						string content = await fs::readFile(file_source_path);
						asset_content ~= content ~ "\n";
					}
				}
			}
		}
		
		/* Create directory if does not exists */
		string dir_name = rs::dirname(asset_path);
		if (not await fs::isDir(dir_name))
		{
			await fs::mkdir(dir_name);
		}
		
		/* Save file */
		await fs::saveFile(asset_path, asset_content);
	}
}