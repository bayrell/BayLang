/*!
 *  Bayrell Language
 *
 *  (c) Copyright 2016-2023 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Bayrell.Lang.Compiler;

use Runtime.fs;
use Runtime.Context;
use Bayrell.Lang.Compiler.Module;
use Bayrell.Lang.Compiler.SettingsProvider;
use Bayrell.Lang.Exceptions.ParserUnknownError;
use Bayrell.Lang.LangBay.ParserBay;
use Bayrell.Lang.LangES6.TranslatorES6;
use Bayrell.Lang.LangNode.TranslatorNode;
use Bayrell.Lang.LangPHP.TranslatorPHP;
use Bayrell.Lang.OpCodes.BaseOpCode;
use Bayrell.Lang.CoreTranslator;
use Bayrell.Lang.LangUtils;


class CLI
{
	SettingsProvider settings = null;
	
	
	/**
	 * Returns modules
	 */
	Dict<Module> getModules()
	{
		return this.settings.modules;
	}
	
	
	
	/**
	 * Create translator
	 */
	CoreTranslator createTranslator(string lang = "")
	{
		CoreTranslator t = null;
		
		if (lang == "php")
		{
			t = new TranslatorPHP();
		}
		if (lang == "es6")
		{
			t = new TranslatorES6();
		}
		if (lang == "nodejs")
		{
			t = new TranslatorNode();
		}
		
		return t;
	}
	
	
	
	/**
	 * Compile file
	 */
	async void compileFile(string file_path, bool log_message = true)
	{
		var output = @.provider("output");
		
		Dict file_info = await this.settings.resolveFile(file_path);
		if (not file_info)
			return;
		
		if (log_message)
			output.print(file_path);
		
		string ext_name = file_info["ext_name"];
		Map container = {
			"op_code": null,
			"success": false,
			"content": "",
			"result": "",
			"lang": "",
		};
		
		container <= content <= await fs::readFile(file_path);
		
		if (ext_name == "bay")
		{
			ParserBay parser = new ParserBay();
			BaseOpCode op_code = LangUtils::parse(parser, container["content"]);
			container <= op_code <= op_code;
		}
		
		fn is_lang = bool (string ext_name, string lang)
		{
			/* ES6 */
			if (ext_name == "es6" and lang == "es6") return true;
			if (ext_name == "js" and lang == "es6") return true;
			
			/* NodeJS */
			if (ext_name == "node" and lang == "nodejs") return true;
			if (ext_name == "nodejs" and lang == "nodejs") return true;
			if (ext_name == "js" and lang == "nodejs") return true;
			
			/* PHP */
			if (ext_name == "php" and lang == "php") return true;
			
			return false;
		}
		
		fn save_file = async void (string file_info, string container)
			use (log_message, output)
		{
			string file_name = file_info["file_name"];
			Module module = file_info["module"];
			
			string dest_path = module.resolveDestFile(
				this.settings.project_path,
				file_name,
				container["lang"]
			);
			
			if (dest_path == "") return false;
			
			/* Create directory if does not exists */
			string dir_name = rs::dirname( dest_path );
			if (not await fs::isDir(dir_name))
			{
				await fs::mkdir(dir_name);
			}
			
			/* Save file */
			await fs::saveFile(dest_path, container["result"]);
			
			if (log_message)
				output.print("=> " ~ dest_path);
			
			return true;
		};
		
		Collection<string> languages = this.settings.config["languages"] |> default Collection [];
		for (int i=0; i<languages.count(); i++)
		{
			string lang_name = languages[i] |> default string "";
			BaseOpCode op_code = container["op_code"];
			
			container <= success <= false;
			container <= lang <= lang_name;
			container <= result <= "";
			
			if (ext_name == "bay")
			{
				if (op_code)
				{
					CoreTranslator t = static::createTranslator(lang_name);
					if (t)
					{
						container <= result <= LangUtils::translate(t, op_code);
						container <= success <= true;
					}
				}
			}
			else if ( is_lang(ext_name, lang_name) )
			{
				container <= result <= container["content"];
				container <= success <= true;
			}
			
			if (container["success"])
			{
				await save_file(file_info, container, lang_name);
			}
		}
		
		if (log_message)
			output.print("Ok");
	}
	
	
	
	/**
	 * Compile module
	 */
	void compileModule(string module_name, string lang = "")
	{
		var output = @.provider("output");
		
		if (not this.settings.modules.has(module_name))
		{
			output.print_error("Module " + module_name + " not found");
			return -1;
		}
		
		log (module_name);
	}
	
	
	
	/**
	 * Make es6 bundle
	 */
	void makeES6Bundle(string module_name)
	{
		
	}
	
	
	
	/**
	 * Show modules
	 */
	void showModules(bool verbose)
	{
		var output = @.provider("output");
		
		Dict<Module> modules = static::getModules();
		Collection<string> modules_names = modules.keys().sort();
		for (int i=0; i<modules_names.count(); i++)
		{
			string module_name = modules_names[i];
			Module module = modules[module_name];
			
			if (verbose)
			{
				output.print( (i + 1) ~ ") " ~
					output.color("yellow", module_name) ~ " - " ~
					module.path
				);
			}
			else
			{
				output.print( module_name );
			}
		}
	}
	
	
	
	/**
	 * Init app
	 */
	async void init(Context c)
	{
		return c;
	}
	
	
	
	/**
	 * Start app
	 */
	async void start()
	{
		/* Create settings provider */
		this.settings = new SettingsProvider();
		await this.settings.start();
	}
	
	
	
	/**
	 * Main entry point
	 */
	async int main()
	{
		string cmd = @.cli_args[1];
		var output = @.provider("output");
		
		if (rtl::isEmpty(cmd))
		{
			output.print("Methods:");
			output.print("  watch");
			output.print("  make");
			output.print("  modules");
			output.print("  version");
			return 0;
		}
		
		else if (cmd == "version")
		{
			fn runtime_version = rtl::method("Runtime.ModuleDescription", "getModuleVersion");
			fn lang_version = rtl::method("Bayrell.Lang.ModuleDescription", "getModuleVersion");
			
			output.print("Lang version: " ~ lang_version());
			output.print("Runtime version: " ~ runtime_version());
			return 0;
		}
		
		else if (cmd == "modules")
		{
			this.showModules(true);
			return 0;
		}
		
		else if (cmd == "make")
		{
			string module_name = @.cli_args[2];
			string lang = @.cli_args[3];
			
			if (rtl::isEmpty(module_name))
			{
				this.showModules();
				return 0;
			}
			
			return await this.compileModule(module_name, lang);
		}
		
		else if (cmd == "watch")
		{
			#ifcode NODEJS then
			
			let on_change_file = async (ctx, changed_file_path) =>
			{
				try
				{
					await this.compileFile(ctx, changed_file_path, true);
				}
				catch (e)
				{
					let ParserUnknownError = use("Bayrell.Lang.Exceptions.ParserUnknownError");
					if (e instanceof ParserUnknownError)
					{
						output.print_error(ctx, "Error: " + e.getMessage());
					}
					else
					{
						output.print(ctx, e);
					}
					return;
				}
			};
			
			let watch_dir = (ctx) =>
			{
				let chokidar = require('chokidar');
				return new Promise(() => {
					
					output.print(ctx, "Start watch");
					chokidar
						.watch(ctx.base_path)
						.on('change', (path, stat) => {
							setTimeout(()=>{ on_change_file(ctx, path); }, 500);
						})
					;
					
				});
			};
			
			await watch_dir(ctx);
			
			#endif
		}
		
		return 0;
	}
}