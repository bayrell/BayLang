/*!
 *  Bayrell Common Languages Transcompiler
 *
 *  (c) Copyright 2016-2017 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace bayrell_lang;
use bayrell_rtl import rtl, BayrellError;
use bayrell_parser import BayrellCoreParser;



export class BayrellParserBay extends BayrellCoreParser{
	
	protected bool _mathSemicolon = true;
	
	
	string getClassName(){
		return "bayrell_lang.BayrellParserBay";
	}
	
	void constructor (){
	}
	
	void _initSpecTokens(){
		this._spec_tokens = [
			
			{
				'token': BayrellCommonParser::TOKEN_BASE,
				'type': BayrellCommonParser::TYPE_SINGLE,
				'arr': [
					'!==', '===', '!=', '==',  '<=', '>=',
					"::", "&&", "||", ">>", "<<", "->", 
					"++", "--", "+=", "-=", "~=", 
					"#ifcode", "#switch", "#case", "#endswitch", "#endif",
				],
			},
			
			{
				'token': BayrellCommonParser::TOKEN_STRING,
				'type': BayrellCommonParser::TYPE_STRING,
				'arr': [
					'"', "'",
				],
				'func': '_readTokenString',
			},
			
			{
				'token': BayrellCommonParser::TOKEN_COMMENT,
				'type': BayrellCommonParser::TYPE_PAIR,
				'json': {
					'/*!': '*/',
					'/**': '*/',
					'/*': '*/',
				},
			},
			
		];
	}
	
	string _readTokenString(string match_str, bool flag = true){				
		var arr1 = ['n', 'r', 't', '\\', '"', "'"];
		/*
		\[0-7]{1,3}	- последовательность символов, соответствующая регулярному выражению символа в восьмеричной системе счисления, который молча переполняется, чтобы поместиться в байт (т.е. "\400" === "\000")
		\x[0-9A-Fa-f]{1,2} - последовательность символов, соответствующая регулярному выражению символа в шестнадцатеричной системе счисления
		\u{[0-9A-Fa-f]+} - последовательность символов, соответствующая регулярному выражению символа Unicode, которая отображается в строка в представлении UTF-8 (добавлено в PHP 7.0.0)
		*/
		
		int len = rtl::strlen(s);
		int len_match = rtl::strlen(match_str);
		string s = "";
		string look = this._lookChar();
		string look_str = this._lookString(len_match);
		
		while (look !== "" and look_str != match_str) {
			
			if (look == '\\'){
				string look2 = this._readLookChar(look);
				
				if (rtl::in_array(look2, arr1)){				
					if (look2 == 'n') s = s ~ '\n';
					else if (look2 == 'r') s = s ~ '\r';
					else if (look2 == 't') s = s ~ '\t';
					else if (look2 == '\\') s = s ~ '\\';
					else if (look2 == '"') s = s ~ '"';
					else if (look2 == "'") s = s ~ "'";
				}
				else{
					s = s ~ look2;
				}
				
				look = this._readLookChar(look2);
			}
			else{
				s = s ~ look;
				look = this._readLookChar(look);
			}
			
			look_str = this._lookString(len_match);
		}
		
		if (len > 1){
			s = rtl::substr(s, 0, rtl::strlen(s) - len_match + 1);
		}
		
		if (flag)
			this._match(match_str);
		
		return s;
	}
	
	bool isIdentifier(string name){
		return this.isToken(name);
	}
	
	
	/**
	 * Поиск запятой в цикле
	 * @return {int} результат
	 *   -1 - прервать и выйти из цикла. Комманда break
	 *    1 - продолжить выполнение цикла с начала. Комманда continue
	 *    0 - идти дальше
	 */
	int matchComma(bool &match_comma, string stop_token){
		if (match_comma){ 
			this.match(','); 
			match_comma = false;
		}
		
		if (this.isLookComment()){
			this.getToken();
			return 1;
		}
		if (this.eof()){
			return -1;
		}
		if (this.findToken(stop_token)){
			return -1;
		}
		
		return 0;
	}
	
	
	/**
	 * Вызвать аргументы
	 */
	array matchCallArgs(char ch = ')'){
		array childs = [];
		bool match_comma = false;
		
		while (!this.findToken(ch) and !this.eof()){
			
			/* Ищем запятую. Запятая должна разделять элементы */
			int res = this.matchComma(match_comma, ch);
			if (res == 1) continue;
			else if (res == -1) break;
			
			rtl::array_push(childs, this.matchExpression());
			
			match_comma = true;
		}
		return childs;
	}
	
	
	
	/**
	 * Вызвать аргументы
	 */
	array matchTypeArgs(char ch = '>'){
		array childs = [];
		bool match_comma = false;
		
		while (!this.findToken(ch) and !this.eof()){
			
			/* Ищем запятую. Запятая должна разделять элементы */
			int res = this.matchComma(match_comma, ch);
			if (res == 1) continue;
			else if (res == -1) break;
			
			rtl::array_push(childs, this.matchIdentifier());
			
			match_comma = true;
		}
		return childs;
	}
	
	
	
	/**
	 * Читает флаги
	 */
	OpFlags readFlags(){
		OpFlags flags = new OpFlags();
		while ( this.findTokenVector(OpFlags::FLAGS) ){
			string token = this.getToken();
			flags.setFlag(token, true);
		}
		return flags;
	}
	
	
	
	/**
	 * Вызвать аргументы
	 */
	array matchDeclareArgs(){ 
		array childs = [];
		bool match_comma = false;
		
		while (!this.findToken(')') and !this.eof()){
			
			
			/* Ищем запятую. Запятая должна разделять элементы */
			int res = this.matchComma(match_comma, ")");
			if (res == 1) continue;
			else if (res == -1) break;
			
			
			/* Читаем флаги */
			json flags = this.readFlags();
			
			/* TODO: тип может быть классом с указанием package и namespace. 
			Нужно использовать функцию matchMultiName */
			var tp = this.getToken(); 
			
			if ( this.findToken('&') ){
				this.match('&');
				flags['pointer'] = true;
			}
			if (this.findToken(')') or this.findToken(',')){
				this.match('type');
			}
			
			string name = this.matchIdentifier();
			json value = null;
		
			if (this.findToken('=')){
				this.match('=');
				value = this.matchExpression();
			}
			
			rtl::array_push(childs, BayrellCode::op_declare_var(name, tp, value, flags));
			
			match_comma = true;
		}
		return childs;
	}
	
	
	
	/**
	 * Сканирует имя, разделенное точками
	 */
	string matchMultiName(){
		string name = "";
		array names = [];
		
		/* TODO: проверка на то, что getToken это токен, а не строка, коммментарий или еще чего */
		if (!this.findToken('.')){
			name = this.getToken(); 
			rtl::array_push(names, name);
		}
		
		while (this.findToken('.')){
			name = this.getToken();
			rtl::array_push(names, name); 
			
			/* read name */
			name = this.getToken(); 
			rtl::array_push(names, name);
		}
		
		return rtl::implode("", names);
	}	
	
	
	
	
	BaseOpCode matchIdentificator(){
		return this.getToken();
	}
	
	
	
	/**
	 * Сканирует на динамическое имя
	 */
	BaseOpCode matchDynamicIdentificator(BaseOpCode op1){
		
		if (!this.findToken('.'))
			return op1;
		
		BaseOpCode res = new OpLoadVector();
		res.load = op1;
		
		while (this.findToken('.')){
			this.match('.');
			res.childs.push( this.matchIdentificator() );
		}
		
		return res;
	}
	
	
	
	/**
	 * Сканирует на наличие типа
	 */
	BaseOpCode matchTypeName(){
		BaseOpCode op1 = new OpLoad(this.matchIdentificator());
		op1 = this.matchDynamicIdentificator(op1);
		
		if (!this.findToken('<'))
			return op1;
		
		
		BaseOpCode args = null;
		this.match('<');
		this.match('>');
		
		return new OpTemplateType(op1, args);
	}
	
	
	
	/**
	 * Сканирует на статическое имя
	 */
	BaseOpCode matchStaticIdentificator(op1){
		op1 = this.matchDynamicIdentificator(op1);
		
		if (!this.findToken('::'))
			return op1;
		
		this.match('::');
		string name = this.matchIdentificator();
		
		return new OpLoadStatic(op1, name);
	}
	
	
	
	/**
	 * Сканирует на вызов функции
	 */
	BaseOpCode matchCallFunc(BaseOpCode op1){
		op1 = this.matchStaticIdentificator(op1);
		
		if (!this.findToken('('))
			return name;
		
		Vector<BaseOpCode> args = null;
		this.match('(');
		this.match(')');
		
		op1 = new OpCall(op1, args);
		
		if (this.findToken('.')){
			return this.matchCallFunc(op1);
		}
		
		return op1;
	}
	
	
	
	/**
	 * Сканирует на наличие имени
	 */
	BaseOpCode matchName(){
		BaseOpCode op1 = new OpLoad(this.matchIdentificator());
		
		if (!this.findTokenVector(['.', '::', '(']))
			return op1;
		
		
		return this.matchCallFunc(op1);
	}
	
	
	
	/**
	 * Сканирует Array
	 */
	BaseOpCode matchArray(){
		BaseOpCode op = new OpArray();
	
		this.match('[');
		bool match_comma = false;
		
		while (!this.findToken(']') and !this.eof()){
			
			/* Ищем запятую. Запятая должна разделять элементы */
			int c = this.matchComma(match_comma, "]");
			if (c == 1) continue;
			else if (c == -1) break;
			
			if (this.isLookComment()){
				this.getToken();
				continue;
			}
			
			op.childs.push( this.matchExpression() );
			match_comma = true;
		}
		this.match(']');
		
		return op;
	}
	
	
	
	/**
	 * Сканирует на наличие операций с именем
	 */
	BaseOpCode matchOpName (){
		
		if (this.findToken('(')){
			this.match('(');
			BaseOpCode res = this.matchTernaryOperator();
			this.match(')');
			return res;
		}
		
		else if (this.findToken('!')){
			this.match('!');
			return new OpNot(this.matchArithmetic());
		}
		else if (this.findToken('-')){
			this.match('-');
			return new OpSub(this.matchArithmetic());
		}
		else if (this.findToken('++')){
			this.match('++');
			return new OpPreInc(this.matchName());
		}
		else if (this.findToken('--')){
			this.match('--');
			return new OpPreDec(this.matchName());
		}
		else if (this.findToken('[')){
			return this.matchArray();
		}
		
		
		BaseOpCode res = this.matchName();
		
		if (this.findToken('++')){
			this.match('++');
			return new OpPostInc(res);
		}
		else if (this.findToken('--')){
			this.match('--');
			return new OpPostDec(res);
		}
		
		return res;
	}
	
	
	
	/**
	 * Сканирует умножение, деление, возведение в степень
	 */
	BaseOpCode matchFactor (){
	
		BaseOpCode op1 = this.matchOpName();
		if (!this.findTokenVector(['*', '/']))
			return op1;
			
		OpOr op2 = new OpCalc();
		op2.childs.push(op1);
		
		while (this.findTokenVector(['*', '/']) and !this.eof()){
			if (this.findToken('*')){
				this.match('*');
				op2.childs.push( new OpMult(this.matchOpName()) );
			}
			else if (this.findToken('/')){
				this.match('/');
				op2.childs.push( new OpDiv(this.matchOpName()) );
			}
			else{
				BayrellError e = this.createError(BayrellParserBay::ERROR_EXPECTED);
				e.setParam('what', '"*" or "/"');
				throw e;
			}
		}
		
		return op2;
	}
	
	
	
	/**
	 * Сканирует арифметические операции
	 */
	BaseOpCode matchArithmetic(){
		
		BaseOpCode op1 = this.matchFactor();
		if (!this.findTokenVector(['+', '-']))
			return op1;
			
		OpOr op2 = new OpCalc();
		op2.childs.push(op1);
		
		while (this.findTokenVector(['+', '-']) and !this.eof()){
			if (this.findToken('+')){
				this.match('+');
				op2.childs.push( new OpAdd(this.matchFactor()) );
			}
			else if (this.findToken('-')){
				this.match('-');
				op2.childs.push( new OpSub(this.matchFactor()) );
			}
			else{
				BayrellError e = this.createError(BayrellParserBay::ERROR_EXPECTED);
				e.setParam('what', '"+" or "-"');
				throw e;
			}
		}
		
		return op2;
	}
	
	
	
	/**
	 * Сканирует арифметические операции
	 */
	BaseOpCode matchConcat(){
		BaseOpCode op1 = this.matchArithmetic();
		if (!this.findToken('~'))
			return op1;
		OpOr op2 = new OpConcat();
		op2.childs.push(op1);
		
		while (this.findToken('~') and !this.eof()){
			this.match('~');
			op2.childs.push( this.matchArithmetic() );
		}
		
		return op2;
	}
	
	
	
	/**
	 * Сканирует логическое выражение
	 */
	BaseOpCode matchLogicExpression(){
		string op = null;
		BaseOpCode left = this.matchConcat();
		BaseOpCode right = null;
		
		if (!this.findTokenVector(['>', '!', '<', '=', '!=', '==', '===', '!==', '<=', '>=', 'in', 'is', 'instanceof']) )
			return left;
			
		op = this.getToken();
		right = this.matchConcat();
		
		return new OpCmp(left, right);
	}
	
	
	
	/**
	 * Сканирует логическое и
	 */
	BaseOpCode matchAnd (){
		
		BaseOpCode op1 = this.matchLogicExpression();
		if (!this.findToken('and'))
			return op1;
		OpOr op2 = new OpAnd();
		op2.childs.push(op1);
		
		while (this.findToken('and') and !this.eof()){
			this.match('and');
			op2.childs.push( this.matchLogicExpression() );
		}
		
		return op2;
	}
	
	
	
	/**
	 * Сканирует логическое ИЛИ
	 */
	BaseOpCode matchOr (){
		
		BaseOpCode op1 = this.matchAnd();
		if (!this.findToken('or'))
			return op1;
		
		OpOr op2 = new OpOr();
		op2.childs.push(op1);
		
		while (this.findToken('or') and !this.eof()){
			this.match('or');
			op2.childs.push( this.matchAnd() );
		}
		
		return op2;
	}
	
	
	
	/**
	 * Тернарный оператор
	 */
	BaseOpCode matchTernaryOperator(){
		BaseOpCode expr = this.matchOr();
		
		if (!this.findToken('?'))
			return expr;
			
		this.match('?');
		BaseOpCode if_true = this.matchExpression();
		
		this.match(':');
		BaseOpCode if_false = this.matchExpression();
		
		return new OpTernary(expr, if_true, if_false);
	}
	
	
	
	/**
	 * Сканирует выражение
	 */
	BaseOpCode matchExpression(){
		bool is_link = false;
		bool is_new = false;
		bool is_clone = false;
		
		if (this.findToken('&')){
			this.match('&');
			is_link = true;
		}
		
		if (this.findToken('new')){
			this.match('new');
			is_new = true;
		}
		
		if (this.findToken('clone')){
			this.match('clone');
			is_clone = true;
		}
		
		if (this.findToken('link')){
			this.match('link');
			is_link = true;
		}
		
		BaseOpCode code_tree = this.matchTernaryOperator();		
		
		if (is_clone)
			code_tree = new OpClone(code_tree);
		
		if (is_link)
			code_tree = new OpLink(code_tree);
		
		if (is_new)
			code_tree = new OpNew(code_tree);
		
		return code_tree;
	}
	
	
	
	/**
	 * Сканирует ifcode директиву
	 */
	json matchPreprocessorIfCode(){
		bool flag_open_token = false;
		
		if (this.findToken('#ifcode')){
			this.match("#ifcode");
			flag_open_token = true;
		}
		else if (this.findToken('ifcode')){
			this.match("ifcode");
		}
		
		json expr = this.matchExpression();
		if (!this.findToken('then')){
			throw this._createError(BayrellCommonParser::ERROR_EXPECTED, {
				'what': 'then',
			});
		}
		
		string code_str = this._readUntilStringArr(['#endif', '#case', '#endswitch'], false);
		this.getToken();
		
		if (flag_open_token){
			this.match("#endif");
		}
		
		return BayrellCode::op_ifcode(expr, code_str);
	}
	
	
	
	/**
	 * Сканирует switch директиву
	 */
	json matchPreprocessorSwitch(bool flag_open_token){
		this.match("#switch");
		array arr = [];
		
		while (!this.eof() and this.findToken('#case')){
			this.match("#case");
			rtl::array_push(arr, this.matchPreprocessorDirective());
		}
		
		this.match("#endswitch");
		
		if (rtl::count(arr) == 1) return arr[0];
		return BayrellCode::op_nope(arr);
	}
	
	
	
	/**
	 * Сканирует препроцессорные директивы
	 */
	json matchPreprocessorDirective(){		
		
		if (this.findToken('#switch')) return this.matchPreprocessorSwitch();
		else if (this.findToken('#ifcode')) return this.matchPreprocessorIfCode();
		else if (this.findToken('ifcode')) return this.matchPreprocessorIfCode();
		
		
		throw this.createError(BayrellParserBay.ERROR_UNKNOWN_PREPROCESSOR_DIRECTIVE, {
			'name': this._look_token,
		});
		
		return null;
	}
	
	
	
	/**
	 * Сканирует на наличие оператора
	 */
	json matchOperator(){
		
		if (this.findTokenVector(['#switch', '#ifcode'])){
			this._mathSemicolon = false;
			return this.matchPreprocessorDirective();
		}
		
		json flags = this.readFlags();
		
		/*string first_name = this.matchName();*/
		
		if (this.findToken('return')){
			this.match('return');
			
			var value = null;
			if (!this.findToken(';'))
				value = this.matchExpression();
			
			return BayrellCode::op_ret(value);
		}
		
		else if (this.findToken('class')){
			this.match('class');
			
			string name = this.getToken();
			string extend_name = null;
			
			if (this.findToken('extends')){
				this.match('extends');
				extend_name = this.getToken();
			}
			
			json code_tree = this.matchOperatorsBlock();
			this._mathSemicolon = false;
			
			return BayrellCode::op_declare_class(name, extend_name, code_tree, flags);
		}
		
		else if (this.findToken('namespace')){
			this.match('namespace');
			
			string name = this.matchMultiName();
			return BayrellCode::op_namespace(name);
		}
		
		else if (this.findToken('package')){
			this.match('package');
			
			string name = this.matchMultiName();
			/*return BayrellCode::op_package(name);*/
			return null;
		}
		
		else if (this.findToken('use')){
			this.match('use');
			
			string name = this.matchMultiName();
			array arr = null;
			
			if (this.findToken('import')){
				this.match('import');
				
				arr = [];
				while (!this.eof()){
					string token = this.getToken();
					
					rtl::array_push(arr, token);
					
					if (this.findToken(',')){
						this.match(',');
					}
					else{
						break;
					}
					
				}
			}
			
			return BayrellCode::op_use(name, arr);
		}
		
		else if (this.findToken('if')){
			this.match('if');
			this.match('(');
			
			json expr = this.matchExpression();
			this.match(')');
			array code_true = this.matchOperatorsBlock();
			array code_false = null;
			array else_if = [];
			
			while (this.findToken('else') or this.isLookComment()){
				if (this.isLookComment()){
					this.getToken();
					continue;
				}
				
				else{
					this.match('else');
					
					if (this.findToken('if')){
						rtl::array_push(else_if, this.matchOperatorsBlock());
					}
					else{
						if (code_false != null){
							this.error("dublicate else");
						}
						code_false = this.matchOperatorsBlock();
					}
				}
			}
			
			this._mathSemicolon = false;
			
			return BayrellCode::op_if(expr, code_true, code_false, else_if);
		}
		
		else if (this.findToken('while')){
			this.match('while');
			this.match('(');
			json expr = this.matchExpression();
			this.match(')');
			json code_loop = this.matchOperatorsBlock();
			this._mathSemicolon = false;
			return BayrellCode::op_while(expr, code_loop);
		}
		
		else if (this.findToken('for')){
			this.match('for');
			this.match('(');
			
			json loop_init = null;
			json loop_name = this.matchName(['.', '::']);
			
			if ( this.isLookTokenIdentifier() ){
				string second_name = this.matchIdentifier();
				this.match('=');
				json code_tree = this.matchExpression();
				loop_init = BayrellCode::op_declare_var(second_name, loop_name, code_tree, {});
			}
			else if (this.findToken('=')){
				this.match('=');
				json code_tree = this.matchExpression();
				loop_init = BayrellCode::op_assign(loop_name, code_tree);
			}
			else {
				throw this.createError(BayrellParserBay.ERROR_UNKNOWN_IDENT, {
					'name': this._look_token,
				});
			}
			
			this.match(';');
			
			json loop_expression = this.matchExpression();
			this.match(';');
			
			json loop_inc = this.matchOperator();
			this.match(')');
			
			array childs = this.matchOperatorsBlock();
			this._mathSemicolon = false;
			return BayrellCode::op_for(loop_init, loop_expression, loop_inc, childs);
		}
		
		else if (this.findToken('foreach')){
			this.match('foreach');
			this.match('(');
			
			string key_type, key_name, value_type, value_name;
			
			value_type = this.getToken();
			value_name = this.getToken();
			key_type = '';
			key_name = '';
			
			if (this.findToken(',')){
				this.match(',');
				key_type = value_type;
				key_name = value_name;
				value_type = this.getToken();
				value_name = this.getToken();
			}
			
			this.match('in');
			json arr_name = this.matchName();
			this.match(')');
			array childs = this.matchOperatorsBlock();
			
			this._mathSemicolon = false;
			return BayrellCode::op_foreach(key_type, key_name, value_type, value_name, arr_name, childs);
		}
		
		else if (this.findToken('throw')){
			this.match('throw');
			json expr = this.matchExpression();
			return BayrellCode::op_throw(expr);
		}
		
		else if (this.findToken('break')){
			this.match('break');
			return BayrellCode::op_break();
		}
		
		else if (this.findToken('continue')){
			this.match('continue');
			return BayrellCode::op_continue();
		}
		
		else if (this.findToken('delete')){
			this.match('delete');
			json name = this.matchName(['.', '::', '[']);
			return BayrellCode::op_del(name);
		}
		
		else if (this.findToken(';')){
			this.match(';');
			return null;
		}
		
		else if (this.findToken('++')){
			this.match('++');
			json first_name = this.matchName(['.', '::']);
			return BayrellCode::op_inc(first_name);
		}
		else if (this.findToken('--')){
			this.match('--');
			json first_name = this.matchName(['.', '::']);
			return BayrellCode::op_dec(first_name);
		}
		
		
		json first_name = this.matchName(['.', '::', '[', '<']);
		
		/* Match SubOperator */
		if (this.findToken('=')){
			this.match('=');
			json code_tree = this.matchExpression();
			return BayrellCode::op_assign(first_name, code_tree);
		}
		
		else if (this.findToken('++')){
			this.match('++');
			return BayrellCode::op_inc(first_name);
		}
		else if (this.findToken('--')){
			this.match('--');
			return BayrellCode::op_dec(first_name);
		}
		
		else if (this.findToken('+=')){
			this.match('+=');
			json code_tree = this.matchExpression();
			return BayrellCode::op_assign_inc(first_name, code_tree);
		}
		
		else if (this.findToken('~=')){
			this.match('~=');
			json code_tree = this.matchExpression();
			return BayrellCode::op_assign_concat(first_name, code_tree);
		}
		
		else if (this.findToken('-=')){
			this.match('-=');
			json code_tree = this.matchExpression();
			return BayrellCode::op_assign_dec(first_name, code_tree);
		}
		
		else if (this.findToken(';')){
			return first_name;
		}
		
		else if ( this.findTokenVector( ['('] ) ){
			
			array arr=[];
			if (first_name['op'] == BayrellCode::OP_LOAD){
				rtl::array_push(arr, first_name);
			}
			else if (first_name['op'] == BayrellCode::OP_LOAD_NAMES or 
					first_name['op'] == BayrellCode::OP_LOAD_NAMES_CALC){
				arr = clone first_name['arr'];
			}
			else{
				throw this.createError(self::ERROR_UNKNOWN_OP_CODE, {});
			}
			
			string name = "";
			json pos = null;
			array args = [];
			
			while ( this.findTokenVector( ['.', '::', '[', '('] ) ){
			
				if ( this.findToken('.') ){
					this.match('.');
					name = this.matchToken();
					rtl::array_push(arr, BayrellCode::op_load_dynamic(name));
				}
				
				else if ( this.findToken('::') ){
					this.match('::');
					name = this.matchToken();
					rtl::array_push(arr, BayrellCode::op_load_static(name));
				}
				
				else if ( this.findToken('[') ){
					this.match('[');
					pos = this.matchExpression();
					this.match(']');
					rtl::array_push(arr, BayrellCode::op_load_arr(pos));
				}
				
				else if ( this.findToken('(') ){
					this.match('(');
					args = this.matchCallArgs();
					this.match(')');
					rtl::array_push(arr,  BayrellCode::op_call(args));
				}
				
			}
			
			return BayrellCode::op_load_names(arr);
		}
		
		
		array arr = [];
		bool mathSemicolon = true;
		
		while (!this.eof()){
		
			flags['pointer'] = false;
			if ( this.findToken('&') ){
				this.match('&');
				flags['pointer'] = true;
			}
		
			string name = this.matchIdentifier();
			json code_tree = null;
			
			if (this.findToken('=')){
				this.match('=');
				code_tree = this.matchExpression();
				rtl::array_push(arr, BayrellCode::op_declare_var(name, first_name, code_tree, flags));
			}
			
			else if (this.findToken('(')){
				this.match('(');
				array args = this.matchDeclareArgs();
				this.match(')');
				
				json code_tree = null;
				if (flags['declare'] == false){
					code_tree = this.matchOperatorsBlock();
					this._mathSemicolon = false;
				}
				else
					this._mathSemicolon = true;
				
				rtl::array_push(arr, BayrellCode::op_declare_func(name, first_name, args, code_tree, flags));
			}
			
			else{
				rtl::array_push(arr, BayrellCode::op_declare_var(name, first_name, code_tree, flags));
			}
			
			if (this.findToken(',')){
				this.match(',');
			}
			else{
				break;
			}
		}
		
		if (rtl::count(arr) == 1) return arr[0];
		return BayrellCode::op_nope(arr);
	}
	
	
	
	/**
	 * Парсит блок операторов между {}
	 */
	json matchOperatorsBlock(){
		bool multi = false;
		
		if (this.findToken('{')){
			this.match('{');
			multi = true;
		}
		
		array code_tree = [];
		while (!this.findToken('}') and !this.eof()){
			rtl::array_push(code_tree, this.matchOperator());
			if (this._mathSemicolon or this.findToken(';'))
				this.match(';');
			this._mathSemicolon = true;
			if (!multi){
				break;
			}
		}
		
		if (multi){
			this.match('}');
		}
		
		return code_tree;
	}
	
	
	
	/**
	 * Парсит содержимое
	 */
	void runParser(){
		array arr = [];
		while (!this.eof()){
			rtl::array_push(arr, this.matchOperator());
			if (this._mathSemicolon)
				this.match(';');
			this._mathSemicolon = true;
		}
		if (rtl::count(arr) == 1) 
			this._code_tree = arr[0];
		else
			this._code_tree = BayrellCode::op_nope(arr);
	}
	
	
	
	/**
	 * Парсит контент выражение и возвращает code tree дерево
	 * @return {json} Дерево code tree
	 */
	json parseExpression (string content){
		this.setContent(content);
		this.reset();
		this._code_tree = this.matchExpression();
		return this._code_tree;
	}
	
}