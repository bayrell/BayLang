/*!
 *  Bayrell Common Languages Transcompiler
 *
 *  (c) Copyright 2016-2018 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayrellLang.LangBay;

use Runtime.rs;
use Runtime.ContextObject;
use BayrellLang.CoreTranslator;
use BayrellLang.OpCodes.BaseOpCode;
use BayrellLang.OpCodes.OpAdd;
use BayrellLang.OpCodes.OpAnd;
use BayrellLang.OpCodes.OpAssign;
use BayrellLang.OpCodes.OpAssignDeclare;
use BayrellLang.OpCodes.OpBitAnd;
use BayrellLang.OpCodes.OpBitNot;
use BayrellLang.OpCodes.OpBitOr;
use BayrellLang.OpCodes.OpBitXor;
use BayrellLang.OpCodes.OpBreak;
use BayrellLang.OpCodes.OpCall;
use BayrellLang.OpCodes.OpCallAwait;
use BayrellLang.OpCodes.OpChilds;
use BayrellLang.OpCodes.OpClassDeclare;
use BayrellLang.OpCodes.OpClassName;
use BayrellLang.OpCodes.OpClone;
use BayrellLang.OpCodes.OpComment;
use BayrellLang.OpCodes.OpCompare;
use BayrellLang.OpCodes.OpConcat;
use BayrellLang.OpCodes.OpContinue;
use BayrellLang.OpCodes.OpDelete;
use BayrellLang.OpCodes.OpDiv;
use BayrellLang.OpCodes.OpDynamic;
use BayrellLang.OpCodes.OpFlags;
use BayrellLang.OpCodes.OpFor;
use BayrellLang.OpCodes.OpFunctionArrowDeclare;
use BayrellLang.OpCodes.OpFunctionDeclare;
use BayrellLang.OpCodes.OpHexNumber;
use BayrellLang.OpCodes.OpIdentifier;
use BayrellLang.OpCodes.OpIf;
use BayrellLang.OpCodes.OpIfElse;
use BayrellLang.OpCodes.OpInterfaceDeclare;
use BayrellLang.OpCodes.OpMap;
use BayrellLang.OpCodes.OpMethod;
use BayrellLang.OpCodes.OpMod;
use BayrellLang.OpCodes.OpMult;
use BayrellLang.OpCodes.OpNamespace;
use BayrellLang.OpCodes.OpNew;
use BayrellLang.OpCodes.OpNope;
use BayrellLang.OpCodes.OpNot;
use BayrellLang.OpCodes.OpNumber;
use BayrellLang.OpCodes.OpOr;
use BayrellLang.OpCodes.OpPostDec;
use BayrellLang.OpCodes.OpPostInc;
use BayrellLang.OpCodes.OpPow;
use BayrellLang.OpCodes.OpPreDec;
use BayrellLang.OpCodes.OpPreInc;
use BayrellLang.OpCodes.OpPreprocessorSwitch;
use BayrellLang.OpCodes.OpReturn;
use BayrellLang.OpCodes.OpShiftLeft;
use BayrellLang.OpCodes.OpShiftRight;
use BayrellLang.OpCodes.OpStatic;
use BayrellLang.OpCodes.OpString;
use BayrellLang.OpCodes.OpStringItem;
use BayrellLang.OpCodes.OpStructDeclare;
use BayrellLang.OpCodes.OpSub;
use BayrellLang.OpCodes.OpTemplateIdentifier;
use BayrellLang.OpCodes.OpTernary;
use BayrellLang.OpCodes.OpThrow;
use BayrellLang.OpCodes.OpTryCatch;
use BayrellLang.OpCodes.OpUse;
use BayrellLang.OpCodes.OpVector;
use BayrellLang.OpCodes.OpWhile;


export class TranslatorBay extends CoreTranslator 
{
	
	public bool is_interface = false;
	public bool is_struct = false;
	public bool struct_read_only = false;
	Vector<string> current_function_name = null;
	public string current_class_name = "";
	public string current_namespace = "";
	
	
	/**
	 * Get name
	 */
	string getName(string name)
	{
		return name;
	}
	
	
	
	/**
	 * Escape string
	 */
	string convertString(string s){
		s = re::replace('\\\\', '\\\\', s);
		s = re::replace('"', '\\\"', s);
		s = re::replace('\n', '\\n', s);
		s = re::replace('\r', '\\r', s);
		s = re::replace('\t', '\\t', s);
		return s;
	}
	
	
	
	/**
	 * Convert string
	 */
	string convertString(string s)
	{
		return '"' ~ this.escapeString(s) ~ '"';
	}
	
	
	
	/** =========================== Identifier ============================ */
	
	
	/**
	 * HexNumber
	 */
	string OpHexNumber(OpHexNumber op_code)
	{
		this.setMaxOpCodeLevel();
		return op_code.value;
	}
	
	
	
	/**
	 * Identifier
	 */
	string OpIdentifier(OpIdentifier op_code)
	{
		this.setMaxOpCodeLevel();
		return this.getName(op_code.value);
	}
	
	
	
	/**
	 * Number
	 */
	string OpNumber(OpNumber op_code)
	{
		this.setMaxOpCodeLevel();
		return op_code.value;
	}
	
	
	
	/**
	 * String
	 */
	string OpString(OpString op_code)
	{
		this.setMaxOpCodeLevel();
		return this.convertString(op_code.value);
	}
	
	
	
	/**
	 * OpStringItem
	 */
	string OpStringItem(OpStringItem op_code)
	{
		return this.translateRun(op_code.value1) ~ this.n('[') ~ this.s( this.translateRun(op_code.value2) ) ~ ']';
	}
	
	
	
	/** ======================== Dynamic or static ======================== */
	
	
	
	/**
	 * Dynamic load
	 */
	string OpDynamic(OpDynamic op_code)
	{
		string res = this.o(this.translateRun(op_code.value), this.max_opcode_level) ~ '.' ~ op_code.name;
		this.setMaxOpCodeLevel();
		return res;
	}
	
	
	
	/**
	 * Static load
	 */
	string OpStatic(OpStatic op_code)
	{
		return this.translateRun(op_code.value) ~ '::' ~ op_code.name;
	}
	
	
	
	/**
	 * Template Identifier
	 */
	string OpTemplateIdentifier(OpTemplateIdentifier op_code)
	{
		return this.translateRun(op_code.t);
	}
	
	
	
	
	/** ============================ Operations ============================ */
	
	
	/**
	 * ADD
	 */
	string OpAdd(OpAdd op_code)
	{
		return this.op(op_code, '+', 13);
	}
	
	
	
	/**
	 * AND
	 */
	string OpAnd(OpAnd op_code)
	{ 
		return this.op(op_code, '&&', 6);
	}
	
	
	
	/**
	 * Bit AND
	 */
	string OpBitAnd(OpBitAnd op_code)
	{
		return this.op(op_code, '&', 9);
	}
	
	
	
	/**
	 * Bit NOT
	 */
	string OpBitNot(OpBitNot op_code)
	{
		string res = '!' ~ this.o(this.translateRun(op_code.value), 16);
		this.setOpCodeLevel(16);
		return res;
	}
	
	
	
	/**
	 * Bit OR
	 */
	string OpBitOr(OpBitOr op_code)
	{
		return this.op(op_code, '|', 7);
	}
	
	
	
	/**
	 * Bit XOR
	 */
	string OpBitXor(OpBitXor op_code)
	{
		return this.op(op_code, '^', 8);
	}
	
	
	
	/**
	 * Concat strings
	 */
	string OpConcat(OpConcat op_code)
	{
		return this.op(op_code, '~', 13);
	}
	
	
	
	/**
	 * Divide
	 */
	string OpDiv(OpDiv op_code)
	{
		return this.op(op_code, '/', 14);
	}
	
	
	
	/**
	 * Module
	 */
	string OpMod(OpMod op_code)
	{
		return this.op(op_code, '%', 14);
	}
	
	
	
	/**
	 * Multiply
	 */
	string OpMult(OpMult op_code)
	{
		return this.op(op_code, '*', 14);
	}
	
	
	
	/**
	 * New
	 */
	string OpNew(OpNew op_code)
	{
		/* Function name */
		string s = "new " ~ this.translateRun(op_code.value);
		
		/* Call arguments */
		this.setMaxOpCodeLevel();
		this.beginOperation();
		s ~= "(";
		if (op_code.args != null)
		{
			string ch = "";
			for (int i=0; i<op_code.args.count(); i++)
			{
				BaseOpCode op = op_code.args.item(i);
				s ~= ch ~ this.s(this.translateRun(op));
				ch = ", ";
			}
		}
		s ~= this.s(")");
		this.endOperation();
		this.setOpCodeLevel(19);
		
		return s;
	}
	
	
	
	/**
	 * Not
	 */
	string OpNot(OpNot op_code)
	{
		string res = '!' ~ this.o(this.translateRun(op_code.value), 16);
		this.setOpCodeLevel(16);
		return res;
	}
	
	
	
	/**
	 * Or
	 */
	string OpOr(OpOr op_code)
	{
		return this.op(op_code, '||', 5);
	}
	
	
	
	/**
	 * Post decrement
	 */
	string OpPostDec(OpPostDec op_code)
	{
		string semicolon = this.isOperation() ? "" : ";";
		string res = this.o(this.translateRun(op_code.value), 17) ~ '--' ~ semicolon;
		this.setOpCodeLevel(17);
		return res;
	}
	
	
	
	/**
	 * Post increment
	 */
	string OpPostInc(OpPostInc op_code)
	{
		string semicolon = this.isOperation() ? "" : ";";
		string res = this.o(this.translateRun(op_code.value), 17) ~ '++' ~ semicolon;
		this.setOpCodeLevel(17);
		return res;
	}
	
	
	
	/**
	 * Pow
	 */
	string OpPow(OpPow op_code)
	{
		return this.op(op_code, '**', 15);
	}
	
	
	
	/**
	 * Pre decrement
	 */
	string OpPreDec(OpPreDec op_code)
	{
		string semicolon = this.isOperation() ? "" : ";";
		string res = '--' ~ this.o(this.translateRun(op_code.value), 16) ~ semicolon;
		this.setOpCodeLevel(16);
		return res;
	}
	
	
	
	/**
	 * Pre increment
	 */
	string OpPreInc(OpPreInc op_code)
	{
		string semicolon = this.isOperation() ? "" : ";";
		string res = '++' ~ this.o(this.translateRun(op_code.value), 16) ~ semicolon;
		this.setOpCodeLevel(16);
		return res;
	}
	
	
	
	/**
	 * Bit shift left
	 */
	string OpShiftLeft(OpShiftLeft op_code)
	{
		return this.op(op_code, '<<', 12);
	}
	
	
	
	/**
	 * Bit shift right
	 */
	string OpShiftRight(OpShiftRight op_code)
	{
		return this.op(op_code, '>>', 12);
	}
	
	
	
	/**
	 * Sub
	 */
	string OpSub(OpSub op_code)
	{
		return this.op(op_code, '-', 13);
	}
	
	
	
	/**
	 * Operator call function
	 */
	string OpCall(OpCall op_code)
	{
		string s = "";
		this.pushOneLine();
		this.beginOperation();
		s ~= this.translateRun(op_code.value);
		this.endOperation();
		
		/* Call arguments */
		string s_args = "";
		s ~= this.s("(");
		if (op_code.args != null)
		{
			string ch = "";
			for (int i=0; i<op_code.args.count(); i++)
			{
				BaseOpCode op = op_code.args.item(i);
				s_args ~= ch ~ this.s(this.translateRun(op));
				ch = ", ";
			}
		}
		s ~= this.s(s_args);
		s ~= this.s(")");
		
		if (not this.isOperation())
		{
			s ~= ";";
		}
		
		this.popOneLine();
		return s;
	}
	
	
	
	/**
	 * Operator call function
	 */
	string OpCompare(OpCompare op_code)
	{
		this.setOpCodeLevel(10);
		return this.op(op_code, op_code.condition, 10);
	}
	
	
	
	/**
	 * Operator call function
	 */
	string OpTernary(OpTernary op_code)
	{		
		string semicolon = this.isOperation() ? "" : ";";
		string res = 
			'(' ~ this.translateRun(op_code.condition) ~ ') ? ' ~
			'(' ~ this.s(this.translateRun(op_code.if_true)) ~ ') : ' ~
			'(' ~ this.s(this.translateRun(op_code.if_false)) ~ ')'
		;
		this.setOpCodeLevel(4);
		return res;
	}
	
	
	
	/** ========================== Vector and Map ========================= */
	
	
	/**
	 * Vector
	 */
	string OpVector(OpVector op_code)
	{
		string res = "";
		string ch = "";
		for (var i=0; i<op_code.values.count(); i++)
		{
			BaseOpCode item = op_code.values.item(i);
			this.setMaxOpCodeLevel();
			res ~= ch ~ this.s(this.translateRun(item));
			ch = ",";
		}
		this.setMaxOpCodeLevel();
		return this.n("[") ~ res ~ "]";
	}
	
	
	
	/**
	 * Map
	 */
	string OpMap(OpMap op_code)
	{
		string res = "";
		Vector<string> keys = op_code.values.keys();
		for (var i=0; i<op_code.values.count(); i++)
		{
			string key = keys.item(i);
			BaseOpCode item = op_code.values.item(key);
			this.setMaxOpCodeLevel();
			res ~= ch ~ this.s(this.convertString(key) ~ ": " ~ this.translateRun(item));
			ch = ",";
		}
		this.setMaxOpCodeLevel();
		return this.n("{") ~ res ~ "}";
	}
	
	
	
	/**
	 * Method
	 */
	string OpMethod(OpMethod op_code)
	{
		return "method " ~ this.translateRun(op_code.value);
	}
	
	
	
	/**
	 * Class name
	 */
	string OpClassName(OpClassName op_code)
	{
		return this.convertString(op_code.value);
	}
	
	
	
	/** ============================ Operators ============================ */
	
	
	/**
	 * Assign
	 */
	string OpAssign(OpAssign op_code)
	{
		bool old_is_operation = this.beginOperation();
		
		/* one line */
		this.pushOneLine(true);
		string res = this.translateRun(op_code.ident);
		this.popOneLine();
		
		if (op_code.op_name == "=") res ~= " = ";
		else if (op_code.op_name == "~=") res ~= " .= ";
		else if (op_code.op_name == "+=") res ~= " += ";
		else if (op_code.op_name == "-=") res ~= " -= ";
		
		/* result */
		this.setOpCodeLevel(0);
		res ~= this.s(this.translateRun(op_code.value));
		
		if (not old_is_operation) res ~= this.n(';');
		this.endOperation();
		
		return rs::trim(res);
	}
	
	
	
	/**
	 * Assign declare
	 */
	string OpAssignDeclare(OpAssignDeclare op_code)
	{
		bool old_is_operation = this.beginOperation();
		string res = "";
		
		/* one line */
		this.pushOneLine(true);
		res ~= this.translateRun(op_code.tp) ~ ' ';
		res ~= op_code.name;
		this.popOneLine();
		
		if (op_code.value == null)
		{
			this.setOpCodeLevel(0);
			res ~= ' = ' ~ this.s( this.translateRun(op_code.value) );
		}
		
		if (not old_is_operation) res ~= this.n(';');
		this.endOperation();
		
		return rs::trim(res);
	}
	
	
	
	/**
	 * Break
	 */
	string OpBreak(OpBreak op_code)
	{
		return "break;"; 
	}
	
	
	
	/**
	 * Clone
	 */
	string OpClone(OpClone op_code)
	{
		this.beginOperation();
		this.setOpCodeLevel(0);
		string res = "clone " ~ this.translateRun(op_code.value);
		this.endOperation();
		return rs::trim(res);
	}
	
	
	
	/**
	 * Continue
	 */
	string OpContinue(OpContinue op_code)
	{
		return "continue;"; 
	}
	
	
	
	/**
	 * Delete
	 */
	string OpDelete(OpDelete op_code)
	{
		this.beginOperation();
		this.setOpCodeLevel(0);
		string res = "delete " ~ this.translateRun(op_code.value);
		this.endOperation();
		return rs::trim(res);
	}
	
	
	
	/**
	 * For
	 */
	string OpFor(OpFor op_code)
	{
		string s = "";
		
		/* Header */
		this.beginOperation();
		s ~= this.n("for (" ~ 
			this.translateRun(op_code.loop_init) ~ "; " ~
			this.translateRun(op_code.loop_condition) ~ "; " ~
			this.translateRun(op_code.loop_inc) ~ ")"
		);
		s ~= this.n("{");
		this.endOperation();
		
		/* Childs */
		for (int i=0; i<op_code.childs.count(); i++)
		{
			BaseOpCode item = op_code.childs.item(i);
			s ~= this.s( this.translateRun(item) );
		}
		s ~= this.n("}");
		
		return rs::trim(s);
	}
	
	
	
	/**
	 * If
	 */
	string OpIf(OpIf op_code)
	{
		string s = "";
		
		/* Condition */
		this.beginOperation();
		s ~= this.n("if (" ~ this.translateRun(op_code.condition) ~ ")");
		s ~= this.n("{");
		this.endOperation();
		
		/* If true */
		for (int i=0; i<op_code.if_true.count(); i++)
		{
			BaseOpCode item = op_code.if_true.item(i);
			s ~= this.s( this.translateRun(item) );
		}
		s ~= this.n("}");
		
		
		/* If else */
		for (int i=0; i<op_code.if_else.count(); i++)
		{
			OpIfElse if_else = op_code.if_else.item(i);
			
			this.beginOperation();
			string res = "else if (" ~ this.translateRun(if_else.condition) ~ ")";
			res ~= this.n("{");
			this.endOperation();
			s ~= this.n(res);
			
			for (int j=0; j<if_else.if_true.count(); j++)
			{
				BaseOpCode item = if_else.if_true.item(j);
				s ~= this.s( this.translateRun(item) );
			}
			s ~= this.n("}");
		}
		
		
		/* If false */
		if (op_code.if_false != null)
		{
			s ~= this.n("else");
			s ~= this.n("{");
			for (int i=0; i<op_code.if_false.count(); i++)
			{
				BaseOpCode item = op_code.if_false.item(i);
				s ~= this.s( this.translateRun(item) );
			}
			s ~= this.n("}");
		}
		
		return rs::trim(s);
	}
	
	
	
	/**
	 * Return
	 */
	string OpReturn(OpReturn op_code)
	{
		this.beginOperation();
		this.setOpCodeLevel(0);
		string res = "return " ~ this.translateRun(op_code.value);
		this.endOperation();
		return rs::trim(res);
	}
	
	
	
	/**
	 * Throw
	 */
	string OpThrow(OpThrow op_code)
	{
		this.beginOperation();
		this.setOpCodeLevel(0);
		string res = "throw " ~ this.translateRun(op_code.value);
		this.endOperation();
		return rs::trim(res);
	}
	
	
	
	/**
	 * Try Catch
	 */
	string OpTryCatch(OpTryCatch op_code)
	{
		string s = "";
		
		s ~= "try";
		s ~= this.n("{");
		for (int i=0; i<op_code.op_try.count(); i++)
		{
			BaseOpCode item = op_code.op_try.item(i);
			s ~= this.s( this.translateRun(item) );
		}
		s ~= this.n("}");
		
		int try_catch_childs_sz = op_code.childs.count();
		string is_else = "";
		for (int i=0; i<try_catch_childs_sz; i++)
		{
			OpTryCatchChilds try_catch = op_code.childs.item(i);
			
			this.beginOperation();
			string tp = this.translateRun(try_catch.op_type);
			string name = this.translateRun(try_catch.op_ident);
			this.endOperation();
			
			/* catch childs */
			string catch_s = "";
			s ~= this.n("catch (" ~ tp ~ " " ~ name ~ ")");
			s ~= this.n("{");
			for (int j=0; j<try_catch.childs.count(); j++)
			{
				BaseOpCode item = op_code.op_try.item(i);
				catch_s ~= this.s( this.translateRun(item) );
			}
			s ~= this.s(catch_s);
			s ~= this.n("}"); 
		}
		
		return rs::trim(s);
	}
	
	
	
	/**
	 * While
	 */
	string OpWhile(OpWhile op_code)
	{
		string s = "";
		
		/* Condition */
		this.beginOperation();
		s ~= this.n("while (" ~ this.translateRun(op_code.condition) ~ ")");
		s ~= this.n("{");
		this.endOperation();
		
		/* Childs */
		for (int i=0; i<op_code.childs.count(); i++)
		{
			BaseOpCode item = op_code.childs.item(i);
			s ~= this.s( this.translateRun(item) );
		}
		s ~= "}";
		
		return s;
	}
	
	
	
	
	/** ======================== Namespace and use ======================== */
	
	
	/**
	 * Namespace
	 */
	string OpNamespace(OpNamespace op_code)
	{
		this.current_namespace = op_code.value;
		return "namespace " ~ op_code.value ~ ";";
	}
	
	
	
	/**
	 * Use
	 */
	string OpUse(OpUse op_code)
	{
		string lib_name = op_code.value;
		return "use " ~ lib_name ~ ";";
	}
	
	
	
	
	/** ============================= Classes ============================= */
	
	
	
	/**
	 * Function arrow declare
	 */
	string OpFunctionArrowDeclare(OpFunctionArrowDeclare op_code)
	{
		string res = "";
		string ch = "";
		Vector<string> use_vars = new Vector();
		
		/* Skip if declare function */
		if (op_code.isFlag("declare"))
		{
			return "";
		}
		
		/* Static function */
		if (op_code.isFlag("static"))
		{
			res ~= "static function ";
			if (this.current_function_name.count() == 0)
			{
				this.current_function_is_static = true;
			}
		}
		else{
			res ~= "function ";
			if (this.current_function_name.count() == 0)
			{
				this.current_function_is_static = false;
			}	
			/*
			if (!this.current_function_is_static and this.current_function_name.count() > 0){
				use_vars.push("$this");
			}*/
		}
		
		/* Function Header */
		this.current_function_name.push(op_code.name);
		res ~= op_code.name;
		res ~= "(";
		for (int i=0; i<op_code.args.count(); i++)
		{
			OpAssignDeclare variable = op_code.args.item(i);
			this.pushOneLine(true);
			res ~= ch ~ "$" ~ variable.name;
			if (variable.value != null)
			{
				res ~= " = " ~ this.translateRun(variable.value);
			}
			this.popOneLine();
			use_vars.push(variable.name);
			ch = ", ";
		}
		res ~= ")";
		res ~= "{";
		this.pushOneLine();
		
		res ~= this.s("return ");
		res ~= this.OpFunctionDeclare(op_code.return_function, true, use_vars);
		res ~= this.s("}");
		this.popOneLine();
		this.current_function_name.pop();
		
		return res;
	}
	
	
	
	/**
	 * Function declare
	 */
	string OpFunctionDeclare(OpFunctionDeclare op_code, bool end_semicolon = false, Vector<string> use_vars = null)
	{
		string res = "";
		string ch = "";
		string s = "";
		
		/* Skip if declare function */
		if (op_code.isFlag("declare"))
		{
			return "";
		}
		
		/* Static function */
		if (op_code.isFlag("static"))
		{
			res ~= "static function ";
			if (this.current_function_name.count() == 0)
			{
				this.current_function_is_static = true;
			}
		}
		else
		{
			res ~= "function ";
			if (this.current_function_name.count() == 0)
			{
				this.current_function_is_static = false;
			}
		}
		
		/* Header */
		if (op_code.name == 'constructor')
		{
			res ~= '__construct';
		}
		else if (op_code.name == 'destructor')
		{
			res ~= '__destruct';
		}
		else{
			res ~= op_code.name;
		}
		this.current_function_name.push(op_code.name);
		this.pushOneLine(true);
		res ~= "(";
		for (int i=0; i<op_code.args.count(); i++)
		{
			OpAssignDeclare variable = op_code.args.item(i);
			res ~= ch ~ "$" ~ variable.name;
			if (variable.value != null){
				res ~= " = " ~ this.translateRun(variable.value);
			}
			ch = ", ";
		}
		res ~= ")";
		
		bool flag_use = false;
		if (this.current_function_name.count() == 2 and !this.current_function_is_static)
		{
			if (use_vars == null)
			{
				Vector<string> use_vars = new Vector();
			}
			/*use_vars.prepend("$this");*/
		}
		if (use_vars != null)
		{
			if (use_vars.count() > 0) flag_use = true;
		}
		if (op_code.use_variables != null)
		{
			if (op_code.use_variables.count() > 0) flag_use = true;
		}		
		
		if (flag_use)
		{
			ch = "";
			res ~= " use (";
			if (use_vars != null)
			{
				for (int i=0; i<use_vars.count(); i++)
				{
					res ~= ch ~ "&$" ~ use_vars.item(i);
					ch = ", ";
				}
			}
			if (op_code.use_variables != null)
			{
				for (int i=0; i<op_code.use_variables.count(); i++)
				{
					res ~= ch ~ "&$" ~ op_code.use_variables.item(i);
					ch = ", ";
				}
			}
			res ~= ")";
		}
		this.popOneLine();
		
		if (this.is_interface)
		{
			res ~= ";";
		}
		else
		{
			res ~= "{";
			this.pushOneLine(false);
			
			/* Childs */
			if (op_code.childs != null)
			{
				for (int i=0; i<op_code.childs.count(); i++)
				{
					res ~= this.s(this.translateRun(op_code.childs.item(i)));
				}
			}
			
			res ~= this.s("}" ~ (end_semicolon ? ";" : ""));
			this.popOneLine();
		}
		
		
		this.current_function_name.pop();
		
		return res;
	}
	
	
	
	/**
	 * Class declare header
	 */
	string OpClassDeclareHeader(OpClassDeclare op_code)
	{
		string res = "";
		
		bool old_is_operation = this.beginOperation();
		if (this.is_interface)
		{
			res ~= "interface ";
		}
		else
		{
			res ~= "class ";
		}
		res ~= op_code.class_name;
		if (op_code.class_extends != "")
		{
			res ~= " extends " ~ this.translateRun(op_code.class_extends);
		}
		/* Implements */
		if (op_code.class_implements != null and op_code.class_implements.count() > 0)
		{
			res ~= " implements ";
			string ch = "";
			for (int i=0; i<op_code.class_implements.count(); i++)
			{
				string name = op_code.class_implements.item(i);
				res ~= ch ~ this.getName(name);
				ch = ", ";
			}
		}
		res ~= "{";
		this.endOperation(old_is_operation);
		
		return res;
	}
	
	
	
	/**
	 * Class declare footer
	 */
	string OpClassDeclareFooter(OpClassDeclare op_code)
	{
	}
	
	
	
	/**
	 * Class init functions
	 */
	string OpClassInit(OpClassDeclare op_code)
	{
	}
	
	
	
	/**
	 * Class declare body
	 */
	string OpClassBody(OpClassDeclare op_code)
	{
		string res = "";
		for (int i=0; i<op_code.childs.count(); i++)
		{
			BaseOpCode item = op_code.childs.item(i);
			res ~= this.s( this.OpClassBodyItem(item) );
		}
		return res;
	}
	
	
	
	/**
	 * Class declare body item
	 */
	string OpClassBodyItem(BaseOpCode op_code)
	{
		if (op_code instanceof OpFunctionArrowDeclare)
		{
			return this.OpFunctionArrowDeclare(op_code);
		}
		else if (op_code instanceof OpFunctionDeclare)
		{
			return this.OpFunctionDeclare(op_code);
		}
		else if (op_code instanceof OpPreprocessorSwitch)
		{
			return this.OpPreprocessorSwitch(op_code);
		}
		else if (op_code instanceof OpComment)
		{
			return this.OpComment(op_code);
		}
		return "";
	}
	
	
	
	/**
	 * Class declare
	 */
	string OpClassDeclare(OpClassDeclare op_code)
	{
		string res = "";
		string s = "";
		
		/* Set current class name */
		this.current_class_name = op_code.class_name;
		
		/* Skip if declare class */
		if (op_code.isFlag("declare"))
		{
			return "";
		}
		
		/* Header */
		res ~= this.OpClassDeclareHeader(op_code);
		
		/* Body */
		res ~= this.OpClassBody(op_code);
		
		/* Class Init */
		res ~= this.OpClassInit(op_code);
		
		/* Footer class */
		res ~= this.s("}");
		
		/* Footer */
		res ~= this.OpClassDeclareFooter(op_code);
		
		return res;
	}
	
	
	
	/**
	 * Interface declare
	 */
	string OpInterfaceDeclare(OpInterfaceDeclare op_code)
	{
		this.is_interface = true;
		string res = this.OpClassDeclare(op_code);
		this.is_interface = false;
		return res;
	}
	
	
	
	/**
	 * Struct declare
	 */
	string OpStructDeclare(OpStructDeclare op_code)
	{
		this.is_struct = true;
		this.struct_read_only = op_code.is_readonly;
		string res = this.OpClassDeclare(op_code);
		this.is_struct = false;
		return res;
	}
	
	
	
	/**
	 * Reset translator to default settings
	 */
	void resetTranslator()
	{
		parent();
		this.current_function_name = new Vector<string>();
	}
	
}