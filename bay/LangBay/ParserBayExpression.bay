/*!
 *  Bayrell Language
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Bayrell.Lang.LangBay;

use Bayrell.Lang.Caret;
use Bayrell.Lang.CoreToken;
use Bayrell.Lang.Exceptions.ParserError;
use Bayrell.Lang.Exceptions.ParserExpected;
use Bayrell.Lang.LangBay.ParserBay;
use Bayrell.Lang.OpCodes.BaseOpCode;
use Bayrell.Lang.OpCodes.OpAttr;
use Bayrell.Lang.OpCodes.OpCall;
use Bayrell.Lang.OpCodes.OpIdentifier;
use Bayrell.Lang.OpCodes.OpInc;
use Bayrell.Lang.OpCodes.OpMath;
use Bayrell.Lang.OpCodes.OpMethod;
use Bayrell.Lang.OpCodes.OpPipe;
use Bayrell.Lang.OpCodes.OpPreprocessorIfDef;
use Bayrell.Lang.OpCodes.OpString;
use Bayrell.Lang.OpCodes.OpTernary;


static class ParserBayExpression
{
	
	/**
	 * Read bit not
	 */
	pure list<ParserBay, BaseOpCode> readBitNot(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		Caret caret_start = token.caret_start.clone();
		if (token.content == "!")
		{
			BaseOpCode op_code = null;
			list res = parser.parser_base::readDynamic(look.clone()); parser = res[0]; op_code = res[1];
			return 
			[
				parser,
				new OpMath
				{
					"value1": op_code,
					"math": "!",
					"caret_start": caret_start,
					"caret_end": parser.caret.clone(),
				}
			];
		}
		return parser.parser_base::readDynamic(parser);
	}
	
	
	
	/**
	 * Read bit shift
	 */
	pure list<ParserBay, BaseOpCode> readBitShift(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		BaseOpCode look_value = null;
		
		list res = static::readBitNot(parser); parser = res[0]; op_code = res[1];
		Caret caret_start = op_code.caret_start.clone();
		string math = "";
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		while (
			not token.eof and (
				token.content == ">>" or
				token.content == "<<" 
			)
		)
		{
			math = token.content;
			list res = static::readBitNot(look); look = res[0]; look_value = res[1];
			op_code = new OpMath
			{
				"value1": op_code,
				"value2": look_value,
				"math": math,
				"caret_start": caret_start,
				"caret_end": look.caret.clone(),
			};
			parser = look.clone();
			list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read bit and
	 */
	pure list<ParserBay, BaseOpCode> readBitAnd(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		BaseOpCode look_value = null;
		
		list res = static::readBitShift(parser); parser = res[0]; op_code = res[1];
		Caret caret_start = op_code.caret_start.clone();
		string math = "";
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		while (not token.eof and token.content == "&")
		{
			math = token.content;
			list res = static::readBitShift(look); look = res[0]; look_value = res[1];
			op_code = new OpMath
			{
				"value1": op_code,
				"value2": look_value,
				"math": math,
				"caret_start": caret_start,
				"caret_end": look.caret.clone(),
			};
			parser = look.clone();
			list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read bit or
	 */
	pure list<ParserBay, BaseOpCode> readBitOr(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		BaseOpCode look_value = null;
		
		list res = static::readBitAnd(parser); parser = res[0]; op_code = res[1];
		Caret caret_start = op_code.caret_start.clone();
		string math = "";
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		while (not token.eof and (token.content == "|" or token.content == "xor"))
		{
			math = token.content;
			list res = static::readBitAnd(look); look = res[0]; look_value = res[1];
			op_code = new OpMath
			{
				"value1": op_code,
				"value2": look_value,
				"math": math,
				"caret_start": caret_start,
				"caret_end": look.caret.clone(),
			};
			parser = look.clone();
			list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read factor
	 */
	pure list<ParserBay, BaseOpCode> readFactor(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		BaseOpCode look_value = null;
		
		list res = static::readBitOr(parser); parser = res[0]; op_code = res[1];
		Caret caret_start = op_code.caret_start.clone();
		string math = "";
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		while (
			not token.eof and (
				token.content == "*" or
				token.content == "/" or 
				token.content == "%" or
				token.content == "div" or
				token.content == "mod"
			)
		)
		{
			math = token.content;
			list res = static::readBitOr(look); look = res[0]; look_value = res[1];
			op_code = new OpMath
			{
				"value1": op_code,
				"value2": look_value,
				"math": math,
				"caret_start": caret_start,
				"caret_end": look.caret.clone(),
			};
			parser = look.clone();
			list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read arithmetic
	 */
	pure list<ParserBay, BaseOpCode> readArithmetic(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		BaseOpCode look_value = null;
		
		list res = static::readFactor(parser); parser = res[0]; op_code = res[1];
		Caret caret_start = op_code.caret_start.clone();
		string math = "";
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		while (not token.eof and (token.content == "+" or token.content == "-"))
		{
			math = token.content;
			list res = static::readFactor(look); look = res[0]; look_value = res[1];
			op_code = new OpMath
			{
				"value1": op_code,
				"value2": look_value,
				"math": math,
				"caret_start": caret_start,
				"caret_end": look.caret.clone(),
			};
			parser = look.clone();
			list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read concat
	 */
	pure list<ParserBay, BaseOpCode> readConcat(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		BaseOpCode look_value = null;
		
		list res = static::readArithmetic(parser); parser = res[0]; op_code = res[1];
		Caret caret_start = op_code.caret_start.clone();
		string math = "";
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		while (not token.eof and token.content == "~")
		{
			math = token.content;
			list res = static::readArithmetic(look); look = res[0]; look_value = res[1];
			op_code = new OpMath
			{
				"value1": op_code,
				"value2": look_value,
				"math": math,
				"caret_start": caret_start,
				"caret_end": look.caret.clone(),
			};
			parser = look.clone();
			list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read compare
	 */
	pure list<ParserBay, BaseOpCode> readCompare(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		BaseOpCode look_value = null;
		
		list res = static::readConcat(parser); parser = res[0]; op_code = res[1];
		Caret caret_start = op_code.caret_start.clone();
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		string content = token.content;
		if (
			content == "===" or content == "!==" or content == "==" or
			content == "!=" or content == ">=" or content == "<=" or
			content == ">" or content == "<"
		)
		{
			string math = token.content;
			list res = static::readConcat(look); look = res[0]; look_value = res[1];
			op_code = new OpMath
			{
				"value1": op_code,
				"value2": look_value,
				"math": math,
				"caret_start": caret_start,
				"caret_end": parser.caret.clone(),
			};
			parser = look.clone();
		}
		else if (content == "is" or content == "implements" or content == "instanceof")
		{
			string math = token.content;
			list res = parser.parser_base::readTypeIdentifier(look); look = res[0]; look_value = res[1];
			op_code = new OpMath
			{
				"value1": op_code,
				"value2": look_value,
				"math": math,
				"caret_start": caret_start,
				"caret_end": parser.caret.clone(),
			};
			parser = look.clone();
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read not
	 */
	pure list<ParserBay, BaseOpCode> readNot(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		Caret caret_start = token.caret_start.clone();
		if (token.content == "not")
		{
			BaseOpCode op_code = null;
			ParserBay start = parser.clone();
			list res = static::readCompare(look.clone()); parser = res[0]; op_code = res[1];
			return 
			[
				parser,
				new OpMath
				{
					"value1": op_code,
					"math": "not",
					"caret_start": caret_start,
					"caret_end": parser.caret.clone(),
				}
			];
		}
		return static::readCompare(parser);
	}
	
	
	
	/**
	 * Read and
	 */
	pure list<ParserBay, BaseOpCode> readAnd(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		BaseOpCode look_value = null;
		
		list res = static::readNot(parser); parser = res[0]; op_code = res[1];
		Caret caret_start = op_code.caret_start.clone();
		string math = "";
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		while (not token.eof and (token.content == "and" or token.content == "&&"))
		{
			math = token.content;
			list res = static::readNot(look); look = res[0]; look_value = res[1];
			op_code = new OpMath
			{
				"value1": op_code,
				"value2": look_value,
				"math": "and",
				"caret_start": caret_start,
				"caret_end": look.caret.clone(),
			};
			parser = look.clone();
			list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read or
	 */
	pure list<ParserBay, BaseOpCode> readOr(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		BaseOpCode look_value = null;
		
		list res = static::readAnd(parser); parser = res[0]; op_code = res[1];
		Caret caret_start = op_code.caret_start.clone();
		string math = "";
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		while (not token.eof and (token.content == "or" or token.content == "||"))
		{
			math = token.content;
			list res = static::readAnd(look); look = res[0]; look_value = res[1];
			op_code = new OpMath
			{
				"value1": op_code,
				"value2": look_value,
				"math": "or",
				"caret_start": caret_start,
				"caret_end": look.caret.clone(),
			};
			parser = look.clone();
			list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read element
	 */
	pure list<ParserBay, BaseOpCode> readElement(ParserBay parser)
	{
		/* Try to read function */
		if (parser.parser_operator::tryReadFunction(parser.clone(), false))
		{
			return parser.parser_operator::readDeclareFunction(parser, false);
		}
		return static::readOr(parser);
	}
	
	
	
	/**
	 * Read ternary operation
	 */
	pure list<ParserBay, BaseOpCode> readTernary(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		BaseOpCode condition = null;
		BaseOpCode if_true = null;
		BaseOpCode if_false = null;
		
		list res = static::readElement(parser); parser = res[0]; op_code = res[1];
		Caret caret_start = op_code.caret_start.clone();
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		if (token.content == '?')
		{
			condition = op_code;
			list res = static::readExpression(look); parser = res[0]; if_true = res[1];
			
			list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
			if (token.content == ':')
			{
				list res = static::readExpression(look); parser = res[0]; if_false = res[1];
			}
			
			op_code = new OpTernary({
				"condition": condition,
				"if_true": if_true,
				"if_false": if_false,
				"caret_start": caret_start,
				"caret_end": parser.caret.clone(),
			});
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read pipe call
	 */
	pure list<ParserBay, BaseOpCode> readPipeCall(ParserBay parser, bool is_method = false)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		bool is_context_call = true;
		Caret caret_start = parser.caret;
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		if (token.content == "@")
		{
			is_context_call = false;
			parser = look;
		}
		
		Caret caret_start2 = parser.caret;
		Collection<BaseOpCode> args = null;
		list res = parser.parser_base::readIdentifier(parser); parser = res[0]; op_code = res[1];
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		
		if (token.content == "::")
		{
			if (is_method)
			{
				throw new ParserError("second :: are not allowed", parser.caret, parser.file_name);
			}
			
			list res = parser.parser_base::readToken(look); look = res[0]; token = res[1];
			op_code = new OpMethod
			{
				"value1": op_code.value,
				"value2": token.content,
				"kind": OpMethod::KIND_STATIC,
				"caret_start": caret_start2,
				"caret_end": parser.caret,
			}
		}
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		if (token.content == "(" or token.content == "{")
		{
			list res = parser.parser_base::readCallArgs(parser); parser = res[0]; args = res[1];
			op_code = new OpCall
			{
				"obj": op_code,
				"args": args,
				"caret_start": caret_start,
				"caret_end": parser.caret,
				"is_context": is_context_call,
			};
		}
		
		return
		[
			parser,
			op_code
		];
	}
	
	
	
	/**
	 * Read pipe
	 */
	pure list<ParserBay, BaseOpCode> ExpressionPipe(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken look_token = null;
		BaseOpCode op_code = null;
		bool is_next_attr = false;
		
		list res = static::readTernary(parser); parser = res[0]; op_code = res[1];
		Caret caret_start = op_code.caret_start;
		
		list res = parser.parser_base::readToken(parser); look = res[0]; look_token = res[1];
		if (look_token.content == '|>')
		{
			while (look_token.content == '|>' or look_token.content == ',')
			{
				parser = look;
				BaseOpCode value = null;
				string kind = "";
				bool is_async = false;
				
				if (look_token.content == ',')
				{
					is_next_attr = true;
				}
				
				list res = parser.parser_base::readToken(parser); look = res[0]; look_token = res[1];
				if (look_token.content == 'await')
				{
					is_async = true;
					parser = look;
					list res = parser.parser_base::readToken(parser); look = res[0]; look_token = res[1];
				}
				
				if (look_token.content == 'attr')
				{
					parser = look;
					list res = static::readTernary(parser); parser = res[0]; value = res[1];
					kind = OpPipe::KIND_ATTR;
				}
				else if (look_token.content == '"' or look_token.content == "'")
				{
					list res = static::readTernary(parser); parser = res[0]; value = res[1];
					kind = OpPipe::KIND_ATTR;
				}
				else if (look_token.content == '{')
				{
					parser = look;
					list res = static::readTernary(parser); parser = res[0]; value = res[1];
					kind = OpPipe::KIND_ATTR;
					list res = parser.parser_base::matchToken(parser, '}'); parser = res[0];
				}
				else if (is_next_attr)
				{
					throw new ParserExpected("|>", parser.caret, parser.file_name);
				}
				else if (look_token.content == 'monad')
				{
					parser = look;
					list res = parser.parser_base::readDynamic(parser); parser = res[0]; value = res[1];
					kind = OpPipe::KIND_MONAD;
				}
				else if (look_token.content == 'default')
				{
					BaseOpCode arg1, arg2;
					kind = OpPipe::KIND_MONAD;
					
					list res = parser.parser_base::readIdentifier(look); parser = res[0]; arg1 = res[1];
					list res = static::readTernary(parser); parser = res[0]; arg2 = res[1];
					
					arg1 = new OpString
					{
						"value": parser::findModuleName(parser, arg1.value),
						"caret_start": arg1.caret_start,
						"caret_end": arg1.caret_end,
					};
					
					value = new OpCall
					{
						"args":
						[
							arg1,
							arg2
						],
						"obj": new OpAttr
						{
							"kind": OpAttr::KIND_STATIC,
							"obj": new OpIdentifier
							{
								"kind": OpIdentifier::KIND_MODULE,
								"caret_start": caret_start,
								"caret_end": parser.caret,
								"value": "rtl",
							},
							"value": new OpIdentifier
							{
								"caret_start": caret_start,
								"caret_end": parser.caret,
								"value": "m_to",
							},
							"caret_start": caret_start,
							"caret_end": parser.caret,
						},
						"caret_start": caret_start,
						"caret_end": parser.caret,
					}
					
				}
				else if (look_token.content == 'method' or look_token.content == ':' or look_token.content == '::')
				{
					parser = look;
					kind = OpPipe::KIND_CALL;
					
					/* Set pipe */
					bool save_find_ident = parser.find_ident;
					parser <= find_ident <= false;
					parser <= is_pipe <= true;
					
					list res = parser.parser_base::readDynamic(parser); parser = res[0]; value = res[1];
					
					/* Restore parser */
					parser <= is_pipe <= false;
					parser <= find_ident <= save_find_ident;
				}
				else
				{
					kind = OpPipe::KIND_CALL;
					list res = parser.parser_base::readDynamic(parser); parser = res[0]; value = res[1];
				}
				
				/*
				else if (look_token.content == 'method' or look_token.content == ':' or look_token.content == '::')
				{
					parser = look;
					kind = OpPipe::KIND_METHOD;
					list res = static::readPipeCall(parser); parser = res[0]; value = res[1];
				}
				else
				{
					kind = OpPipe::KIND_CALL;
					list res = parser.parser_base::readDynamic(parser); parser = res[0]; value = res[1];
					list res = static::readPipeCall(parser); parser = res[0]; value = res[1];
				}
				*/
				
				op_code = new OpPipe
				{
					"obj": op_code,
					"kind": kind,
					"value": value,
					"is_async": is_async,
					"caret_start": caret_start,
					"caret_end": parser.caret,
				};
				
				list res = parser.parser_base::readToken(parser); look = res[0]; look_token = res[1];
				is_next_attr = false;
			}
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read expression
	 */
	pure list<ParserBay, BaseOpCode> readExpression(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		if (token.content == "<")
		{
			return parser.parser_html::readHTML(parser);
		}
		else if (token.content == "@css")
		{
			return parser.parser_html::readCss(parser);
		}
		return static::ExpressionPipe(parser);
	}
}