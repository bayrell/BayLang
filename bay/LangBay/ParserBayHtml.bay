/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2025 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang.LangBay;

use Runtime.BaseObject;
use BayLang.Caret;
use BayLang.TokenReader;
use BayLang.LangBay.ParserBay;
use BayLang.OpCodes.BaseOpCode;
use BayLang.OpCodes.OpAssign;
use BayLang.OpCodes.OpDeclareClass;
use BayLang.OpCodes.OpDeclareFunction;
use BayLang.OpCodes.OpEntityName;
use BayLang.OpCodes.OpFor;
use BayLang.OpCodes.OpHtmlAttribute;
use BayLang.OpCodes.OpHtmlContent;
use BayLang.OpCodes.OpHtmlItems;
use BayLang.OpCodes.OpHtmlStyle;
use BayLang.OpCodes.OpHtmlTag;
use BayLang.OpCodes.OpIdentifier;
use BayLang.OpCodes.OpIf;
use BayLang.OpCodes.OpIfElse;
use BayLang.OpCodes.OpItems;
use BayLang.OpCodes.OpModule;
use BayLang.OpCodes.OpNamespace;
use BayLang.OpCodes.OpTypeIdentifier;


class ParserBayHtml extends BaseObject
{
	ParserBay parser = null;
	
	
	/**
	 * Constructor
	 */
	void constructor(ParserBay parser)
	{
		parent();
		this.parser = parser;
	}
	
	
	/**
	 * Read open string
	 */
	string readOpenString(TokenReader reader)
	{
		if (reader.nextToken() == "\"")
		{
			reader.matchToken("\"");
			return "\"";
		}
		else if (reader.nextToken() == "'")
		{
			reader.matchToken("'");
			return "'";
		}
		else
		{
			throw reader.expected("\"");
		}
	}
	
	
	/**
	 * Read attr value
	 */
	BaseOpCode readAttrValue(TokenReader reader, string key, string kind)
	{
		BaseOpCode value = null;
		if (kind == "type")
		{
			string open_tag = this.readOpenString(reader);
			value = this.parser.parser_base.readTypeIdentifier(reader, false);
			reader.matchToken(open_tag);
		}
		else if (kind == "template")
		{
			if (key == "name")
			{
				string open_tag = this.readOpenString(reader);
				value = this.parser.parser_base.readIdentifier(reader);
				reader.matchToken(open_tag);
			}
			else if (key == "args")
			{
				string open_tag = this.readOpenString(reader);
				value = this.parser.parser_function.readDeclareFunctionArgs(reader, false, open_tag);
				reader.matchToken(open_tag);
			}
			else
			{
				value = this.parser.parser_base.readString();
			}
		}
		else if (kind == "expression")
		{
			string next_token = reader.nextToken();
			if (next_token == "\"" or next_token == "'")
			{
				value = this.parser.parser_base.readString(reader);
			}
			else if (next_token == "{{")
			{
				reader.matchToken("{{");
				value = this.parser.parser_expression.readExpression(reader);
				reader.matchToken("}}");
			}
		}
		else if (kind == "function")
		{
			string open_tag = this.readOpenString(reader);
			value = this.parser.parser_operator.parse(reader, false, open_tag);
			value = new OpDeclareFunction
			{
				"content": value,
				"caret_start": value.caret_start,
				"caret_end": value.caret_end,
			};
			reader.matchToken(open_tag);
		}
		else
		{
			value = this.parser.parser_base.readString(reader);
		}
		return value;
	}
	
	
	/**
	 * Read attrs
	 */
	Collection<BaseOpCode> readAttrs(TokenReader reader, string kind)
	{
		Collection<BaseObject> attrs = [];
		reader.main_caret.skipToken();
		while (not reader.eof() and reader.main_caret.nextChar() != ">")
		{
			Caret caret_start = reader.start();
			bool is_system_attr = false;
			if (reader.nextToken() == "@")
			{
				is_system_attr = true;
				reader.matchToken("@");
			}
			BaseOpCode key = this.parser.parser_base.readIdentifier(reader);
			string key_value = is_system_attr ? "@" ~ key.value : key.value;
			reader.main_caret.skipToken();
			reader.init(reader.main_caret);
			reader.matchToken("=");
			BaseOpCode value = this.readAttrValue(
				reader, key_value, is_system_attr ? "function" : kind
			);
			reader.main_caret.skipToken();
			attrs.push(new OpHtmlAttribute{
				"key": key_value,
				"value": value,
				"caret_start": caret_start,
				"caret_end": reader.caret(),
			});
		}
		return attrs;
	}
	
	
	/**
	 * Read style
	 */
	BaseOpCode readStyle(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		reader.matchToken("<");
		reader.matchToken("style");
		reader.matchToken(">");
		reader.matchToken("</");
		reader.matchToken("style");
		reader.matchToken(">");
		
		return new OpHtmlStyle
		{
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read html content
	 */
	OpHtmlContent readHtmlContent(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		Caret caret = caret_start.copy();
		Collection tokens = ["</", "{{"];
		Collection<string> content = [];
		while (not reader.eof() and
			not caret.isNextChar("<") and tokens.indexOf(caret.nextString(2)) == -1
		)
		{
			content.push(caret.readChar());
		}
		
		reader.init(caret);
		
		return new OpHtmlContent
		{
			"value": rs::trim(rs::join("", content)),
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read html expression
	 */
	BaseOpCode readHtmlExpression(TokenReader reader)
	{
		reader.matchToken("{{");
		BaseOpCode expression = this.parser.parser_expression.readExpression(reader);
		reader.matchToken("}}");
		return expression;
	}
	
	
	/**
	 * Read html render
	 */
	BaseOpCode reaHtmlRender(TokenReader reader)
	{
		reader.matchToken("%render");
		BaseOpCode expression = this.parser.parser_expression.readExpression(reader);
		reader.matchToken(";");
		return expression;
	}
	
	
	/**
	 * Read html tag
	 */
	OpHtmlTag readHtmlTag(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		reader.matchToken("<");
		BaseOpCode tag_name = this.parser.parser_base.readIdentifier(reader);
		Collection<OpHtmlAttribute> attrs = this.readAttrs(reader, "expression");
		reader.matchToken(">");
		
		OpHtmlItems content = this.readHtml(reader);
		
		reader.matchToken("</");
		reader.matchToken(tag_name.value);
		reader.matchToken(">");
		
		return new OpHtmlTag
		{
			"attrs": attrs,
			"content": content,
			"tag_name": tag_name.value,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read HTML Assign
	 */
	BaseOpCode readHtmlAssign(TokenReader reader)
	{
		reader.matchToken("%set");
		OpAssign op_code = this.parser.parser_operator.readAssign(reader);
		reader.matchToken(";");
		return op_code;
	}
	
	
	/**
	 * Read HTML for
	 */
	BaseOpCode readHtmlFor(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		/* Read for */
		reader.matchToken("%for");
		reader.matchToken("(");
		
		/* Read assing */
		BaseOpCode expr1 = this.parser.parser_operator.readAssign(reader);
		reader.matchToken(";");
		
		/* Read expression */
		BaseOpCode expr2 = this.parser.parser_expression.readExpression(reader);
		reader.matchToken(";");
		
		/* Read operator */
		BaseOpCode expr3 = this.parser.parser_operator.readInc(reader);
		reader.matchToken(")");
		
		/* Read content */
		OpItems content = this.readHtml(reader, true, "}");
		
		/* Returns op_code */
		return new OpFor
		{
			"expr1": expr1,
			"expr2": expr2,
			"expr3": expr3,
			"content": content,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		}
	}
	
	
	/**
	 * Read HTML if
	 */
	BaseOpCode readHtmlIf(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		BaseOpCode if_true = null;
		BaseOpCode if_false = null;
		Collection if_else = [];
		
		/* Read condition */
		reader.matchToken("%if");
		reader.matchToken("(");
		BaseOpCode condition = this.parser.parser_expression.readExpression(reader);
		reader.matchToken(")");
		
		/* Read content */
		if_true = this.readHtml(reader, true, "}");
		this.parser.parser_base.skipComment(reader);
		
		/* Read content */
		Caret caret_last = null;
		Collection operations = ["%else", "%elseif"];
		while (not reader.eof() and (operations.indexOf(reader.nextToken()) >= 0))
		{
			string token = reader.readToken();
			if (token == "%elseif" or token == "%else" and reader.nextToken() == "if")
			{
				/* Read condition */
				if (reader.nextToken() == "if") reader.readToken();
				reader.matchToken("(");
				BaseOpCode if_else_condition = this.parser.parser_expression.readExpression(reader);
				reader.matchToken(")");
				
				/* Read content */
				BaseOpCode if_else_content = this.readHtml(reader, true, "}");
				
				/* Add op_code */
				if_else.push(new OpIfElse
				{
					"condition": if_else_condition,
					"content": if_else_content,
					"caret_start": caret_start,
					"caret_end": reader.caret(),
				});
			}
			else if (token == "%else")
			{
				if_false = this.readHtml(reader, true, "}");
			}
			caret_last = reader.caret();
			this.parser.parser_base.skipComment(reader);
		}
		
		/* Restore caret */
		if (caret_last) reader.init(caret_last);
		
		return new OpIf
		{
			"condition": condition,
			"if_true": if_true,
			"if_false": if_false,
			"if_else": if_else,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read HTML item
	 */
	BaseOpCode readHtmlItem(TokenReader reader)
	{
		string next_token = reader.nextToken();
		if (next_token == "<") return this.readHtmlTag(reader);
		else if (next_token == "{{") return this.readHtmlExpression(reader);
		else if (next_token == "%render") return this.reaHtmlRender(reader);
		else if (next_token == "%set") return this.readHtmlAssign(reader);
		else if (next_token == "%for") return this.readHtmlFor(reader);
		else if (next_token == "%if") return this.readHtmlIf(reader);
		return this.readHtmlContent(reader);
	}
	
	
	/**
	 * Read html
	 */
	OpHtmlItems readHtml(TokenReader reader, bool match_brackets = false, string end_tag = "")
	{
		Caret caret_start = reader.start();
		
		if (match_brackets) reader.matchToken("{");
		
		Collection items = [];
		while (not reader.eof() and reader.nextToken() != "</" and reader.nextToken() != end_tag)
		{
			BaseOpCode op_code_item = this.readHtmlItem(reader);
			items.push(op_code_item);
		}
		
		if (match_brackets) reader.matchToken("}");
		
		return new OpHtmlItems
		{
			"items": items,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read template
	 */
	BaseOpCode readTemplate(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		reader.matchToken("<");
		reader.matchToken("template");
		Collection attrs = this.readAttrs(reader, "template");
		reader.matchToken(">");
		
		OpHtmlItems content = this.readHtml(reader);
		
		reader.matchToken("</");
		reader.matchToken("template");
		reader.matchToken(">");
		
		OpIdentifier name = null;
		OpHtmlAttribute args = null;
		for (int i=0; i<attrs.count(); i++)
		{
			OpHtmlAttribute item = attrs.get(i);
			if (item.key == "name") name = item.value;
			else if (item.key == "args") args = item;
		}
		
		return new OpDeclareFunction
		{
			"name": name ? name.value : "render",
			"args": args ? args.value : null,
			"is_html": true,
			"content": content,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read script
	 */
	BaseOpCode readScript(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		reader.matchToken("<");
		reader.matchToken("script");
		Collection attrs = this.readAttrs(reader, "script");
		reader.matchToken(">");
		
		OpItems items = this.parser.parser_class.readBody(reader, false, "</");
		
		reader.matchToken("</");
		reader.matchToken("script");
		reader.matchToken(">");
		
		return items;
	}
	
	
	/**
	 * Read item
	 */
	BaseOpCode readItem(TokenReader reader)
	{
		Caret caret_save = reader.caret();
		reader.matchToken("<");
		string next_token = reader.nextToken();
		reader.init(caret_save);
		
		if (next_token == "style") return this.readStyle(reader);
		else if (next_token == "template") return this.readTemplate(reader);
		else if (next_token == "script") return this.readScript(reader);
		else throw reader.error("Unknown token " ~ next_token);
		return null;
	}
	
	
	/**
	 * Read class content
	 */
	BaseOpCode readContent(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		Collection items = [];
		while (not reader.eof() and reader.nextToken() != "</")
		{
			BaseOpCode op_code_item = this.readItem(reader);
			if (op_code_item instanceof OpItems) items.appendItems(op_code_item.items);
			else items.push(op_code_item);
		}
		
		return new OpItems
		{
			"items": items,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Parse HTML
	 */
	BaseOpCode parse(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		reader.matchToken("<");
		reader.matchToken("class");
		
		/* Read attrs */
		Collection<OpHtmlAttribute> attrs = this.readAttrs(reader, "type");
		OpTypeIdentifier class_name = attrs.find(bool (OpHtmlAttribute attr) => attr.key == "name");
		OpTypeIdentifier extend_name = attrs.find(
			bool (OpHtmlAttribute attr) => attr.key == "extends"
		);
		
		reader.matchToken(">");
		
		/* Read component content */
		BaseOpCode class_content = this.readContent(reader);
		
		/*string class_name_value = class_name.entity_name.items.last();*/
		string namespace_name = rs::join(".", class_name.value.entity_name.items
			.slice(0, class_name.value.entity_name.items.count() - 1)
			.map(string (OpIdentifier item) => item.value)
		);
		
		/* Change class name */
		class_name.value.entity_name.items = [ class_name.value.entity_name.items.last() ];
		
		/* Create items */
		Collection items = [
			new OpNamespace
			{
				"name": namespace_name,
				"caret_start": caret_start,
				"caret_end": reader.caret(),
			},
			new OpDeclareClass
			{
				"name": class_name.value,
				"kind": OpDeclareClass::KIND_CLASS,
				"class_extends": extend_name ? extend_name.value : null,
				"is_component": true,
				"content": class_content,
				"caret_start": caret_start,
				"caret_end": reader.caret(),
			},
		];
		
		return new OpModule
		{
			"items": items,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
}
