/*!
 *  Bayrell Language
 *
 *  (c) Copyright 2016-2019 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Bayrell.Lang.LangBay;

use Runtime.CoreObject;
use Runtime.CoreStruct;
use Runtime.Reference;
use Runtime.RuntimeUtils;
use Bayrell.Lang.Caret;
use Bayrell.Lang.CoreParser;
use Bayrell.Lang.CoreToken;
use Bayrell.Lang.LangBay.ParserBay;
use Bayrell.Lang.OpCodes.BaseOpCode;
use Bayrell.Lang.OpCodes.OpHtmlAttribute;
use Bayrell.Lang.OpCodes.OpHtmlContent;
use Bayrell.Lang.OpCodes.OpHtmlItems;
use Bayrell.Lang.OpCodes.OpHtmlTag;
use Bayrell.Lang.OpCodes.OpHtmlValue;
use Bayrell.Lang.OpCodes.OpIdentifier;
use Bayrell.Lang.OpCodes.OpString;


class ParserBayHtml extends CoreObject
{
	
	/**
	 * Read css selector
	 */
	lambda list<ParserBay, string> readCssSelector(ParserBay parser)
	{
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		string class_name = parser.current_namespace_name ~ "." ~ parser.current_class_name;
		string ch = rs::substr(content.ref, pos, 1);
		if (ch == "(")
		{
			pos = pos + 1;
			x = parser.parser_base::nextX(parser, ch, x);
			y = parser.parser_base::nextY(parser, ch, y);
			int start_pos = pos;
			while (pos < content_sz and ch != ")")
			{
				pos = pos + 1;
				x = parser.parser_base::nextX(parser, ch, x);
				y = parser.parser_base::nextY(parser, ch, y);
				ch = rs::substr(content.ref, pos, 1);
			}
			class_name = rs::substr(content.ref, start_pos, pos - start_pos);
			if (parser.uses.has(class_name))
			{
				class_name = parser.uses.item(class_name);
			}
			pos = pos + 1;
			x = parser.parser_base::nextX(parser, ch, x);
			y = parser.parser_base::nextY(parser, ch, y);
		}
		
		int start_pos = pos;
		ch = rs::substr(content.ref, pos, 1);
		while (
			pos < content_sz and ch != " " and ch != "," and 
			ch != "." and ch != ":" and ch != "[" and ch != "{"
		)
		{
			pos = pos + 1;
			x = parser.parser_base::nextX(parser, ch, x);
			y = parser.parser_base::nextY(parser, ch, y);
			ch = rs::substr(content.ref, pos, 1);
		}
		string postfix = rs::substr(content.ref, start_pos, pos - start_pos);
		string selector = "." ~ postfix ~ "-" ~ RuntimeUtils::getCssHash(class_name);
		Caret caret = new Caret{ "x": x, "y": y, "pos": pos };
		parser <= caret <= caret;
		return [parser, selector];
	}
	
	
	
	/**
	 * Read css
	 */
	lambda list<ParserBay, BaseOpCode> readCss(ParserBay parser)
	{
		Caret caret_start = parser.caret.clone();
		
		list res = parser.parser_base::matchToken(parser, "@css"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
		
		string css_str = "";
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		int bracket_level = 0;
		int start_pos = pos;
		
		string ch = rs::substr(content.ref, pos, 1);
		while (pos < content_sz and (ch != "}" or ch == "}" and bracket_level > 0))
		{
			/* If html or  tag */
			if (ch == "%")
			{
				x = parser.parser_base::nextX(parser, ch, x);
				y = parser.parser_base::nextY(parser, ch, y);
				pos = pos + 1;
				
				/* Add value */
				string value = rs::substr(content.ref, start_pos, pos - start_pos - 1);
				if (value != "") css_str ~= value;
				
				/* Read CSS Selector */
				Caret caret = new Caret{ "x": x, "y": y, "pos": pos };
				parser <= caret <= caret;
				list res = static::readCssSelector(parser);
				parser = res[0]; string s = res[1];
				css_str ~= s;
				
				/* Set pos, x, y */
				caret_start = parser.caret.clone();
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			else if (ch == "{")
			{
				/* Add value */
				string value = rs::substr(content.ref, start_pos, pos - start_pos);
				if (value != "") css_str ~= value;
				
				/* Read CSS Block */
				Caret caret = new Caret{ "x": x, "y": y, "pos": pos };
				parser <= caret <= caret;
				list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
				list res = parser.parser_base::readUntilStringArr(parser, ["}"], false);
				parser = res[0]; string s = res[1];
				list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
				css_str ~= "{" ~ s ~ "}";
				
				/* Set pos, x, y */
				caret_start = parser.caret.clone();
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			else
			{
				x = parser.parser_base::nextX(parser, ch, x);
				y = parser.parser_base::nextY(parser, ch, y);
				pos = pos + 1;
			}
			
			ch = rs::substr(content.ref, pos, 1);
		}
		
		/* Push item */
		string value = rs::substr(content.ref, start_pos, pos - start_pos);
		Caret caret = new Caret{ "x": x, "y": y, "pos": pos };
		if (value != "") css_str ~= value;
		
		parser <= caret <= caret;
		list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
		css_str = rs::replace("\t", "", css_str);
		css_str = rs::replace("\n", "", css_str);
		
		BaseOpCode op_code = new OpString
		{
			"caret_start": caret,
			"caret_end": parser.caret.clone(),
			"value": css_str,
		};
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read html value
	 */
	lambda list<ParserBay, BaseOpCode> readHTMLValue(ParserBay parser)
	{
		BaseOpCode item = null;
		Caret caret = parser.caret.clone();
		Reference<string> content = parser.content;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		string ch = rs::substr(content.ref, pos, 1);
		if (ch == "<")
		{
			list res = static::readHTMLTag(parser);
			parser = res[0]; item = res[1];
		}
		else if (ch == "{")
		{
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; item = res[1];
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
		}
		else if (ch == "@")
		{
			x = parser.parser_base::nextX(parser, ch, x);
			y = parser.parser_base::nextY(parser, ch, y);
			pos = pos + 1;
			
			string ch3 = rs::substr(content.ref, pos, 3);
			string ch4 = rs::substr(content.ref, pos, 4);
			if (ch3 == "raw" or ch4 == "json" or ch4 == "html")
			{
				list res;
				if (ch3 == "raw") res = parser.parser_base::next(parser, ch3, x, y, pos);
				if (ch4 == "json") res = parser.parser_base::next(parser, ch4, x, y, pos);
				if (ch4 == "html") res = parser.parser_base::next(parser, ch4, x, y, pos);
				x = res[0]; y = res[1]; pos = res[2];
			}
			
			caret = new Caret{ "x": x, "y": y, "pos": pos };
			parser <= caret <= caret;
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; item = res[1];
			
			if (ch3 == "raw")
			{
				item = new OpHtmlValue
				{
					"kind": OpHtmlValue::KIND_RAW,
					"value": item,
					"caret_start": caret,
					"caret_end": parser.caret.clone(),
				};
			}
			else if (ch4 == "json")
			{
				item = new OpHtmlValue
				{
					"kind": OpHtmlValue::KIND_JSON,
					"value": item,
					"caret_start": caret,
					"caret_end": parser.caret.clone(),
				};
			}
			else if (ch4 == "html")
			{
				item = new OpHtmlValue
				{
					"kind": OpHtmlValue::KIND_HTML,
					"value": item,
					"caret_start": caret,
					"caret_end": parser.caret.clone(),
				};
			}
			
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
		}
		
		return [parser, item];
	}
	
	
	
	/**
	 * Read html attribute key
	 */
	lambda list<ParserBay, string> readHTMLAttrKey(ParserBay parser)
	{
		CoreToken token = null;
		ParserBay look = null;
		OpIdentifier ident = null;
		string key = "";
		
		/* Look token */
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		if (token.content == "@")
		{
			parser = look.clone();
			key = "@";
		}
		
		list res = parser.parser_base::readIdentifier(parser); parser = res[0]; ident = res[1];
		key ~= ident.value;
		
		/* Read attr */
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		while (token.content == "-")
		{
			list res = parser.parser_base::readIdentifier(look.clone()); parser = res[0]; ident = res[1];
			key ~= "-" ~ ident.value;
			
			/* Look next token */
			list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		}
		
		/* Look token */
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		if (token.content == ":")
		{
			parser = look.clone();
			key ~= ":";
			list res = parser.parser_base::readIdentifier(parser); parser = res[0]; ident = res[1];
			key ~= ident.value;
		}
		
		return [parser, key];
	}
	
	
	
	/**
	 * Read html attribute value
	 */
	lambda list<ParserBay, BaseOpCode> readHTMLAttrValue(ParserBay parser)
	{
		CoreToken token = null;
		ParserBay look = null;
		BaseOpCode op_code = null;
		OpIdentifier ident = null;
		
		/* Look token */
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		if (token.content == "{")
		{
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; op_code = res[1];
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
		}
		else if (token.content == "@")
		{
			list res = static::readHTMLValue(parser);
			parser = res[0]; op_code = res[1];
		}
		else
		{
			list res = parser.parser_base::readString(parser); parser = res[0]; op_code = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read html attributes
	 */
	lambda list<ParserBay, BaseOpCode> readHTMLAttrs(ParserBay parser)
	{
		Vector<OpHtmlAttribute> items = new Vector();
		
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		Caret caret = parser.parser_base::skipChar(parser, content, parser.caret.clone());
		string ch = rs::substr(content.ref, caret.pos, 1);
		while (ch != ">" and caret.pos < content_sz)
		{
			Caret caret_start = caret;
			parser <= caret <= caret.clone();
			list res = static::readHTMLAttrKey(parser); parser = res[0]; string key = res[1];
			list res = parser.parser_base::matchToken(parser, "="); parser = res[0];
			list res = static::readHTMLAttrValue(parser); parser = res[0]; BaseOpCode value = res[1];
			items.push
			(
				new OpHtmlAttribute
				{
					"key": key,
					"value": value,
					"caret_start": caret_start,
					"caret_end": parser.caret.clone(),
				}
			);
			caret = parser.parser_base::skipChar(parser, content, parser.caret.clone());
			ch = rs::substr(content.ref, caret.pos, 1);
			string ch2 = rs::substr(content.ref, caret.pos, 2);
			if (ch2 == "/>") break;
		}
		
		return [parser, items.toCollection()];
	}
	
	
	
	/**
	 * Read html template
	 */
	lambda list<ParserBay, Collection> readHTMLContent(ParserBay parser, string end_tag)
	{
		Vector<BaseOpCode> items = new Vector();
		BaseOpCode item = null;
		CoreToken token = null;
		ParserBay look = null;
		Caret caret = null;
		Caret caret_start = parser.caret.clone();
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		int start_pos = pos;
		int end_tag_sz = rs::strlen(end_tag);
		string ch2 = rs::substr(content.ref, pos, end_tag_sz);
		while (ch2 != end_tag and pos < content_sz)
		{
			string ch = rs::substr(content.ref, pos, 1);
			
			/* If html or  tag */
			if (ch == "<" or ch == "{" or ch == "@")
			{
				string value = rs::substr(content.ref, start_pos, pos - start_pos);
				caret = new Caret{ "x": x, "y": y, "pos": pos };
				value = rs::trim(value, "\t\r\n");
				
				if (value != "")
				{
					item = new OpHtmlContent
					{
						"value": value,
						"caret_start": caret_start,
						"caret_end": caret,
					}
					items.push(item);
				}
				
				/* Read HTML Value */
				parser <= caret <= caret;
				list res = static::readHTMLValue(parser);
				parser = res[0]; item = res[1];
				items.push(item);
				
				/* Set pos, x, y */
				caret_start = parser.caret.clone();
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			else
			{
				x = parser.parser_base::nextX(parser, ch, x);
				y = parser.parser_base::nextY(parser, ch, y);
				pos = pos + 1;
			}
			ch2 = rs::substr(content.ref, pos, end_tag_sz);
		}
		
		/* Push item */
		string value = rs::substr(content.ref, start_pos, pos - start_pos);
		value = rs::trim(value, "\t\r\n");
		caret = new Caret{ "x": x, "y": y, "pos": pos };
		if (value != "")
		{
			item = new OpHtmlContent
			{
				"value": value,
				"caret_start": caret_start,
				"caret_end": caret,
			}
			items.push(item);
		}
		
		return [ parser.copy({ "caret": caret }), items ];
	}
	
	
	
	/**
	 * Read html tag
	 */
	lambda list<ParserBay, BaseOpCode> readHTMLTag(ParserBay parser)
	{
		CoreToken token = null;
		ParserBay look = null;
		OpIdentifier ident = null;
		Caret caret_items_start = null, caret_items_end = null;
		Caret caret_start = parser.caret.clone();
		Collection<BaseOpCode> items = null;
		BaseOpCode op_code_name = null;
		bool is_single_flag = false;
		bool op_code_flag = false;
		string tag_name = "";
		
		/* Tag start */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		
		/* Look token */
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		if (token.content == "{")
		{
			op_code_flag = true;
			Caret caret1 = parser.caret.clone();
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; op_code_name = res[1];
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
			Caret caret2 = parser.caret.clone();
			tag_name = rs::substr(parser.content.ref, caret1.pos, caret2.pos - caret1.pos);
		}
		else if (token.content == ">")
		{
			op_code_flag = true;
			tag_name = "";
		}
		else
		{
			list res = parser.parser_base::readIdentifier(parser, false);
			parser = res[0]; ident = res[1];
			tag_name = ident.value;
		}
		
		list res = static::readHTMLAttrs(parser); parser = res[0]; Collection<OpHtmlAttribute> attrs = res[1];
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		if (token.content == "/")
		{
			parser = look.clone();
			is_single_flag = true;
		}
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		if (not is_single_flag)
		{
			/* Read items */
			caret_items_start = parser.caret.clone();
			list res = static::readHTMLContent(parser, "</" ~ tag_name);
			parser = res[0]; Collection<BaseOpCode> items = res[1];
			caret_items_end = parser.caret.clone();
			
			/* Tag end */
			if (op_code_flag)
			{
				list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
				list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
				if (tag_name)
				{
					list res = parser.parser_base::matchString(parser, tag_name); parser = res[0];
				}
				list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
			}
			else
			{
				list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
				list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
				if (ident != null)
				{
					list res = parser.parser_base::matchToken(parser, ident.value); parser = res[0];
				}
				list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
			}
		}
		
		OpHtmlTag op_code = new OpHtmlTag
		{
			"attrs": attrs,
			"tag_name": tag_name,
			"op_code_name": op_code_name,
			"caret_start": caret_start,
			"caret_end": parser.caret.clone(),
			"items": (items != null) ? new OpHtmlItems
			{
				"caret_start": caret_items_start,
				"caret_end": caret_items_end,
				"items": items.toCollection()
			} : null,
		};
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read html template
	 */
	lambda list<ParserBay, BaseOpCode> readHTML(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		Vector<OpHtmlTag> items = new Vector();
		Caret caret_start = parser.caret.clone();
		
		list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
		string ch2 = rs::substr(parser.content.ref, parser.caret.pos, 2);
		while (not token.eof and token.content == "<" and ch2 != "</")
		{
			list res = static::readHTMLTag(parser); parser = res[0]; OpHtmlTag op_code = res[1];
			items.push(op_code);
			list res = parser.parser_base::readToken(parser.clone()); look = res[0]; token = res[1];
			Caret caret = parser.parser_base::skipChar(parser, parser.content, parser.caret.clone());
			ch2 = rs::substr(parser.content.ref, caret.pos, 2);
		}
		
		OpHtmlItems op_code = new OpHtmlItems
		{
			"caret_start": caret_start,
			"caret_end": parser.caret.clone(),
			"items": items.toCollection(),
		}
		
		return [parser, op_code];
	}
	
}
