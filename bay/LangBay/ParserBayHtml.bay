/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang.LangBay;

use Runtime.re;
use Runtime.lib;
use Runtime.BaseObject;
use Runtime.BaseStruct;
use Runtime.Reference;
use Runtime.RuntimeUtils;
use BayLang.Caret;
use BayLang.CoreParser;
use BayLang.CoreToken;
use BayLang.Exceptions.ParserError;
use BayLang.Exceptions.ParserExpected;
use BayLang.LangBay.ParserBay;
use BayLang.OpCodes.BaseOpCode;
use BayLang.OpCodes.OpAnnotation;
use BayLang.OpCodes.OpCall;
use BayLang.OpCodes.OpCollection;
use BayLang.OpCodes.OpComment;
use BayLang.OpCodes.OpDeclareClass;
use BayLang.OpCodes.OpDeclareFunction;
use BayLang.OpCodes.OpDeclareFunctionArg;
use BayLang.OpCodes.OpEntityName;
use BayLang.OpCodes.OpFlags;
use BayLang.OpCodes.OpHtmlAttribute;
use BayLang.OpCodes.OpHtmlContent;
use BayLang.OpCodes.OpHtmlItems;
use BayLang.OpCodes.OpHtmlMeta;
use BayLang.OpCodes.OpHtmlSlot;
use BayLang.OpCodes.OpHtmlStyle;
use BayLang.OpCodes.OpHtmlTag;
use BayLang.OpCodes.OpHtmlValue;
use BayLang.OpCodes.OpIdentifier;
use BayLang.OpCodes.OpMath;
use BayLang.OpCodes.OpModule;
use BayLang.OpCodes.OpNamespace;
use BayLang.OpCodes.OpString;
use BayLang.OpCodes.OpTypeIdentifier;
use BayLang.OpCodes.OpUse;
use BayLang.OpCodes.OpWidget;
use BayLang.OpCodes.OpWidgetData;


class ParserBayHtml extends BaseObject
{
	/**
	 * Hash function
	 * @param string
	 * @return int hash
	 */
	pure int hash(string s, bool last=true, int x = 257, int p = 1000000007)
	{
		int h = 0;
		int sz = rs::strlen(s);
		for (int i=0; i<sz; i++)
		{
			int ch = rs::ord( rs::substr(s, i, 1) );
			h = (h * x + ch) % p;
		}
		if (last)
		{
			h = (h * x) % p;
		}
		return h;
	}
	
	
	/**
	 * Convert int to hex
	 * @param int
	 * @return string
	 */
	pure string toHex(int h)
	{
		string r = "";
		string a = "0123456789abcdef";
		while (h >= 0)
		{
			int c = h & 15;
			h = h >> 4;
			r = rs::substr(a, c, 1) ~ r;
			if (h == 0) break;
		}
		return r;
	}
	
	
	/**
	 * Retuns css hash
	 * @param string component class name
	 * @return string hash
	 */
	pure memorize string getCssHash(string s)
	{
		int h = static::hash(s, true, 337, 65537) + 65537;
		string res = static::toHex(h);
		return rs::substr(res, -4);
	}
	
	
	/**
	 * Read css component name
	 */
	pure list<ParserBay, string> readCssComponentName(ParserBay parser)
	{
		bool flag = false;
		string class_name = "";
		
		/* Get caret */
		Caret caret = parser.getCaret();
		
		/* Read char */
		string ch = caret.nextChar();
		if (ch == "(")
		{
			flag = true;
			
			/* Read ( */
			caret.readChar();
			
			/* Next char */
			ch = caret.nextChar();
			
			/* Read class name */
			int start_pos = caret.pos;
			while (not caret.eof() and ch != ")")
			{
				caret.readChar();
				ch = caret.nextChar();
			}
			class_name = caret.getString(start_pos, caret.pos - start_pos);
			
			/* Recognize class name */
			if (parser.uses.has(class_name))
			{
				class_name = parser.uses.item(class_name);
			}
			
			/* Read ) */
			caret.matchChar(")");
		}
		
		parser = parser.copy{ "caret": caret };
		return [parser, class_name, flag];
	}
	
	
	/**
	 * Read css class name
	 */
	pure list<ParserBay, string> readCssClassName(
		ParserBay parser, bool default_component_name = true
	)
	{
		/* Get caret */
		Caret caret = parser.getCaret();
		
		/* Component name */
		bool use_component_name = default_component_name;
		string component_name = parser.current_namespace_name ~ "." ~ parser.current_class_name;
		
		/* Read start selector */
		string start_ch = caret.nextChar();
		if (start_ch == "." or start_ch == "%")
		{
			caret.readChar();
		}
		else if (start_ch == "&")
		{
			caret.readChar();
			use_component_name = false;
		}
		else if (start_ch == "#" or start_ch == ":")
		{
			caret.readChar();
			if (start_ch == ":")
			{
				use_component_name = false;
			}
		}
		else if (start_ch == "*")
		{
			caret.readChar();
			parser <= caret <= caret;
			return [parser, "*"];
		}
		else start_ch = "";
		
		/* Save caret */
		parser <= caret <= caret;
		
		/* Read class name */
		if (start_ch == "%")
		{
			start_ch = ".";
			list res = static::readCssComponentName(parser);
			parser = res[0];
			if (res[2] != "")
			{
				component_name = res[1];
				use_component_name = true;
			}
		}
		
		/* Start position */
		caret = parser.getCaret();
		int start_pos = caret.pos;
		
		/* Read selector */
		char ch = caret.nextChar();
		while (
			not caret.eof() and ch != " " and ch != "," and
			ch != ":" and ch != "[" and ch != "{"
		)
		{
			caret.readChar();
			ch = caret.nextChar();
		}
		string postfix = caret.getString(start_pos, caret.pos - start_pos);
		postfix = rs::trim(postfix);
		
		/* Read suffix */
		int start_pos = caret.pos;
		while (
			not caret.eof() and ch != " " and ch != "," and
			ch != "." and ch != "{"
		)
		{
			caret.readChar();
			ch = caret.nextChar();
		}
		string suffix = caret.getString(start_pos, caret.pos - start_pos);
		suffix = rs::trim(suffix);
		
		string class_name = start_ch ~ postfix ~
			(use_component_name ? ".h-" ~ static::getCssHash(component_name) : "") ~
			suffix
		;
		parser <= caret <= caret;
		return [parser, class_name];
	}
	
	
	/**
	 * Read css selector
	 */
	pure list<ParserBay, string> readCssSelector(
		ParserBay parser, bool default_component_name = true
	)
	{
		/* Get caret */
		Caret caret = parser.getCaret();
		
		Vector selectors = new Vector();
		while (not caret.eof())
		{
			list res = static::readCssClassName(parser, default_component_name);
			parser = res[0];
			string selector = res[1];
			
			default_component_name = false;
			selectors.push(selector);
			
			/* Skip empty chars */
			Caret caret = parser.parser_base::skipChar(parser, parser.content, parser.caret);
			parser <= caret <= caret;
			
			/* Get caret */
			caret = parser.caret.clone{
				"file_name": parser.file_name,
				"content": parser.content,
				"content_sz": parser.content_sz,
			};
			
			string ch = caret.nextChar();
			if (ch == "{" or ch == "}" or ch == "<" or ch == ",")
			{
				break;
			}
		}
		
		string selector = rs::join(" ", selectors);
		return [parser, selector];
	}
	
	
	/**
	 * Concat op_code_item with selector
	 */
	pure BaseOpCode readCssBodyConcatItem(
		Caret caret_start,
		Caret caret_end,
		string selector,
		BaseOpCode op_code_item
	)
	{
		if (op_code_item instanceof OpString)
		{
			op_code_item = new OpString{
				"caret_start": caret_start,
				"caret_end": caret_end,
				"value": op_code_item.value ~ "}",
			}
		}
		else
		{
			op_code_item = new OpMath
			{
				"caret_start": caret_start,
				"caret_end": caret_end,
				"value1": op_code_item,
				"value2": new OpString
				{
					"value": "}",
				},
				"math": "~",
			};
		}
		
		if (op_code_item instanceof OpString)
		{
			op_code_item = new OpString{
				"caret_start": caret_start,
				"caret_end": caret_end,
				"value": selector ~ "{" ~ op_code_item.value,
			}
		}
		else
		{
			op_code_item = new OpMath
			{
				"caret_start": caret_start,
				"caret_end": caret_end,
				"value1": new OpString
				{
					"caret_start": caret_start,
					"caret_end": caret_end,
					"value": selector ~ "{",
				},
				"value2": op_code_item,
				"math": "~",
			};
		}
		
		return op_code_item;
	}
	
	
	/**
	 * Returns true if next string is css selector
	 */
	pure bool isNextSelector(Caret caret)
	{
		caret = caret.clone();
		
		char ch = caret.nextChar();
		if (
			ch == "@" or ch == "%" or ch == "&" or
			ch == "." or ch == ":" or ch == "#" or ch == "*"
		) return true;
		if (not caret::isChar(ch)) return false;
		
		while (not caret.eof() and ch != "{" and ch != "}" and ch != "<")
		{
			if (ch == ";" or ch == "(" or ch == ")") return false;
			caret.nextChar();
			ch = caret.readChar();
		}
		
		if (ch == "{") return true;
		return false;
	}
	
	
	/**
	 * Split selector by dot
	 */
	pure string splitSelector(string selector)
	{
		Collection arr1 = rs::split(" ", selector);
		string prefix = rs::join(" ", arr1.slice(0, -1));
		if (prefix != "") prefix = prefix ~ " ";
		
		Collection arr2 = rs::split(".", arr1.last());
		string first = "";
		string second = "";
		if (arr2.get(0) == "")
		{
			first = "." ~ arr2.get(1);
			second = rs::join(".", arr2.slice(2))
		}
		else
		{
			first = arr2.get(0);
			second = rs::join(".", arr2.slice(1));
		}
		
		if (second != "") second = "." ~ second;
		return [prefix ~ first, second];
	}
	
	
	/**
	 * Concat selectors
	 */
	pure string concatSelectors(string prev_selector, string selector)
	{
		if (prev_selector == "") return selector;
		
		/* If first symbol is & */
		if (rs::charAt(selector, 0) == "&")
		{
			list res = static::splitSelector(prev_selector);
			return res.get(0) ~ rs::substr(selector, 1) ~ res.get(1);
		}
		
		return prev_selector ~ " " ~ selector;
	}
	
	
	/**
	 * Get selectors from collection
	 */
	pure void getSelectors(Collection<Collection<string>> start_selectors)
	{
		Vector result = [""];
		
		for (int i=0; i<start_selectors.count(); i++)
		{
			Vector prev_result = result; result = [];
			Collection items = start_selectors.get(i);
			for (int j=0; j<prev_result.count(); j++)
			{
				string prev_selector = prev_result.get(j);
				for (int k=0; k<items.count(); k++)
				{
					string selector = items.get(k);
					result.push(static::concatSelectors(prev_selector, selector));
				}
			}
		}
		
		return result;
	}
	
	
	/**
	 * Read css body
	 */
	pure ParserBay readCssBodyItems(
		ParserBay parser, Vector items,
		Collection<Collection<string>> start_selectors, string end_tag,
		bool default_component_name
	)
	{
		Vector css_content = [];
		Vector sub_items = [];
		
		/* Get caret */
		Caret caret_start = parser.getCaret();
		
		/* Skip empty chars */
		Caret caret = parser.parser_base::skipChar(parser, parser.content, parser.caret);
		parser <= caret <= caret;
		caret = parser.getCaret();
		
		BaseOpCode op_code = null;
		while (not caret.eof() and caret.nextChar() != end_tag and caret.nextChar() != "}")
		{
			BaseOpCode op_code_item = null;
			
			/* Read media css */
			if (caret.isNextString("@media"))
			{
				/* Read selector */
				Vector arr = new Vector();
				string ch = caret.nextChar();
				while (not caret.eof() and ch != "{")
				{
					if (ch != "\t" and ch != "\n")
					{
						arr.push(ch);
					}
					caret.readChar();
					ch = caret.nextChar();
				}
				string media_selector = rs::trim(rs::join("", arr));
				
				/* Setup caret */
				parser <= caret <= caret;
				
				Caret caret_start_item2 = parser.getCaret();
				
				/* Read body */
				Vector new_items = new Vector();
				list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
				parser = static::readCssBodyItems(
					parser, new_items,
					start_selectors,
					"}", default_component_name
				);
				list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
				
				/* Items */
				for (int i=0; i<new_items.count(); i++)
				{
					BaseOpCode item = new_items.get(i);
					item = static::readCssBodyConcatItem(
						item.caret_start,
						item.caret_end,
						media_selector,
						item
					);
					items.push(item);
				}
				
				/* Get caret */
				caret = parser.getCaret();
			}
			
			/* If next selector */
			else if (static::isNextSelector(caret))
			{
				Vector selectors = [];
				
				/* Read css selector */
				while (static::isNextSelector(caret))
				{
					parser <= caret <= caret;
					list res = static::readCssSelector(parser, default_component_name);
					parser = res[0];
					selectors.push(res[1]);
					caret = parser.getCaret();
					if (caret.isNextChar(","))
					{
						caret.readChar();
						caret.skipSpace();
					}
				}
				
				/* Setup caret */
				parser <= caret <= caret;
				
				Caret caret_start_item2 = parser.getCaret();
				
				/* Read body */
				list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
				parser = static::readCssBodyItems(
					parser, sub_items,
					start_selectors.pushIm(selectors),
					"}", default_component_name
				);
				list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
				
				/* Get caret */
				caret = parser.getCaret();
			}
			
			/* Read CSS content */
			else
			{
				Vector arr = new Vector();
				string ch = caret.nextChar();
				while (not caret.eof() and ch != "}" and ch != ";")
				{
					if (ch != "\t" and ch != "\n")
					{
						arr.push(ch);
					}
					caret.readChar();
					ch = caret.nextChar();
				}
				
				string s = rs::trim(rs::join("", arr));
				css_content.push(s);
				
				caret.skipChar(";");
				
				/* Setup caret */
				parser <= caret <= caret;
			}
			
			/* Skip empty chars */
			caret = parser.parser_base::skipChar(parser, parser.content, caret);
			parser <= caret <= caret;
			caret = parser.getCaret();
		}
		
		/* Add CSS content to items */
		if (css_content.count() > 0)
		{
			/* Get content */
			string content = rs::join(";", css_content);
			Collection selectors = static::getSelectors(start_selectors);
			content = rs::join(",", selectors) ~ "{" ~ content ~ "}";
			
			/* Create op code */
			BaseOpCode op_code_item = new OpString
			{
				"caret_start": caret_start,
				"caret_end": parser.getCaret(),
				"value": rs::trim(content),
			};
			
			items.push(op_code_item);
		}
		
		/* Add sub items */
		items.appendItems(sub_items);
		
		parser <= caret <= caret;
		return parser;
	}
	
	
	/**
	 * Read css body
	 */
	pure list<ParserBay, BaseOpCode> readCssBody(
		ParserBay parser, string end_tag = "}",
		bool default_component_name = true
	)
	{
		/* Get caret */
		Caret caret_start = parser.getCaret();
		
		BaseOpCode op_code = null;
		Vector items = new Vector();
		
		/* Read items */
		parser = static::readCssBodyItems(parser, items, [], end_tag, default_component_name);
		
		for (int i=0; i<items.count(); i++)
		{
			BaseOpCode op_code_item = items.get(i);
			if (op_code == null) op_code = op_code_item;
			else
			{
				if (op_code instanceof OpString and op_code_item instanceof OpString)
				{
					op_code = new OpString{
						"caret_start": op_code.caret_start,
						"caret_end": op_code_item.caret_end,
						"value": op_code.value ~ op_code_item.value,
					}
				}
				else
				{
					op_code = new OpMath
					{
						"caret_start": op_code.caret_start,
						"caret_end": op_code_item.caret_end,
						"value1": op_code,
						"value2": op_code_item,
						"math": "~",
					};
				}
			}
		}
		
		if (op_code == null)
		{
			op_code = new OpString
			{
				"caret_start": caret_start,
				"caret_end": parser.caret,
				"value": "",
			};
		}
		
		op_code <= caret_start <= caret_start;
		op_code <= caret_end <= parser.caret;
		
		return [parser, op_code];
	}
	
	
	/**
	 * Read css
	 */
	pure list<ParserBay, BaseOpCode> readCss(ParserBay parser)
	{
		Caret caret_start = parser.caret;
		
		list res = parser.parser_base::matchToken(parser, "@css"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
		
		list res = static::readCssBody(parser);
		parser = res[0]; BaseOpCode op_code = res[1];
		
		list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
		
		if (op_code == null)
		{
			op_code = new OpString
			{
				"caret_start": caret_start,
				"caret_end": parser.caret,
				"value": "",
			};
		}
		
		return [parser, op_code];
	}
	
	
	/**
	 * Read style
	 */
	pure list<ParserBay, BaseOpCode> readStyle
	(
		ParserBay parser, Dict item_attrs, Vector<BaseOpCode> items, Caret caret_start
	)
	{
		/* Save vars */
		Dict<bool> save_vars = parser.vars;
		parser <= vars <= parser.vars.setIm("vars", true);
		parser <= is_local_css <= true;
		
		/* Check if local css */
		string is_global = item_attrs.get("global", "");
		if (is_global == "true")
		{
			parser <= is_local_css <= false;
		}
		
		/* Read css */
		list res = static::readCssBody(parser, "<", parser.is_local_css);
		parser = res[0]; BaseOpCode css_op_code = res[1];
		
		/* Restore vars */
		parser <= vars <= save_vars;
		
		/* Read style footer */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "style"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		/* Get style content */
		int start_pos = css_op_code.caret_start.pos;
		int end_pos = css_op_code.caret_end.pos;
		string style_content = rs::trim(
			rs::substr(parser.content.ref, start_pos, end_pos - start_pos)
		);
		
		/* Create op code */
		BaseOpCode op_code = new OpHtmlStyle{
			"caret_start": caret_start,
			"caret_end": parser.caret,
			"content": style_content,
			"is_global": is_global,
			"value": css_op_code,
		};
		
		return [parser, op_code];
	}
	
	
	/**
	 * Read html comment
	 */
	pure list<ParserBay, OpComment> readHTMLComment(ParserBay parser)
	{
		ParserBay start = parser;
		CoreToken token = null;
		ParserBay look = null;
		Caret caret_start = parser.caret;
		
		parser <= skip_comments <= false;
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "!--"); parser = res[0];
		
		string content = parser.content;
		int content_sz = parser.content_sz;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		int pos_start = pos;
		
		string ch = rs::charAt(content.ref, pos);
		string ch3 = rs::substr(content.ref, pos, 3);
		while (ch3 != "-->" and pos < content_sz)
		{
			x = parser.parser_base::nextX(parser, ch, x);
			y = parser.parser_base::nextY(parser, ch, y);
			pos = pos + 1;
			if (pos >= parser.content_sz)
			{
				break;
			}
			ch = rs::charAt(content.ref, pos);
			ch3 = rs::substr(content.ref, pos, 3);
		}
		
		int pos_end = pos;
		if (ch3 == "-->")
		{
			x = x + 3;
			pos = pos + 3;
		}
		else
		{
			throw new ParserExpected
			(
				"End of comment",
				new Caret{ "x": x, "y": y, "pos": pos },
				start.file_name
			);
		}
		
		/* Return result */
		string value_str = rs::substr(content.ref, pos_start, pos_end - pos_start);
		Caret caret_end = new Caret{ "x": x, "y": y, "pos": pos };
		
		parser <= skip_comments <= true;
		
		return
		[
			start.copy({ "caret": caret_end }),
			new OpComment
			{
				"value": value_str,
				"caret_start": caret_start,
				"caret_end": caret_end,
			}
		];
		
		
		return [parser, null];
	}
	
	
	/**
	 * Read html value
	 */
	pure list<ParserBay, BaseOpCode> readHTMLValue(ParserBay parser)
	{
		BaseOpCode item = null;
		Caret caret = parser.caret;
		Reference<string> content = parser.content;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		string ch = rs::substr(content.ref, pos, 1);
		string ch2 = rs::substr(content.ref, pos, 2);
		if (ch == "<")
		{
			list res = static::readHTMLTag(parser);
			parser = res[0]; item = res[1];
		}
		else if (ch == "{")
		{
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			
			/* Look token */
			bool flag = false;
			list res = parser.parser_base::readToken(parser);
			ParserBay look = res[0]; CoreToken token = res[1];
			
			if (token.content == "{")
			{
				flag = true;
				parser = look;
			}
			
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; item = res[1];
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
			
			if (flag)
			{
				list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
			}
		}
		else if (ch == "@")
		{
			x = parser.parser_base::nextX(parser, ch, x);
			y = parser.parser_base::nextY(parser, ch, y);
			pos = pos + 1;
			
			string ch3 = rs::substr(content.ref, pos, 3);
			string ch4 = rs::substr(content.ref, pos, 4);
			if (ch3 == "raw" or ch4 == "json" or ch4 == "html")
			{
				list res;
				if (ch3 == "raw") res = parser.parser_base::next(parser, ch3, x, y, pos);
				if (ch4 == "json") res = parser.parser_base::next(parser, ch4, x, y, pos);
				if (ch4 == "html") res = parser.parser_base::next(parser, ch4, x, y, pos);
				x = res[0]; y = res[1]; pos = res[2];
			}
			
			caret = new Caret{ "x": x, "y": y, "pos": pos };
			parser <= caret <= caret;
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			
			/* Look bracket */
			list res = parser.parser_base::lookToken(parser, "{");
			ParserBay look = res[0]; bool find_bracket = res[2];
			if (find_bracket) parser = look;
			
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; item = res[1];
			
			if (ch3 == "raw")
			{
				item = new OpHtmlValue
				{
					"kind": OpHtmlValue::KIND_RAW,
					"value": item,
					"caret_start": caret,
					"caret_end": parser.caret,
				};
			}
			else if (ch4 == "json")
			{
				item = new OpHtmlValue
				{
					"kind": OpHtmlValue::KIND_JSON,
					"value": item,
					"caret_start": caret,
					"caret_end": parser.caret,
				};
			}
			else if (ch4 == "html")
			{
				item = new OpHtmlValue
				{
					"kind": OpHtmlValue::KIND_HTML,
					"value": item,
					"caret_start": caret,
					"caret_end": parser.caret,
				};
			}
			
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
			if (find_bracket)
			{
				list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
			}
		}
		
		return [parser, item];
	}
	
	
	/**
	 * Read html attribute key
	 */
	pure list<ParserBay, string> readHTMLAttrKey(ParserBay parser)
	{
		CoreToken token = null;
		ParserBay look = null;
		OpIdentifier ident = null;
		string key = "";
		
		/* Look token */
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "@")
		{
			parser = look;
			key = "@";
		}
		
		list res = parser.parser_base::readIdentifier(parser); parser = res[0]; ident = res[1];
		key ~= ident.value;
		
		/* Read attr */
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		while (token.content == "-")
		{
			list res = parser.parser_base::readIdentifier(look); parser = res[0]; ident = res[1];
			key ~= "-" ~ ident.value;
			
			/* Look next token */
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		}
		
		/* Look token */
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content == ":")
		{
			parser = look;
			key ~= ":";
			list res = parser.parser_base::readIdentifier(parser); parser = res[0]; ident = res[1];
			key ~= ident.value;
		}
		
		return [parser, key];
	}
	
	
	/**
	 * Read html attribute value
	 */
	pure list<ParserBay, BaseOpCode> readHTMLAttrValue(ParserBay parser, string attr_key)
	{
		CoreToken token = null;
		ParserBay look = null;
		BaseOpCode op_code = null;
		OpIdentifier ident = null;
		
		int pos = parser.caret.pos;
		Reference<string> content = parser.content;
		string ch = rs::substr(content.ref, pos, 1);
		string ch2 = rs::substr(content.ref, pos, 2);
		
		/* Look token */
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (rs::substr(attr_key, 0, 7) == "@event:")
		{
			/* Look token */
			list res = parser.parser_base::lookToken(parser, "{");
			ParserBay look = res[0]; CoreToken token = res[1]; bool is_fn = res[2];
			
			if (is_fn)
			{
				list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
				
				/* Look token */
				list res = parser.parser_base::lookToken(parser, "{");
				ParserBay look = res[0]; CoreToken token = res[1]; bool find = res[2];
				if (find)
				{
					parser = look;
				}
				
				/* Add msg to vars */
				Dict<bool> parser_vars = parser.vars;
				parser <= vars <= parser.vars.concat({
					"component": true,
					"msg": true,
				});
				
				/* Read expression */
				list res = parser.parser_expression::readExpression(parser);
				parser = res[0]; op_code = res[1];
				
				/* Restore vars */
				parser <= vars <= parser_vars;
				
				/* Parse brackets */
				list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
				if (find)
				{
					list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
				}
			}
			else
			{
				list res = parser.parser_base::readString(parser);
				parser = res[0]; op_code = res[1];
			}
		}
		else if (ch == "{")
		{
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			
			/* Look token */
			list res = parser.parser_base::lookToken(parser, "{");
			ParserBay look = res[0]; CoreToken token = res[1]; bool find = res[2];
			if (find)
			{
				parser = look;
			}
			
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; op_code = res[1];
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
			
			if (find)
			{
				list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
			}
		}
		else if (token.content == "@")
		{
			list res = static::readHTMLValue(parser);
			parser = res[0]; op_code = res[1];
		}
		else if (token.content == "[")
		{
			list res = parser.parser_base::readCollection(parser);
			parser = res[0]; op_code = res[1];
		}
		else
		{
			list res = parser.parser_base::readString(parser);
			parser = res[0]; op_code = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	/**
	 * Read html attributes
	 */
	pure list<ParserBay, BaseOpCode> readHTMLAttrs(ParserBay parser)
	{
		Vector<OpHtmlAttribute> items = new Vector();
		
		CoreToken token = null;
		ParserBay look = null;
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		Caret caret = parser.parser_base::skipChar(parser, content, parser.caret);
		string ch = rs::substr(content.ref, caret.pos, 1);
		while (ch != "/" and ch != ">" and caret.pos < content_sz)
		{
			Caret caret_start = caret;
			parser <= caret <= caret;
			
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			if (token.content == "...")
			{
				OpIdentifier ident = null;
				list res = parser.parser_base::matchToken(parser, "..."); parser = res[0];
				list res = parser.parser_base::readIdentifier(look); parser = res[0]; ident = res[1];
				items.push
				(
					new OpHtmlAttribute
					{
						"value": ident,
						"is_spread": true,
						"caret_start": caret_start,
						"caret_end": parser.caret,
					}
				);
			}
			else
			{
				list res = static::readHTMLAttrKey(parser); parser = res[0]; string key = res[1];
				list res = parser.parser_base::matchToken(parser, "="); parser = res[0];
				list res = static::readHTMLAttrValue(parser, key);
				parser = res[0]; BaseOpCode value = res[1];
				items.push
				(
					new OpHtmlAttribute
					{
						"key": key,
						"value": value,
						"caret_start": caret_start,
						"caret_end": parser.caret,
					}
				);
			}
			caret = parser.parser_base::skipChar(parser, content, parser.caret);
			ch = rs::substr(content.ref, caret.pos, 1);
			string ch2 = rs::substr(content.ref, caret.pos, 2);
			if (ch2 == "/>") break;
		}
		
		return [parser, items];
	}
	
	
	/**
	 * Read html template
	 */
	pure list<ParserBay, Collection> readHTMLContent(ParserBay parser, string end_tag)
	{
		Vector<BaseOpCode> items = new Vector();
		BaseOpCode item = null;
		CoreToken token = null;
		ParserBay look = null;
		Caret caret = null;
		Caret caret_start = parser.caret;
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		int start_pos = pos;
		int end_tag_sz = rs::strlen(end_tag);
		string ch_pos = rs::substr(content.ref, pos, end_tag_sz);
		bool flag_first = true;
		bool first_html_tag = false;
		if (end_tag == "") first_html_tag = true;
		while ( ( end_tag == "" or (end_tag != "" and ch_pos != end_tag) ) and pos < content_sz)
		{
			string ch = rs::substr(content.ref, pos, 1);
			string ch2 = rs::substr(content.ref, pos, 2);
			string ch3 = rs::substr(content.ref, pos, 3);
			string ch4 = rs::substr(content.ref, pos, 4);
			string ch6 = rs::substr(content.ref, pos, 6);
			string ch7 = rs::substr(content.ref, pos, 7);
			
			/* Html comment */
			if (ch4 == "<!--")
			{
				string value = rs::substr(content.ref, start_pos, pos - start_pos);
				caret = new Caret{ "x": x, "y": y, "pos": pos };
				value = rs::trim(value, "\t\r\n");
				value = rs::trim(value, " ");
				if (value != "")
				{
					item = new OpHtmlContent
					{
						"value": value,
						"caret_start": caret_start,
						"caret_end": caret,
					}
					items.push(item);
				}
				
				/* Read HTML Comment */
				parser <= caret <= caret;
				list res = static::readHTMLComment(parser);
				parser = res[0]; items.push( res[1] );
				
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			
			/* If html or tag */
			else if (ch == "<" or ch2 == "{{" or ch == "@")
			{
				string value = rs::substr(content.ref, start_pos, pos - start_pos);
				caret = new Caret{ "x": x, "y": y, "pos": pos };
				value = rs::trim(value, "\t\r\n");
				
				if (flag_first and first_html_tag) value = rs::trim(value, " ");
				if (value != "")
				{
					item = new OpHtmlContent
					{
						"value": value,
						"caret_start": caret_start,
						"caret_end": caret,
					}
					items.push(item);
				}
				
				/* Read HTML Value */
				parser <= caret <= caret;
				list res = static::readHTMLValue(parser);
				parser = res[0]; item = res[1];
				items.push(item);
				
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			
			/* If html operator */
			else if (
				ch3 == "%if" or ch4 == "%for" or ch4 == "%var" or
				ch4 == "%set" or ch6 == "%while" or ch7 == "%render"
			)
			{
				string value = rs::substr(content.ref, start_pos, pos - start_pos);
				caret = new Caret{ "x": x, "y": y, "pos": pos };
				value = rs::trim(value, "\t\r\n");
				value = rs::trim(value, " ");
				if (value != "")
				{
					item = new OpHtmlContent
					{
						"value": value,
						"caret_start": caret_start,
						"caret_end": caret,
					}
					items.push(item);
				}
				
				/* Read HTML Operator */
				parser <= caret <= caret;
				list res = static::readHTMLOperator(parser);
				parser = res[0]; item = res[1];
				items.push(item);
				
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			
			else
			{
				if (first_html_tag and ch != " " and ch != "\t" and ch != "\r" and ch != "\n")
				{
					break;
				}
				x = parser.parser_base::nextX(parser, ch, x);
				y = parser.parser_base::nextY(parser, ch, y);
				pos = pos + 1;
			}
			ch_pos = rs::substr(content.ref, pos, end_tag_sz);
		}
		
		/* Push item */
		string value = rs::substr(content.ref, start_pos, pos - start_pos);
		value = rs::trim(value, "\t\r\n");
		caret = new Caret{ "x": x, "y": y, "pos": pos };
		if (first_html_tag) value = rs::trim(value, " ");
		if (value != "")
		{
			item = new OpHtmlContent
			{
				"value": value,
				"caret_start": caret_start,
				"caret_end": caret,
			}
			items.push(item);
		}
		
		return [ parser.copy{ "caret": caret }, items ];
	}
	
	
	/**
	 * Read html tag
	 */
	pure list<ParserBay, BaseOpCode> readHTMLTag(ParserBay parser)
	{
		CoreToken token = null;
		ParserBay look = null;
		OpIdentifier ident = null;
		Caret caret_items_start = null, caret_items_end = null;
		Caret caret_start = parser.caret;
		Collection<BaseOpCode> items = null;
		BaseOpCode op_code_name = null;
		bool is_single_flag = false;
		bool op_code_flag = false;
		string tag_name = "";
		
		/* Tag start */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		
		/* Look token */
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "{")
		{
			op_code_flag = true;
			Caret caret1 = parser.caret;
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; op_code_name = res[1];
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
			Caret caret2 = parser.caret;
			tag_name = rs::substr(parser.content.ref, caret1.pos, caret2.pos - caret1.pos);
		}
		else if (token.content == ">")
		{
			op_code_flag = true;
			tag_name = "";
		}
		else
		{
			list res = parser.parser_base::readIdentifier(parser, false);
			parser = res[0]; ident = res[1];
			tag_name = ident.value;
		}
		
		list res = static::readHTMLAttrs(parser);
		parser = res[0]; Collection<OpHtmlAttribute> attrs = res[1];
		
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "/")
		{
			parser = look;
			is_single_flag = true;
		}
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		if (not is_single_flag)
		{
			if (tag_name == "svg")
			{
				list res = parser.parser_base::readUntilStringArr(parser, ["</svg>"], false);
				parser = res[0];
				string content = res[1];
				content = re::replace("[\t\n]", "", content);
				
				Collection<BaseOpCode> items =
				[
					new OpHtmlValue
					{
						"kind": OpHtmlValue::KIND_RAW,
						"value": new OpString
						{
							"caret_start": parser.caret,
							"caret_end": parser.caret,
							"value": content,
						},
						"caret_start": caret_start,
						"caret_end": parser.caret,
					}
				];
				
			}
			else
			{
				/* Read items */
				caret_items_start = parser.caret;
				list res = static::readHTMLContent(parser, "</" ~ tag_name);
				parser = res[0]; Collection<BaseOpCode> items = res[1];
				caret_items_end = parser.caret;
			}
			
			/* Tag end */
			if (op_code_flag)
			{
				list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
				list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
				if (tag_name)
				{
					list res = parser.parser_base::matchString(parser, tag_name); parser = res[0];
				}
				list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
			}
			else
			{
				list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
				list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
				if (ident != null)
				{
					list res = parser.parser_base::matchToken(parser, tag_name); parser = res[0];
				}
				list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
			}
		}
		
		BaseOpCode op_code = null;
		if (tag_name == "slot")
		{
			OpHtmlAttribute op_attr_name = attrs.findItem(lib::equalAttr("key", "name"));
			attrs = attrs.filter(lib::equalAttrNot("key", "name"));
			
			string name = "";
			if (op_attr_name and op_attr_name.value instanceof OpString)
			{
				name = op_attr_name.value.value;
			}
			
			op_code = new OpHtmlSlot
			{
				"attrs": attrs,
				"name": name,
				"caret_start": caret_start,
				"caret_end": parser.caret,
				"items": (items != null) ? new OpHtmlItems
				{
					"caret_start": caret_items_start,
					"caret_end": caret_items_end,
					"items": items
				} : null,
			};
		}
		else
		{
			op_code = new OpHtmlTag
			{
				"attrs": attrs,
				"tag_name": tag_name,
				"op_code_name": op_code_name,
				"caret_start": caret_start,
				"caret_end": parser.caret,
				"items": (items != null) ? new OpHtmlItems
				{
					"caret_start": caret_items_start,
					"caret_end": caret_items_end,
					"items": items
				} : null,
			};
		}
		
		return [parser, op_code];
	}
	
	
	/**
	 * Read html operator
	 */
	pure list<ParserBay, BaseOpCode> readHTMLOperator(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		
		if (token.content == "%if")
		{
			return parser.parser_operator::readIf(parser);
		}
		else if (token.content == "%for")
		{
			return parser.parser_operator::readFor(parser);
		}
		else if (token.content == "%while")
		{
			return parser.parser_operator::readWhile(parser);
		}
		else if (token.content == "%var")
		{
			BaseOpCode op_code = null;
			list res = parser.parser_base::matchToken(parser, "%var"); parser = res[0];
			list res = parser.parser_operator::readAssign(parser); parser = res[0]; op_code = res[1];
			list res = parser.parser_base::matchToken(parser, ";"); parser = res[0];
			return [parser, op_code];
		}
		else if (token.content == "%set")
		{
			BaseOpCode op_code = null;
			list res = parser.parser_base::matchToken(parser, "%set"); parser = res[0];
			list res = parser.parser_operator::readAssign(parser); parser = res[0]; op_code = res[1];
			list res = parser.parser_base::matchToken(parser, ";"); parser = res[0];
			return [parser, op_code];
		}
		else if (token.content == "%render")
		{
			BaseOpCode op_code = null;
			list res = parser.parser_base::matchToken(parser, "%render"); parser = res[0];
			list res = parser.parser_base::readDynamic(parser);
			parser = res[0]; op_code = res[1];
			if (op_code instanceof OpCall)
			{
				op_code <= is_html <= true;
			}
			list res = parser.parser_base::matchToken(parser, ";"); parser = res[0];
			return [parser, op_code];
		}
		
		return [parser, null];
	}
	
	
	/**
	 * Read html operator
	 */
	pure list<ParserBay, BaseOpCode> readHTML(ParserBay parser, string end_tag = "")
	{
		Caret caret_start = parser.caret;
		
		/* Enable html flag */
		bool save_is_html = parser.is_html;
		parser <= is_html <= true;
		
		list res = static::readHTMLContent(parser, end_tag);
		parser = res[0]; Collection<BaseOpCode> items = res[1];
		
		OpHtmlItems op_code = new OpHtmlItems
		{
			"caret_start": caret_start,
			"caret_end": parser.caret,
			"items": items,
		}
		
		/* Disable html flag */
		parser <= is_html <= save_is_html;
		
		return [parser, op_code];
	}
	
	
	/**
	 * Read html operator
	 */
	pure list<ParserBay, BaseOpCode> readHTMLTemplate(
		ParserBay parser, Dict item_attrs, Caret caret_start
	)
	{
		string fn_name = item_attrs.get("name", "render");
		string fn_args_str = item_attrs.get("args", "");
		Dict<bool> parser2_vars = {};
		
		/*
		Collection<OpDeclareFunctionArg> fn_args =
		[
			new OpDeclareFunctionArg
			{
				"name": "component",
				"caret_start": caret_start,
				"caret_end": parser.caret,
			},
			new OpDeclareFunctionArg
			{
				"name": "layout",
				"caret_start": caret_start,
				"caret_end": parser.caret,
			},
			new OpDeclareFunctionArg
			{
				"name": "model_path",
				"caret_start": caret_start,
				"caret_end": parser.caret,
			},
			new OpDeclareFunctionArg
			{
				"name": "render_params",
				"caret_start": caret_start,
				"caret_end": parser.caret,
			},
			new OpDeclareFunctionArg
			{
				"name": "render_content",
				"caret_start": caret_start,
				"caret_end": parser.caret,
			},
		];
		*/
		Collection<OpDeclareFunctionArg> fn_args = [];
		
		if (item_attrs.has("args"))
		{
			ParserBay parser2 = parser::setContent(parser, fn_args_str);
			parser2 <= caret <= new Caret{};
			
			/* Parse args */
			list res = parser.parser_operator::readDeclareFunctionArgs(parser2, false, false);
			parser2 = res[0]; Collection<OpDeclareFunctionArg> fn_args2 = res[1];
			parser2_vars = parser2.vars;
			
			fn_args = fn_args.concat(fn_args2);
		}
		
		/* If multiblock */
		bool is_multiblock = false;
		if (item_attrs.has("multiblock"))
		{
			if (item_attrs.get("multiblock") == "true")
			{
				is_multiblock = true;
			}
			else if (item_attrs.get("multiblock") == "false")
			{
				is_multiblock = false;
			}
		}
		
		/* Register variable in parser */
		parser2_vars = parser2_vars
			.setIm("layout", true)
			.setIm("model", true)
			.setIm("model_path", true)
			.setIm("render_params", true)
			.setIm("render_content", true)
		;
		
		/* Read template content */
		Dict<bool> save_vars = parser.vars;
		parser <= vars <= parser.vars.concat(parser2_vars);
		list res = static::readHTML(parser, "</template"); parser = res[0];
		BaseOpCode expression = res[1];
		parser <= vars <= save_vars;
		
		/* Read template footer */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "template"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		OpDeclareFunction f = new OpDeclareFunction
		{
			"args": fn_args,
			"vars": [],
			"flags": new OpFlags
			{
				"p_static": false,
				"p_pure": false,
				"p_multiblock": is_multiblock,
			},
			"name": fn_name,
			"result_type": "html",
			"is_html": true,
			"expression": expression,
			"items": null,
			"caret_start": caret_start,
			"caret_end": parser.caret,
		};
		
		return [parser, f];
	}
	
	
	/**
	 * Read html attributes
	 */
	pure list<ParserBay, Dict> readAttrs(ParserBay parser)
	{
		ParserBay look = null;
		BaseOpCode op_code = null;
		CoreToken token = null;
		CoreToken look_token = null;
		Map items = new Map();
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz
		Caret caret = parser.parser_base::skipChar(parser, content, parser.caret);
		string ch = rs::substr(content.ref, caret.pos, 1);
		while (ch != "/" and ch != ">" and caret.pos < content_sz)
		{
			list res = parser.parser_base::readToken(parser);
			parser = res[0]; token = res[1];
			
			list res = parser.parser_base::matchToken(parser, "="); parser = res[0];
			string attr_name = token.content;
			
			/* Look token */
			list res = parser.parser_base::readToken(parser); look_token = res[1];
			if (look_token.content == "{")
			{
				list res = parser.parser_base::readDict(parser);
				parser = res[0]; op_code = res[1];
				
				caret = parser.caret;
				items.set(attr_name, op_code);
			}
			else
			{
				list res = parser.parser_base::readString(parser);
				parser = res[0]; op_code = res[1];
				
				items.set(attr_name, op_code.value);
			}
			
			caret = parser.parser_base::skipChar(parser, content, parser.caret);
			ch = rs::substr(content.ref, caret.pos, 1);
			string ch2 = rs::substr(content.ref, caret.pos, 2);
			if (ch2 == "/>") break;
		}
		return [parser, items];
	}
	
	
	/**
	 * Read item
	 */
	pure list<ParserBay, BaseOpCode> readWidget(ParserBay parser)
	{
		Map settings = new Map();
		Vector items = new Vector();
		
		/* Read item */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "widget"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		CoreToken token = null;
		ParserBay look = null;
		Caret caret = parser.getCaret();
		Caret caret_start = parser.getCaret();
		string end_tag = "</widget>";
		int end_tag_sz = rs::strlen(end_tag);
		
		/* Skip empty chars */
		caret = parser.parser_base::skipChar(parser, parser.content, caret);
		parser <= caret <= caret;
		
		/* Read next string */
		Caret caret = parser.getCaret();
		string next_tag = caret.nextString(end_tag_sz);
		while (next_tag != end_tag and not caret.eof())
		{
			/* Save caret */
			parser <= caret <= caret;
			ParserBay parser_item = parser;
			
			list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
			list res = parser.parser_base::readToken(parser); parser = res[0]; token = res[1];
			
			/* HTML Comment */
			if (token.content == "!--")
			{
				list res = static::readHTMLComment(parser_item); parser = res[0];
			}
			else
			{
				list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
				
				string props_name = token.content;
				string props_value = "";
				
				/* Read widget */
				if (props_name == "widget")
				{
					list res = static::readWidget(parser_item);
					parser = res[0]; BaseOpCode item = res[1];
					items.push(item);
				}
				
				/* Read widget style */
				else if (props_name == "style")
				{
					list res = static::readWidgetStyle(parser_item);
					parser = res[0]; BaseOpCode item = res[1];
					items.push(item);
				}
				
				/* Read widget item props */
				else
				{
					/* Get caret */
					Caret caret = parser.getCaret();
					
					/* Read content */
					string item_ch = caret.nextChar();
					while (item_ch != "<" and not caret.eof())
					{
						props_value += item_ch;
						caret.readChar();
						item_ch = caret.nextChar();
					}
					
					/* Save caret */
					parser <= caret <= caret;
					
					settings.set(props_name, new OpString
					{
						"caret_start": caret,
						"caret_end": parser.caret,
						"value": props_value,
					});
					
					/* Read end tag */
					list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, props_name); parser = res[0];
					list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
				}
			}
			
			/* Skip empty chars */
			caret = parser.parser_base::skipChar(parser, parser.content, parser.caret);
			parser <= caret <= caret;
			
			/* Read next string */
			Caret caret = parser.getCaret();
			next_tag = caret.nextString(end_tag_sz);
		}
		
		/* Read item */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "widget"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		/* Create widget data */
		BaseOpCode op_code = new OpWidget{
			"caret_start": caret_start,
			"caret_end": parser.caret,
			"items": items,
			"settings": settings,
		};
		
		return [parser, op_code];
	}
	
	
	/**
	 * Read widget data
	 */
	pure list<ParserBay, BaseOpCode> readWidgetData(ParserBay parser)
	{
		CoreToken token = null;
		Vector items = new Vector();
		
		/* Read data */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "data"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		Caret caret = parser.getCaret();
		Caret caret_start = parser.getCaret();
		string end_tag = "</data>";
		int end_tag_sz = rs::strlen(end_tag);
		
		/* Skip empty chars */
		caret = parser.parser_base::skipChar(parser, parser.content, caret);
		parser <= caret <= caret;
		
		/* Read next string */
		Caret caret = parser.getCaret();
		string next_tag = caret.nextString(end_tag_sz);
		while (next_tag != end_tag and not caret.eof())
		{
			/* Save caret */
			parser <= caret <= caret;
			ParserBay parser_item = parser;
			
			list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
			list res = parser.parser_base::readToken(parser); parser = res[0]; token = res[1];
			
			/* HTML Comment */
			if (token.content == "!--")
			{
				list res = static::readHTMLComment(parser_item); parser = res[0];
			}
			else
			{
				list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
				
				string item_name = token.content;
				
				/* Read widget */
				if (item_name == "widget")
				{
					list res = static::readWidget(parser_item);
					parser = res[0]; BaseOpCode item = res[1];
					items.push(item);
				}
				
				/* Read widget class */
				else if (item_name == "class")
				{
					list res = static::readWidgetClass(parser_item);
					parser = res[0]; BaseOpCode item = res[1];
					items.push(item);
				}
				
				/* Unknown name */
				else
				{
					throw new ParserError
					(
						"Unknown identifier '" ~ item_name ~ "'",
						parser_item.caret,
						parser.file_name
					);
				}
			}
			
			/* Skip empty chars */
			caret = parser.parser_base::skipChar(parser, parser.content, parser.caret);
			parser <= caret <= caret;
			
			/* Read next string */
			Caret caret = parser.getCaret();
			next_tag = caret.nextString(end_tag_sz);
		}
		
		/* Read data */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "data"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		/* Create widget data */
		BaseOpCode op_code = new OpWidgetData{
			"caret_start": caret_start,
			"caret_end": parser.caret,
			"widget": items,
		};
		
		return [parser, op_code];
	}
	
	
	/**
	 * Read UI
	 */
	pure list<ParserBay, Collection<BaseOpCode>> readUIClass(ParserBay parser)
	{
		Vector<BaseOpCode> module_items = new Vector();
		Vector<BaseOpCode> items = new Vector();
		Vector<string> components = new Vector();
		Caret class_caret_start = parser.caret;
		CoreToken token = null;
		
		string class_name = "", class_extends = "", class_version = "", class_model = "",
			item_name = "", namespace_name = "";
		string short_name = "", full_name = "", is_component = "", class_name_last = "";
		Vector class_annotations = new Vector();
		
		/* Content */
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		
		/* Read class header */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "class"); parser = res[0];
		list res = static::readAttrs(parser); parser = res[0]; Dict attrs = res[1];
		class_name = attrs.get("name", "");
		class_extends = attrs.get("extends", null);
		class_version = attrs.get("version", "1.0");
		class_model = attrs.get("model", "Runtime.Dict");
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		bool flag_is_component = true;
		bool flag_is_model = false;
		if (attrs.get("type") == "model")
		{
			flag_is_component = false;
			flag_is_model = true;
		}
		
		/* Default class extends */
		if (class_extends == null)
		{
			if (flag_is_component) class_extends = "Runtime.Web.Component";
			else class_extends = "Runtime.Web.BaseModel";
		}
		
		fn getClassShortName = string (string class_name) =>
			class_name
			|> curry rs::split(".", ?)
			|> .last()
		;
		
		if (class_name == "Runtime.Web.Component")
		{
			class_extends = "Runtime.BaseObject";
		}
		else
		{
			parser <= uses <= parser.uses.setIm( getClassShortName(class_name), class_name );
		}
		if (class_extends != "" and class_extends != null)
		{
			parser <= uses <= parser.uses.setIm( getClassShortName(class_extends), class_extends );
			if (
				class_extends != "Runtime.BaseObject" and
				class_extends != "Runtime.Web.Component" and
				class_extends != "Runtime.Web.BaseModel"
			)
			{
				components.push(class_extends);
			}
		}
		if (class_model != "" and class_model != "Runtime.Dict")
		{
			parser <= uses <= parser.uses.setIm( getClassShortName(class_model), class_model );
		}
		
		Collection class_name_arr = rs::split(".", class_name);
		class_name_last = class_name_arr.last();
		class_name_arr = class_name_arr.slice(0, -1);
		namespace_name = rs::join(".", class_name_arr);
		
		parser <= current_class_name <= class_name_last;
		parser <= current_namespace_name <= namespace_name;
		
		OpTypeIdentifier class_extend_op_code = null;
		if (class_extends != null)
		{
			class_extend_op_code = new OpTypeIdentifier
			{
				"entity_name": new OpEntityName
				{
					"caret_start": class_caret_start,
					"caret_end": parser.caret,
					"names": rs::split(".", class_extends),
				},
				"template": null,
				"caret_start": class_caret_start,
				"caret_end": parser.caret,
			}
		}
		
		/* Add namespace */
		module_items.push(new OpNamespace
		{
			"name": namespace_name,
		});
		
		/* Read class body */
		Caret caret = parser.parser_base::skipChar(parser, content, parser.caret);
		parser <= caret <= caret;
		string ch2 = rs::substr(content.ref, caret.pos, 2);
		while (ch2 != "</" and caret.pos < content_sz)
		{
			ParserBay parser_start = parser;
			Caret caret_start = parser.caret;
			list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
			list res = parser.parser_base::readToken(parser); parser = res[0];
			CoreToken item_token = res[1];
			item_name = item_token.content;
			
			/* Html comment */
			if (item_name == "!--")
			{
				list res = static::readHTMLComment(parser_start);
				parser = res[0]; items.push( res[1] );
				caret = parser.parser_base::skipChar(parser, content, parser.caret);
				ch2 = rs::substr(content.ref, caret.pos, 2);
				continue;
			}
			
			list res = static::readAttrs(parser);
			parser = res[0]; Dict item_attrs = res[1];
			
			if (item_name == "annotation")
			{
				string annotation_name = item_attrs.get("name", "");
				BaseOpCode annotation_op_code = item_attrs.get("value", null);
				class_annotations.push
				(
					new OpAnnotation
					{
						"name": new OpTypeIdentifier
						{
							"entity_name": new OpEntityName
							{
								"names": rs::split(".", annotation_name),
							},
						},
						"params": annotation_op_code,
					}
				);
			}
			else if (item_name == "use")
			{
				full_name = item_attrs.get("name", "");
				short_name = item_attrs.get("as", "");
				is_component = item_attrs.get("component", "false");
				is_component = is_component == "true" or is_component == "1";
				if (short_name == "") short_name = rs::split(".", full_name).last();
				parser <= uses <= parser.uses.setIm(short_name, full_name);
				if (is_component)
				{
					components.push(full_name);
				}
				module_items.push(new OpUse
				{
					"name": full_name,
					"alias": short_name,
					"is_component": is_component,
				});
			}
			
			/* Read body */
			list res = parser.parser_base::readToken(parser); parser = res[0]; token = res[1];
			if (token.content == ">")
			{
				if (item_name == "template")
				{
					list res = static::readHTMLTemplate(parser, item_attrs, caret_start);
					parser = res[0]; BaseOpCode op_code = res[1];
					items.push(op_code);
				}
				else if (item_name == "style")
				{
					list res = static::readStyle(parser, item_attrs, items, caret_start);
					parser = res[0]; BaseOpCode op_code = res[1];
					items.push(op_code);
				}
				else if (item_name == "script")
				{
					list res = parser.parser_program::readClassBody(parser, "</");
					parser = res[0]; Collection<BaseOpCode> arr = res[1];
					items.appendItems(arr);
					
					/* Read script footer */
					list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, "script"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
				}
				/*
				else if (item_name == "data")
				{
					parser = parser.copy{ "caret": caret_start };
					Dict<bool> save_vars = parser.vars;
					list res = static::readWidgetData(parser, "data"); parser = res[0];
					items.push(res[1]);
					BaseOpCode op_data = res[1];
					parser <= vars <= save_vars;
				}
				*/
				else
				{
					throw new ParserError
					(
						"Unknown identifier '" ~ item_name ~ "'",
						item_token.caret_start, parser.file_name
					);
				}
			}
			
			else if (token.content == "/")
			{
				list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
			}
			else
			{
				throw new ParserError
				(
					"Unknown identifier '" ~ token.content ~ "'",
					token.caret_start, parser.file_name
				);
			}
			
			caret = parser.parser_base::skipChar(parser, content, parser.caret);
			parser <= caret <= caret;
			ch2 = rs::substr(content.ref, caret.pos, 2);
		}
		
		/* Add components function */
		if (components.count() > 0)
		{
			OpDeclareFunction f = new OpDeclareFunction
			{
				"args": [],
				"vars": [],
				"flags": new OpFlags
				{
					"p_static": true,
					"p_pure": true,
				},
				"name": "components",
				"result_type": "var",
				"expression": new OpCollection
				{
					"caret_start": parser.caret,
					"caret_end": parser.caret,
					"values":
						components
							.map
							(
								OpString (string class_name) use (parser) =>
									new OpString
									{
										"caret_start": parser.caret,
										"caret_end": parser.caret,
										"value": class_name,
									}
							)
					,
				},
				"items": null,
				"caret_start": parser.caret,
				"caret_end": parser.caret,
			};
			
			items.push(f);
		}
		
		/* Read class footer */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "class"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		/* Analyze class body */
		Dict class_body = parser.parser_program::classBodyAnalyze(parser, items);
		
		/* Add class */
		module_items.push(new OpDeclareClass
		{
			"kind": OpDeclareClass::KIND_CLASS,
			"name": class_name_last,
			"is_static": true,
			"is_component": flag_is_component,
			"is_model": flag_is_model,
			"is_declare": false,
			"class_extends": class_extend_op_code,
			"class_implements": null,
			"annotations": [],
			"template": null,
			"vars": class_body.item("vars"),
			"annotations": class_annotations,
			"functions": class_body.item("functions"),
			"fn_create": class_body.item("fn_create"),
			"fn_destroy": class_body.item("fn_destroy"),
			"items": items,
			"caret_start": class_caret_start,
			"caret_end": parser.caret,
		});
		
		return
		[
			parser,
			module_items
		];
	}
	
	
	/**
	 * Read UI
	 */
	pure list<ParserBay, BaseOpCode> readUI(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		Vector<BaseOpCode> items = new Vector();
		
		parser <= skip_comments <= false;
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		parser <= skip_comments <= true;
		
		while (token.content == "<")
		{
			ParserBay parser_start = parser;
			parser = look;
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			
			if (token.content == "class")
			{
				list res = static::readUIClass(parser_start);
				parser = res[0];
				items.appendItems( res[1] );
			}
			else if (token.content == "!--")
			{
				list res = static::readHTMLComment(parser_start);
				parser = res[0];
				items.push( res[1] );
			}
			
			parser <= skip_comments <= false;
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			parser <= skip_comments <= true;
		}
		
		
		return
		[
			parser,
			new OpModule
			{
				"is_component": true,
				"uses": parser.uses,
				"items": items,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
}
