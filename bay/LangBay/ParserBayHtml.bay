/*!
 *  Bayrell Language
 *
 *  (c) Copyright 2016-2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Bayrell.Lang.LangBay;

use Runtime.re;
use Runtime.BaseObject;
use Runtime.BaseStruct;
use Runtime.Reference;
use Runtime.RuntimeUtils;
use Bayrell.Lang.Caret;
use Bayrell.Lang.CoreParser;
use Bayrell.Lang.CoreToken;
use Bayrell.Lang.Exceptions.ParserError;
use Bayrell.Lang.Exceptions.ParserExpected;
use Bayrell.Lang.LangBay.ParserBay;
use Bayrell.Lang.OpCodes.BaseOpCode;
use Bayrell.Lang.OpCodes.OpAnnotation;
use Bayrell.Lang.OpCodes.OpCollection;
use Bayrell.Lang.OpCodes.OpComment;
use Bayrell.Lang.OpCodes.OpDeclareClass;
use Bayrell.Lang.OpCodes.OpDeclareFunction;
use Bayrell.Lang.OpCodes.OpDeclareFunctionArg;
use Bayrell.Lang.OpCodes.OpEntityName;
use Bayrell.Lang.OpCodes.OpFlags;
use Bayrell.Lang.OpCodes.OpHtmlAttribute;
use Bayrell.Lang.OpCodes.OpHtmlContent;
use Bayrell.Lang.OpCodes.OpHtmlItems;
use Bayrell.Lang.OpCodes.OpHtmlTag;
use Bayrell.Lang.OpCodes.OpHtmlValue;
use Bayrell.Lang.OpCodes.OpIdentifier;
use Bayrell.Lang.OpCodes.OpMath;
use Bayrell.Lang.OpCodes.OpModule;
use Bayrell.Lang.OpCodes.OpNamespace;
use Bayrell.Lang.OpCodes.OpString;
use Bayrell.Lang.OpCodes.OpTypeIdentifier;
use Bayrell.Lang.OpCodes.OpUse;


class ParserBayHtml extends BaseObject
{
	
	
	/**
	 * Retuns css hash
	 * @param string component class name
	 * @return string hash
	 */
	static memorize string getCssHash(string s)
	{
		string r = "";
		string a = "1234567890abcdef";
		int sz = rs::strlen(s);
		int h = 0;
		for (int i=0; i<sz; i++)
		{
			int c = rs::ord( rs::substr(s, i, 1) );
			h = ((h << 2) + (h >> 14) + c) & 65535;
		}
		int p = 0;
		while (h != 0 or p < 4)
		{
			int c = h & 15;
			h = h >> 4;
			r ~= rs::substr(a, c, 1);
			p = p + 1;
		}
		return r;
	}
	
	
	
	/**
	 * Read css selector
	 */
	pure list<ParserBay, string> readCssSelector(ParserBay parser)
	{
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		string class_name = parser.current_namespace_name ~ "." ~ parser.current_class_name;
		string ch = rs::substr(content.ref, pos, 1);
		if (ch == "(")
		{
			pos = pos + 1;
			x = parser.parser_base::nextX(parser, ch, x);
			y = parser.parser_base::nextY(parser, ch, y);
			int start_pos = pos;
			while (pos < content_sz and ch != ")")
			{
				pos = pos + 1;
				x = parser.parser_base::nextX(parser, ch, x);
				y = parser.parser_base::nextY(parser, ch, y);
				ch = rs::substr(content.ref, pos, 1);
			}
			class_name = rs::substr(content.ref, start_pos, pos - start_pos);
			if (parser.uses.has(class_name))
			{
				class_name = parser.uses.item(class_name);
			}
			pos = pos + 1;
			x = parser.parser_base::nextX(parser, ch, x);
			y = parser.parser_base::nextY(parser, ch, y);
		}
		
		int start_pos = pos;
		ch = rs::substr(content.ref, pos, 1);
		while (
			pos < content_sz and ch != " " and ch != "," and 
			ch != "." and ch != ":" and ch != "[" and ch != "{"
		)
		{
			pos = pos + 1;
			x = parser.parser_base::nextX(parser, ch, x);
			y = parser.parser_base::nextY(parser, ch, y);
			ch = rs::substr(content.ref, pos, 1);
		}
		string postfix = rs::substr(content.ref, start_pos, pos - start_pos);
		string selector = "." ~ postfix ~ ".h-" ~ static::getCssHash(class_name);
		Caret caret = new Caret{ "x": x, "y": y, "pos": pos };
		parser <= caret <= caret;
		return [parser, selector];
	}
	
	
	
	/**
	 * Read css body
	 */
	pure list<ParserBay, BaseOpCode> readCssBody(ParserBay parser, Dict flags = null)
	{
		if (flags == null)
		{
			flags =
			{
				"expression": true,
				"css_selector": true,
			};
		}
		else
		{
			flags <= expression <= ( flags["expression"] |> default bool true );
			flags <= css_selector <= ( flags["css_selector"] |> default bool true );
		}
		Caret caret_start = parser.caret;
		Caret caret_last = parser.caret;
		
		bool is_first_selector = true;
		BaseOpCode op_code = null;
		string css_str = "";
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		int bracket_level = 0;
		int start_pos = pos;
		
		string ch = rs::substr(content.ref, pos, 1);
		string ch2 = rs::substr(content.ref, pos, 2);
		string ch6 = rs::substr(content.ref, pos, 6);
		while (pos < content_sz and (ch != "}" or ch == "}" and bracket_level > 0) and ch != "<")
		{
			/* Read expression */
			if (ch2 == "${")
			{
				list res = parser.parser_base::next(parser, ch2, x, y, pos);
				x = res[0]; y = res[1]; pos = res[2];
				
				/* Add value */
				string value = rs::substr(content.ref, start_pos, pos - start_pos - 2);
				if (value != "") css_str ~= value;
				
				/* Add css op code */
				css_str = rs::replace("\t", "", css_str);
				css_str = rs::replace("\n", "", css_str);
				if (css_str != "")
				{
					OpString css_str_op_code = new OpString
					{
						"caret_start": caret_last,
						"caret_end": parser.caret,
						"value": css_str,
					};
					if (op_code == null) op_code = css_str_op_code;
					else op_code = new OpMath
					{
						"caret_start": caret_start,
						"caret_end": parser.caret,
						"value1": op_code,
						"value2": css_str_op_code,
						"math": "~",
					};
				}
				
				/* Read CSS Selector */
				Caret caret = new Caret{ "x": x, "y": y, "pos": pos };
				parser <= caret <= caret;
				list res = parser.parser_expression::ExpressionPipe(parser);
				parser = res[0]; BaseOpCode expr = res[1];
				list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
				
				/* Add expr op code */
				if (expr != null)
				{
					if (op_code == null) op_code = expr;
					else op_code = new OpMath
					{
						"caret_start": caret_start,
						"caret_end": parser.caret,
						"value1": op_code,
						"value2": expr,
						"math": "~",
					};
				}
				
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
				
				/* Set css str */
				css_str = "";
				caret_last = caret;
				is_first_selector = true;
			}
			
			/* Read media css */
			else if (ch6 == "@media")
			{
				while (pos < content_sz and ch != "{")
				{
					x = parser.parser_base::nextX(parser, ch, x);
					y = parser.parser_base::nextY(parser, ch, y);
					pos = pos + 1;
					ch = rs::substr(content.ref, pos, 1);
				}
				
				/* Add value */
				string value = rs::substr(content.ref, start_pos, pos - start_pos);
				if (value != "") css_str ~= value;
				css_str ~= "{";
				
				/* Add css op code */
				css_str = rs::replace("\t", "", css_str);
				css_str = rs::replace("\n", "", css_str);
				if (css_str != "")
				{
					OpString css_str_op_code = new OpString
					{
						"caret_start": caret_last,
						"caret_end": parser.caret,
						"value": css_str,
					};
					if (op_code == null) op_code = css_str_op_code;
					else op_code = new OpMath
					{
						"caret_start": caret_start,
						"caret_end": parser.caret,
						"value1": op_code,
						"value2": css_str_op_code,
						"math": "~",
					};
				}
				
				/* Read CSS Block */
				Caret caret = new Caret{ "x": x, "y": y, "pos": pos };
				parser <= caret <= caret;
				list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
				list res = static::readCssBody
				(
					parser,
					{
						"css_selector": true,
					}
				);
				parser = res[0]; BaseOpCode expr = res[1];
				list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
				
				/* Add expr op code */
				if (expr != null)
				{
					if (op_code == null) op_code = expr;
					else op_code = new OpMath
					{
						"caret_start": caret_start,
						"caret_end": parser.caret,
						"value1": op_code,
						"value2": expr,
						"math": "~",
					};
				}
				
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
				
				/* Set css str */
				css_str = "}";
				caret_last = caret;
				is_first_selector = true;
			}
			
			/* If html or tag */
			else if (
				(ch == "%" or (parser.is_local_css and ch == "." and is_first_selector)) and
				flags["css_selector"] == true
			)
			{
				x = parser.parser_base::nextX(parser, ch, x);
				y = parser.parser_base::nextY(parser, ch, y);
				pos = pos + 1;
				
				/* Add value */
				string value = rs::substr(content.ref, start_pos, pos - start_pos - 1);
				if (value != "") css_str ~= value;
				
				/* Read CSS Selector */
				Caret caret = new Caret{ "x": x, "y": y, "pos": pos };
				parser <= caret <= caret;
				list res = static::readCssSelector(parser);
				parser = res[0]; string s = res[1];
				css_str ~= s;
				
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
				is_first_selector = false;
			}
			
			/* Read css block */
			else if (ch == "{")
			{
				/* Add value */
				string value = rs::substr(content.ref, start_pos, pos - start_pos);
				if (value != "") css_str ~= value;
				css_str ~= "{";
				
				/* Add css op code */
				css_str = rs::replace("\t", "", css_str);
				css_str = rs::replace("\n", "", css_str);
				if (css_str != "")
				{
					OpString css_str_op_code = new OpString
					{
						"caret_start": caret_last,
						"caret_end": parser.caret,
						"value": css_str,
					};
					if (op_code == null) op_code = css_str_op_code;
					else op_code = new OpMath
					{
						"caret_start": caret_start,
						"caret_end": parser.caret,
						"value1": op_code,
						"value2": css_str_op_code,
						"math": "~",
					};
				}
				
				/* Read CSS Block */
				Caret caret = new Caret{ "x": x, "y": y, "pos": pos };
				parser <= caret <= caret;
				list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
				list res = static::readCssBody
				(
					parser,
					{
						"css_selector": false,
					}
				);
				parser = res[0]; BaseOpCode expr = res[1];
				list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
				
				/* Add expr op code */
				if (expr != null)
				{
					if (op_code == null) op_code = expr;
					else op_code = new OpMath
					{
						"caret_start": caret_start,
						"caret_end": parser.caret,
						"value1": op_code,
						"value2": expr,
						"math": "~",
					};
				}
				
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
				
				/* Set css str */
				css_str = "}";
				caret_last = caret;
				is_first_selector = true;
			}
			else
			{
				x = parser.parser_base::nextX(parser, ch, x);
				y = parser.parser_base::nextY(parser, ch, y);
				pos = pos + 1;
				if (ch == " " or ch == "," or ch == "{") is_first_selector = true;
			}
			
			ch = rs::substr(content.ref, pos, 1);
			ch2 = rs::substr(content.ref, pos, 2);
			ch6 = rs::substr(content.ref, pos, 6);
		}
		
		/* Push item */
		string value = rs::substr(content.ref, start_pos, pos - start_pos);
		Caret caret = new Caret{ "x": x, "y": y, "pos": pos };
		if (value != "") css_str ~= value;
		
		/* Add css op code */
		css_str = rs::replace("\t", "", css_str);
		css_str = rs::replace("\n", "", css_str);
		if (css_str != "")
		{
			OpString css_str_op_code = new OpString
			{
				"caret_start": caret_last,
				"caret_end": parser.caret,
				"value": css_str,
			};
			if (op_code == null) op_code = css_str_op_code;
			else op_code = new OpMath
			{
				"caret_start": caret_start,
				"caret_end": parser.caret,
				"value1": op_code,
				"value2": css_str_op_code,
				"math": "~",
			};
		}
		
		parser <= caret <= caret;
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read css
	 */
	pure list<ParserBay, BaseOpCode> readCss(ParserBay parser)
	{
		Caret caret_start = parser.caret;
		
		list res = parser.parser_base::matchToken(parser, "@css"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
		
		list res = static::readCssBody(parser);
		parser = res[0]; BaseOpCode op_code = res[1];
		
		if (op_code == null)
		{
			op_code = new OpString
			{
				"caret_start": caret_start,
				"caret_end": parser.caret,
				"value": "",
			};
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read html comment
	 */
	pure list<ParserBay, OpComment> readHTMLComment(ParserBay parser)
	{
		ParserBay start = parser;
		CoreToken token = null;
		ParserBay look = null;
		Caret caret_start = parser.caret;
		
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "!--"); parser = res[0];
		
		string content = parser.content;
		int content_sz = parser.content_sz;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		int pos_start = pos;
		
		string ch = rs::charAt(content.ref, pos);
		string ch3 = rs::substr(content.ref, pos, 3);
		while (ch3 != "-->" and pos < content_sz)
		{
			x = parser.parser_base::nextX(parser, ch, x);
			y = parser.parser_base::nextY(parser, ch, y);
			pos = pos + 1;
			if (pos >= parser.content_sz)
			{
				break;
			}
			ch = rs::charAt(content.ref, pos);
			ch3 = rs::substr(content.ref, pos, 3);
		}
		
		int pos_end = pos;
		if (ch3 == "-->")
		{
			x = x + 3;
			pos = pos + 3;
		}
		else
		{
			throw new ParserExpected
			(
				"End of comment",
				new Caret{ "x": x, "y": y, "pos": pos },
				start.file_name
			);
		}
		
		/* Return result */
		string value_str = rs::substr(content.ref, pos_start, pos_end - pos_start);
		Caret caret_end = new Caret{ "x": x, "y": y, "pos": pos };
		
		return
		[
			start.copy({ "caret": caret_end }),
			new OpComment
			{
				"value": value_str,
				"caret_start": caret_start,
				"caret_end": caret_end,
			}
		];
		
		
		return [parser, null];
	}
	
	
	/**
	 * Read html value
	 */
	pure list<ParserBay, BaseOpCode> readHTMLValue(ParserBay parser)
	{
		BaseOpCode item = null;
		Caret caret = parser.caret;
		Reference<string> content = parser.content;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		string ch = rs::substr(content.ref, pos, 1);
		if (ch == "<")
		{
			list res = static::readHTMLTag(parser);
			parser = res[0]; item = res[1];
		}
		else if (ch == "{")
		{
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; item = res[1];
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
		}
		else if (ch == "@")
		{
			x = parser.parser_base::nextX(parser, ch, x);
			y = parser.parser_base::nextY(parser, ch, y);
			pos = pos + 1;
			
			string ch3 = rs::substr(content.ref, pos, 3);
			string ch4 = rs::substr(content.ref, pos, 4);
			if (ch3 == "raw" or ch4 == "json" or ch4 == "html")
			{
				list res;
				if (ch3 == "raw") res = parser.parser_base::next(parser, ch3, x, y, pos);
				if (ch4 == "json") res = parser.parser_base::next(parser, ch4, x, y, pos);
				if (ch4 == "html") res = parser.parser_base::next(parser, ch4, x, y, pos);
				x = res[0]; y = res[1]; pos = res[2];
			}
			
			caret = new Caret{ "x": x, "y": y, "pos": pos };
			parser <= caret <= caret;
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; item = res[1];
			
			if (ch3 == "raw")
			{
				item = new OpHtmlValue
				{
					"kind": OpHtmlValue::KIND_RAW,
					"value": item,
					"caret_start": caret,
					"caret_end": parser.caret,
				};
			}
			else if (ch4 == "json")
			{
				item = new OpHtmlValue
				{
					"kind": OpHtmlValue::KIND_JSON,
					"value": item,
					"caret_start": caret,
					"caret_end": parser.caret,
				};
			}
			else if (ch4 == "html")
			{
				item = new OpHtmlValue
				{
					"kind": OpHtmlValue::KIND_HTML,
					"value": item,
					"caret_start": caret,
					"caret_end": parser.caret,
				};
			}
			
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
		}
		
		return [parser, item];
	}
	
	
	
	/**
	 * Read html attribute key
	 */
	pure list<ParserBay, string> readHTMLAttrKey(ParserBay parser)
	{
		CoreToken token = null;
		ParserBay look = null;
		OpIdentifier ident = null;
		string key = "";
		
		/* Look token */
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "@")
		{
			parser = look;
			key = "@";
		}
		
		list res = parser.parser_base::readIdentifier(parser); parser = res[0]; ident = res[1];
		key ~= ident.value;
		
		/* Read attr */
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		while (token.content == "-")
		{
			list res = parser.parser_base::readIdentifier(look); parser = res[0]; ident = res[1];
			key ~= "-" ~ ident.value;
			
			/* Look next token */
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		}
		
		/* Look token */
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content == ":")
		{
			parser = look;
			key ~= ":";
			list res = parser.parser_base::readIdentifier(parser); parser = res[0]; ident = res[1];
			key ~= ident.value;
		}
		
		return [parser, key];
	}
	
	
	
	/**
	 * Read html attribute value
	 */
	pure list<ParserBay, BaseOpCode> readHTMLAttrValue(ParserBay parser)
	{
		CoreToken token = null;
		ParserBay look = null;
		BaseOpCode op_code = null;
		OpIdentifier ident = null;
		
		/* Look token */
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "{")
		{
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; op_code = res[1];
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
		}
		else if (token.content == "@")
		{
			list res = static::readHTMLValue(parser);
			parser = res[0]; op_code = res[1];
		}
		else if (token.content == "[")
		{
			list res = parser.parser_base::readCollection(parser); parser = res[0]; op_code = res[1];
		}
		else
		{
			list res = parser.parser_base::readString(parser); parser = res[0]; op_code = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read html attributes
	 */
	pure list<ParserBay, BaseOpCode> readHTMLAttrs(ParserBay parser)
	{
		Vector<OpHtmlAttribute> items = new Vector();
		
		CoreToken token = null;
		ParserBay look = null;
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		Caret caret = parser.parser_base::skipChar(parser, content, parser.caret);
		string ch = rs::substr(content.ref, caret.pos, 1);
		while (ch != "/" and ch != ">" and caret.pos < content_sz)
		{
			Caret caret_start = caret;
			parser <= caret <= caret;
			
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			if (token.content == "...")
			{
				OpIdentifier ident = null;
				list res = parser.parser_base::matchToken(parser, "..."); parser = res[0];
				list res = parser.parser_base::readIdentifier(look); parser = res[0]; ident = res[1];
				items.push
				(
					new OpHtmlAttribute
					{
						"value": ident,
						"is_spread": true,
						"caret_start": caret_start,
						"caret_end": parser.caret,
					}
				);
			}
			else
			{
				list res = static::readHTMLAttrKey(parser); parser = res[0]; string key = res[1];
				list res = parser.parser_base::matchToken(parser, "="); parser = res[0];
				list res = static::readHTMLAttrValue(parser); parser = res[0]; BaseOpCode value = res[1];
				items.push
				(
					new OpHtmlAttribute
					{
						"key": key,
						"value": value,
						"caret_start": caret_start,
						"caret_end": parser.caret,
					}
				);
			}
			caret = parser.parser_base::skipChar(parser, content, parser.caret);
			ch = rs::substr(content.ref, caret.pos, 1);
			string ch2 = rs::substr(content.ref, caret.pos, 2);
			if (ch2 == "/>") break;
		}
		
		return [parser, items.toCollection()];
	}
	
	
	
	/**
	 * Read html template
	 */
	pure list<ParserBay, Collection> readHTMLContent(ParserBay parser, string end_tag)
	{
		Vector<BaseOpCode> items = new Vector();
		BaseOpCode item = null;
		CoreToken token = null;
		ParserBay look = null;
		Caret caret = null;
		Caret caret_start = parser.caret;
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		int start_pos = pos;
		int end_tag_sz = rs::strlen(end_tag);
		string ch2 = rs::substr(content.ref, pos, end_tag_sz);
		bool flag_first = true;
		bool first_html_tag = false;
		if (end_tag == "") first_html_tag = true;
		while ( ( end_tag == "" or (end_tag != "" and ch2 != end_tag) ) and pos < content_sz)
		{
			string ch = rs::substr(content.ref, pos, 1);
			string ch3 = rs::substr(content.ref, pos, 3);
			string ch4 = rs::substr(content.ref, pos, 4);
			string ch6 = rs::substr(content.ref, pos, 6);
			string ch7 = rs::substr(content.ref, pos, 7);
			
			/* Html comment */
			if (ch4 == "<!--")
			{
				string value = rs::substr(content.ref, start_pos, pos - start_pos);
				caret = new Caret{ "x": x, "y": y, "pos": pos };
				value = rs::trim(value, "\t\r\n");
				value = rs::trim(value, " ");
				if (value != "")
				{
					item = new OpHtmlContent
					{
						"value": value,
						"caret_start": caret_start,
						"caret_end": caret,
					}
					items.push(item);
				}
				
				/* Read HTML Comment */
				parser <= caret <= caret;
				list res = static::readHTMLComment(parser);
				parser = res[0]; items.push( res[1] );
				
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			
			/* If html or tag */
			else if (ch == "<" or ch == "{" or ch == "@")
			{
				string value = rs::substr(content.ref, start_pos, pos - start_pos);
				caret = new Caret{ "x": x, "y": y, "pos": pos };
				value = rs::trim(value, "\t\r\n");
				
				if (flag_first and first_html_tag) value = rs::trim(value, " ");
				if (value != "")
				{
					item = new OpHtmlContent
					{
						"value": value,
						"caret_start": caret_start,
						"caret_end": caret,
					}
					items.push(item);
				}
				
				/* Read HTML Value */
				parser <= caret <= caret;
				list res = static::readHTMLValue(parser);
				parser = res[0]; item = res[1];
				items.push(item);
				
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			
			/* If html operator */
			else if (ch3 == "%if" or ch4 == "%for" or ch4 == "%var" or ch6 == "%while" or ch7 == "%render")
			{
				string value = rs::substr(content.ref, start_pos, pos - start_pos);
				caret = new Caret{ "x": x, "y": y, "pos": pos };
				value = rs::trim(value, "\t\r\n");
				value = rs::trim(value, " ");
				if (value != "")
				{
					item = new OpHtmlContent
					{
						"value": value,
						"caret_start": caret_start,
						"caret_end": caret,
					}
					items.push(item);
				}
				
				/* Read HTML Operator */
				parser <= caret <= caret;
				list res = static::readHTMLOperator(parser);
				parser = res[0]; item = res[1];
				items.push(item);
				
				/* Set pos, x, y */
				caret_start = parser.caret;
				pos = parser.caret.pos;
				x = parser.caret.x;
				y = parser.caret.y;
				start_pos = pos;
			}
			
			else
			{
				if (first_html_tag and ch != " " and ch != "\t" and ch != "\r" and ch != "\n")
				{
					break;
				}
				x = parser.parser_base::nextX(parser, ch, x);
				y = parser.parser_base::nextY(parser, ch, y);
				pos = pos + 1;
			}
			ch2 = rs::substr(content.ref, pos, end_tag_sz);
		}
		
		/* Push item */
		string value = rs::substr(content.ref, start_pos, pos - start_pos);
		value = rs::trim(value, "\t\r\n");
		caret = new Caret{ "x": x, "y": y, "pos": pos };
		if (first_html_tag) value = rs::trim(value, " ");
		if (value != "")
		{
			item = new OpHtmlContent
			{
				"value": value,
				"caret_start": caret_start,
				"caret_end": caret,
			}
			items.push(item);
		}
		
		return [ parser.copy{ "caret": caret }, items ];
	}
	
	
	
	/**
	 * Read html tag
	 */
	pure list<ParserBay, BaseOpCode> readHTMLTag(ParserBay parser)
	{
		CoreToken token = null;
		ParserBay look = null;
		OpIdentifier ident = null;
		Caret caret_items_start = null, caret_items_end = null;
		Caret caret_start = parser.caret;
		Collection<BaseOpCode> items = null;
		BaseOpCode op_code_name = null;
		bool is_single_flag = false;
		bool op_code_flag = false;
		string tag_name = "";
		
		/* Tag start */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		
		/* Look token */
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "{")
		{
			op_code_flag = true;
			Caret caret1 = parser.caret;
			list res = parser.parser_base::matchToken(parser, "{"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; op_code_name = res[1];
			list res = parser.parser_base::matchToken(parser, "}"); parser = res[0];
			Caret caret2 = parser.caret;
			tag_name = rs::substr(parser.content.ref, caret1.pos, caret2.pos - caret1.pos);
		}
		else if (token.content == ">")
		{
			op_code_flag = true;
			tag_name = "";
		}
		else
		{
			list res = parser.parser_base::readIdentifier(parser, false);
			parser = res[0]; ident = res[1];
			tag_name = ident.value;
		}
		
		list res = static::readHTMLAttrs(parser); parser = res[0]; Collection<OpHtmlAttribute> attrs = res[1];
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "/")
		{
			parser = look;
			is_single_flag = true;
		}
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		if (not is_single_flag)
		{
			if (tag_name == "svg")
			{
				list res = parser.parser_base::readUntilStringArr(parser, ["</svg>"], false); parser = res[0];
				string content = res[1];
				content = re::replace("[\t\n]", "", content);
				
				Collection<BaseOpCode> items =
				[
					new OpHtmlValue
					{
						"kind": OpHtmlValue::KIND_RAW,
						"value": new OpString
						{
							"caret_start": parser.caret,
							"caret_end": parser.caret,
							"value": content,
						},
						"caret_start": caret_start,
						"caret_end": parser.caret,
					}
				];
				
			}
			else
			{
				/* Read items */
				caret_items_start = parser.caret;
				list res = static::readHTMLContent(parser, "</" ~ tag_name);
				parser = res[0]; Collection<BaseOpCode> items = res[1];
				caret_items_end = parser.caret;
			}
			
			/* Tag end */
			if (op_code_flag)
			{
				list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
				list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
				if (tag_name)
				{
					list res = parser.parser_base::matchString(parser, tag_name); parser = res[0];
				}
				list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
			}
			else
			{
				list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
				list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
				if (ident != null)
				{
					list res = parser.parser_base::matchToken(parser, tag_name); parser = res[0];
				}
				list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
			}
		}
		
		OpHtmlTag op_code = new OpHtmlTag
		{
			"attrs": attrs,
			"tag_name": tag_name,
			"op_code_name": op_code_name,
			"caret_start": caret_start,
			"caret_end": parser.caret,
			"items": (items != null) ? new OpHtmlItems
			{
				"caret_start": caret_items_start,
				"caret_end": caret_items_end,
				"items": items.toCollection()
			} : null,
		};
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read html operator
	 */
	pure list<ParserBay, BaseOpCode> readHTMLOperator(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		
		if (token.content == "%if")
		{
			return parser.parser_operator::readIf(parser);
		}
		else if (token.content == "%for")
		{
			return parser.parser_operator::readFor(parser);
		}
		else if (token.content == "%while")
		{
			return parser.parser_operator::readWhile(parser);
		}
		else if (token.content == "%var")
		{
			BaseOpCode op_code = null;
			list res = parser.parser_base::matchToken(parser, "%var"); parser = res[0];
			list res = parser.parser_operator::readAssign(parser); parser = res[0]; op_code = res[1];
			list res = parser.parser_base::matchToken(parser, ";"); parser = res[0];
			return [parser, op_code];
		}
		else if (token.content == "%render")
		{
			BaseOpCode op_code = null;
			list res = parser.parser_base::matchToken(parser, "%render"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; op_code = res[1];
			list res = parser.parser_base::matchToken(parser, ";"); parser = res[0];
			return [parser, op_code];
		}
		
		return [parser, null];
	}
	
	
	
	/**
	 * Read html template
	 */
	pure list<ParserBay, BaseOpCode> readHTML(ParserBay parser, string end_tag = "")
	{
		Caret caret_start = parser.caret;
		
		/* Enable html flag */
		bool save_is_html = parser.is_html;
		parser <= is_html <= true;
		
		list res = static::readHTMLContent(parser, end_tag);
		parser = res[0]; Collection<BaseOpCode> items = res[1];
		
		OpHtmlItems op_code = new OpHtmlItems
		{
			"caret_start": caret_start,
			"caret_end": parser.caret,
			"items": items,
		}
		
		/* Disable html flag */
		parser <= is_html <= save_is_html;
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read html attributes
	 */
	pure list<ParserBay, Dict> readAttrs(ParserBay parser)
	{
		ParserBay look = null;
		BaseOpCode op_code = null;
		CoreToken token = null;
		CoreToken look_token = null;
		Map items = new Map();
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz
		Caret caret = parser.parser_base::skipChar(parser, content, parser.caret);
		string ch = rs::substr(content.ref, caret.pos, 1);
		while (ch != "/" and ch != ">" and caret.pos < content_sz)
		{
			list res = parser.parser_base::readToken(parser); parser = res[0]; token = res[1];
			list res = parser.parser_base::matchToken(parser, "="); parser = res[0];
			string attr_name = token.content;
			
			/* Look token */
			list res = parser.parser_base::readToken(parser); look_token = res[1];
			if (look_token.content == "{")
			{
				list res = parser.parser_base::readDict(parser); parser = res[0]; op_code = res[1];
				caret = parser.caret;
				items.set(attr_name, op_code);
			}
			else
			{
				list res = parser.parser_base::readString(parser); parser = res[0]; op_code = res[1];
				items.set(attr_name, op_code.value);
			}
			
			caret = parser.parser_base::skipChar(parser, content, parser.caret);
			ch = rs::substr(content.ref, caret.pos, 1);
			string ch2 = rs::substr(content.ref, caret.pos, 2);
			if (ch2 == "/>") break;
		}
		return [parser, items.toDict()];
	}
	
	
	
	/**
	 * Read UI
	 */
	pure list<ParserBay, BaseOpCode> readUIClass(ParserBay parser)
	{
		Vector<BaseOpCode> items = new Vector();
		Vector<string> components = new Vector();
		Caret class_caret_start = parser.caret;
		CoreToken token = null;
		
		string class_name = "", class_extends = "", class_version = "", class_model = "",
			item_name = "", namespace_name = "";
		string short_name = "", full_name = "", is_component = "", class_name_last = "";
		Vector class_annotations = new Vector();
		
		/* Content */
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		
		/* Read class header */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "class"); parser = res[0];
		list res = static::readAttrs(parser); parser = res[0]; Dict attrs = res[1];
		class_name = attrs.get("name", "");
		class_extends = attrs.get("extends", "Runtime.Web.Component");
		class_version = attrs.get("version", "1.0");
		class_model = attrs.get("model", "Runtime.Dict");
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		fn getClassShortName = string (string class_name) => class_name |> curry rs::split("\\.", ?) |> .last();
		if (class_name != "")
		{
			parser <= uses <= parser.uses.setIm( getClassShortName(class_name), class_name );
		}
		if (class_extends != "")
		{
			parser <= uses <= parser.uses.setIm( getClassShortName(class_extends), class_extends );
			if (class_extends != "Runtime.Web.Component") components.push(class_extends);
		}
		if (class_model != "" and class_model != "Runtime.Dict")
		{
			parser <= uses <= parser.uses.setIm( getClassShortName(class_model), class_model );
		}
		
		Collection class_name_arr = rs::split("\\.", class_name);
		class_name_last = class_name_arr.last();
		class_name_arr = class_name_arr.removeLastIm();
		namespace_name = rs::join(".", class_name_arr);
		
		parser <= current_class_name <= class_name_last;
		parser <= current_namespace_name <= namespace_name;
		
		OpTypeIdentifier class_extend_op_code = new OpTypeIdentifier
		{
			"entity_name": new OpEntityName
			{
				"caret_start": class_caret_start,
				"caret_end": parser.caret,
				"names": rs::split("\\.", class_extends),
			},
			"template": null,
			"caret_start": class_caret_start,
			"caret_end": parser.caret,
		}
		
		/* Read class body */
		Caret caret = parser.parser_base::skipChar(parser, content, parser.caret);
		string ch2 = rs::substr(content.ref, caret.pos, 2);
		while (ch2 != "</" and caret.pos < content_sz)
		{
			ParserBay parser_start = parser;
			Caret caret_start = parser.caret;
			list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
			list res = parser.parser_base::readToken(parser); parser = res[0]; CoreToken item_token = res[1];
			item_name = item_token.content;
			
			/* Html comment */
			if (item_name == "!--")
			{
				list res = static::readHTMLComment(parser_start);
				parser = res[0]; items.push( res[1] );
				caret = parser.parser_base::skipChar(parser, content, parser.caret);
				ch2 = rs::substr(content.ref, caret.pos, 2);
				continue;
			}
			
			list res = static::readAttrs(parser); parser = res[0]; Dict item_attrs = res[1];
			
			if (item_name == "annotation")
			{
				string annotation_name = item_attrs.get("name", "");
				BaseOpCode annotation_op_code = item_attrs.get("value", null);
				class_annotations.push
				(
					new OpAnnotation
					{
						"name": new OpTypeIdentifier
						{
							"entity_name": new OpEntityName
							{
								"names": rs::split("\\.", annotation_name),
							},
						},
						"params": annotation_op_code,
					}
				);
			}
			else if (item_name == "use")
			{
				full_name = item_attrs.get("name", "");
				short_name = item_attrs.get("as", "");
				is_component = item_attrs.get("component", "false");
				if (short_name == "") short_name = rs::explode(".", full_name).last();
				parser <= uses <= parser.uses.setIm(short_name, full_name);
				if (is_component == "true" or is_component == "1")
				{
					components.push(full_name);
				}
			}
			
			/* Read body */
			list res = parser.parser_base::readToken(parser); parser = res[0]; token = res[1];
			if (token.content == ">")
			{
				if (item_name == "template")
				{
					string fn_name = item_attrs.get("name", "render");
					string fn_args_str = item_attrs.get("args", "");
					Dict<bool> parser2_vars = {};
					
					Collection<OpDeclareFunctionArg> fn_args = null;
					if (item_attrs.has("args"))
					{
						ParserBay parser2 = parser::setContent(parser, fn_args_str);
						parser2 <= caret <= new Caret{};
						
						/* Parse args */
						list res = parser.parser_operator::readDeclareFunctionArgs(parser2, false, false);
						parser2 = res[0]; fn_args = res[1];
						parser2_vars = parser2.vars;
					}
					else
					{
						fn_args =
						[
							new OpDeclareFunctionArg
							{
								"name": "layout",
								"caret_start": caret_start,
								"caret_end": parser.caret,
							},
							new OpDeclareFunctionArg
							{
								"name": "model_path",
								"caret_start": caret_start,
								"caret_end": parser.caret,
							},
							new OpDeclareFunctionArg
							{
								"name": "params",
								"caret_start": caret_start,
								"caret_end": parser.caret,
							},
							new OpDeclareFunctionArg
							{
								"name": "content",
								"caret_start": caret_start,
								"caret_end": parser.caret,
							},
						];
						
						/* Register variable in parser */
						parser2_vars = parser2_vars
							.setIm("layout", true)
							.setIm("model_path", true)
							.setIm("params", true)
							.setIm("content", true)
						;
					}
					
					/* Read template content */
					Dict<bool> save_vars = parser.vars;
					parser <= vars <= parser.vars.concat(parser2_vars);
					list res = static::readHTML(parser, "</template"); parser = res[0];
					BaseOpCode expression = res[1];
					parser <= vars <= save_vars;
					
					/* Read template footer */
					list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, "template"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
					
					OpDeclareFunction f = new OpDeclareFunction
					{
						"args": fn_args,
						"vars": [],
						"flags": new OpFlags
						{
							"p_static": true,
							"p_pure": true,
						},
						"name": fn_name,
						"result_type": "html",
						"expression": expression,
						"items": null,
						"caret_start": caret_start,
						"caret_end": parser.caret,
					};
					
					items.push(f);
				}
				else if (item_name == "style")
				{
					/* Save vars */
					Dict<bool> save_vars = parser.vars;
					parser <= vars <= parser.vars.setIm("vars", true);
					parser <= is_local_css <= true;
					
					/* Check if local css */
					string is_global = item_attrs.get("global", "");
					if (is_global == "true")
					{
						parser <= is_local_css <= false;
					}
					
					/* Read css */
					list res = static::readCssBody(parser);
					parser = res[0]; BaseOpCode css_op_code = res[1];
					
					/* Restore vars */
					parser <= vars <= save_vars;
					
					/* Read style footer */
					list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, "style"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
					
					int find_pos = -1;
					for (int items_i=0; items_i<items.count(); items_i++)
					{
						OpDeclareFunction f = items[items_i];
						if (f instanceof OpDeclareFunction)
						{
							if (f.name == "css")
							{
								find_pos = items_i;
								break;
							}
						}
					}
					
					if (find_pos == -1)
					{
						OpDeclareFunction f = new OpDeclareFunction
						{
							"args":
							[
								new OpDeclareFunctionArg
								{
									"name": "vars",
									"caret_start": caret_start,
									"caret_end": parser.caret,
								},
							],
							"vars": [],
							"flags": new OpFlags
							{
								"p_static": true,
								"p_pure": true,
							},
							"name": "css",
							"result_type": "html",
							"expression": css_op_code,
							"items": null,
							"caret_start": caret_start,
							"caret_end": parser.caret,
						};
						
						items.push(f);
					}
					else
					{
						OpDeclareFunction f = items[find_pos];
						
						f <= expression <= new OpMath
						{
							"caret_start": caret_start,
							"caret_end": parser.caret,
							"math": "~",
							"value1": f.expression,
							"value2": css_op_code,
						};
						
						items.set(find_pos, f);
					}
				}
				else if (item_name == "script")
				{
					list res = parser.parser_program::readClassBody(parser, "</");
					parser = res[0]; Collection<BaseOpCode> arr = res[1];
					items.appendVector(arr);
					
					/* Read script footer */
					list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, "script"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
				}
				
				else if (item_name == "meta")
				{
					list res = parser.parser_base::readDict(parser);
					parser = res[0]; BaseOpCode arr = res[1];
					/*
					OpDeclareFunction f = new OpDeclareFunction
					{
						"args":
						[
						],
						"vars": [],
						"flags": new OpFlags
						{
							"p_static": true,
							"p_pure": true,
						},
						"name": "meta",
						"result_type": "Collection",
						"expression": arr,
						"items": null,
						"caret_start": caret_start,
						"caret_end": parser.caret,
					};
					
					items.push(f);
					*/
					/* Read meta footer */
					list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, "meta"); parser = res[0];
					list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
				}
				
				else
				{
					throw new ParserError
					(
						"Unknown identifier '" ~ item_name ~ "'",
						item_token.caret_start, parser.file_name
					);
				}
			}
			
			else if (token.content == "/")
			{
				list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
			}
			else
			{
				throw new ParserError
				(
					"Unknown identifier '" ~ token.content ~ "'",
					token.caret_start, parser.file_name
				);
			}
			
			caret = parser.parser_base::skipChar(parser, content, parser.caret);
			ch2 = rs::substr(content.ref, caret.pos, 2);
		}
		
		/* Add components function */
		if (components.count() > 0)
		{
			OpDeclareFunction f = new OpDeclareFunction
			{
				"args": [],
				"vars": [],
				"flags": new OpFlags
				{
					"p_static": true,
					"p_pure": true,
				},
				"name": "components",
				"result_type": "var",
				"expression": new OpCollection
				{
					"caret_start": parser.caret,
					"caret_end": parser.caret,
					"values":
						components
							.toCollection()
							.map
							(
								OpString (string class_name) use (parser) =>
									new OpString
									{
										"caret_start": parser.caret,
										"caret_end": parser.caret,
										"value": class_name,
									}
							)
					,
				},
				"items": null,
				"caret_start": parser.caret,
				"caret_end": parser.caret,
			};
			
			items.push(f);
		}
		
		/* Read class footer */
		list res = parser.parser_base::matchToken(parser, "<"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "/"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, "class"); parser = res[0];
		list res = parser.parser_base::matchToken(parser, ">"); parser = res[0];
		
		/* Analyze class body */
		Dict class_body = parser.parser_program::classBodyAnalyze(parser, items);
		
		return
		[
			parser,
			[
				new OpNamespace
				{
					"name": namespace_name,
				},
				new OpDeclareClass
				{
					"kind": OpDeclareClass::KIND_CLASS,
					"name": class_name_last,
					"is_static": true,
					"is_declare": false,
					"class_extends": class_extend_op_code,
					"class_implements": null,
					"annotations": [],
					"template": null,
					"vars": class_body.item("vars"),
					"annotations": class_annotations.toCollection(),
					"functions": class_body.item("functions"),
					"fn_create": class_body.item("fn_create"),
					"fn_destroy": class_body.item("fn_destroy"),
					"items": class_body.item("items"),
					"caret_start": class_caret_start,
					"caret_end": parser.caret,
				}
			]
		];
	}
	
	
	
	/**
	 * Read UI
	 */
	pure list<ParserBay, BaseOpCode> readUI(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		Vector<BaseOpCode> items = new Vector();
		
		parser <= skip_comments <= false;
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		parser <= skip_comments <= true;
		
		while (token.content == "<")
		{
			ParserBay parser_start = parser;
			parser = look;
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			
			if (token.content == "class")
			{
				list res = static::readUIClass(parser_start);
				parser = res[0];
				items.appendVector( res[1] );
			}
			else if (token.content == "!--")
			{
				list res = static::readHTMLComment(parser_start);
				parser = res[0];
				items.push( res[1] );
			}
			
			parser <= skip_comments <= false;
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			parser <= skip_comments <= true;
		}
		
		
		return
		[
			parser,
			new OpModule
			{
				"uses": parser.uses.toDict(),
				"items": items.toCollection(),
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
}
