/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2025 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang.LangBay;

use Runtime.BaseObject;
use BayLang.Caret;
use BayLang.CoreParser;
use BayLang.CoreToken;
use BayLang.TokenReader;
use BayLang.LangBay.ParserBay;
use BayLang.OpCodes.BaseOpCode;
use BayLang.OpCodes.OpPreprocessorIfCode;
use BayLang.OpCodes.OpPreprocessorIfDef;
use BayLang.OpCodes.OpPreprocessorSwitch;


class ParserBayPreprocessor extends BaseObject
{
	ParserBay parser = null;
	
	
	/**
	 * Constructor
	 */
	void constructor(ParserBay parser)
	{
		parent();
		this.parser = parser;
	}
	
	
	/**
	 * Read preprocessor switch
	 */
	OpPreprocessorSwitch readSwitch(TokenReader reader)
	{
		Caret caret_start = reader.start();
		Collection items = [];
		
		reader.matchToken("#switch");
		while (not reader.eof() and reader.nextToken() != "#endswitch")
		{
			reader.matchToken("#case");
			OpPreprocessorIfCode op_code_item = this.readIfCode(reader);
			items.push(op_code_item);
		}
		reader.matchToken("#endswitch");
		
		return new OpPreprocessorSwitch
		{
			"items": items,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read preprocessor ifcode
	 */
	OpPreprocessorIfCode readIfCode(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		bool is_switch = false;
		if (reader.nextToken() == "#ifcode") reader.matchToken("#ifcode");
		else
		{
			is_switch = true;
			reader.matchToken("ifcode");
		}
		
		BaseOpCode expression = this.parser.parser_expression.readExpression(reader);
		reader.matchToken("then");
		
		/* Read content */
		Collection<char> content = [];
		Caret caret = reader.caret();
		while (not caret.eof() and not (
			caret.isNextString("#endif") or caret.isNextString("#case") or
			caret.isNextString("#endswitch")
		))
		{
			content.push(caret.readChar());
		}
		
		reader.init(caret);
		if (reader.nextToken() == "#endif" and not is_switch) reader.matchToken("#endif");
		
		return new OpPreprocessorIfCode
		{
			"condition": expression,
			"content": rs::trim(rs::join("", content)),
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read preprocessor ifdef
	 */
	OpPreprocessorIfDef readIfDef(TokenReader reader, string current_block)
	{
		Caret caret_start = reader.start();
		
		reader.matchToken("#ifdef");
		
		/* Read expression */
		BaseOpCode expression = this.parser.parser_expression.readExpression(reader);
		reader.matchToken("then");
		
		/* Read content */
		BaseOpCode content = null;
		if (current_block == OpPreprocessorIfDef::KIND_PROGRAM)
		{
			content = this.parser.parser_program.parse(reader);
		}
		else if (current_block == OpPreprocessorIfDef::KIND_CLASS_BODY)
		{
			content = this.parser.parser_class.readBody(reader, false);
		}
		else if (current_block == OpPreprocessorIfDef::KIND_OPERATOR)
		{
			content = this.parser.parser_operator.parse(reader, false);
		}
		else if (current_block == OpPreprocessorIfDef::KIND_EXPRESSION)
		{
			content = this.parser.parser_expression.readExpression(reader);
		}
		else
		{
			throw reader.error("Unknown block '" ~ current_block ~ "'");
		}
		
		reader.matchToken("#endif");
		
		return new OpPreprocessorIfDef
		{
			"condition": expression,
			"content": content,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read namespace
	 */
	BaseOpCode readPreprocessor(TokenReader reader)
	{
		if (reader.nextToken() == "#switch")
		{
			return this.readSwitch(reader);
		}
		
		else if (reader.nextToken() == "#ifcode")
		{
			return this.readIfCode(reader);
		}
		
		else if (reader.nextToken() == "#ifdef")
		{
			return this.readIfDef(reader);
		}
		
		return null;
	}
}