/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2025 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang.LangBay;

use Runtime.BaseObject;
use BayLang.Caret;
use BayLang.CoreParser;
use BayLang.TokenReader;
use BayLang.LangBay.ParserBay;
use BayLang.OpCodes.BaseOpCode;
use BayLang.OpCodes.OpItems;
use BayLang.OpCodes.OpPreprocessorIfCode;
use BayLang.OpCodes.OpPreprocessorIfDef;
use BayLang.OpCodes.OpPreprocessorSwitch;


class ParserBayPreprocessor extends BaseObject
{
	ParserBay parser = null;
	
	
	/**
	 * Constructor
	 */
	void constructor(ParserBay parser)
	{
		parent();
		this.parser = parser;
	}
	
	
	/**
	 * Read preprocessor switch
	 */
	OpPreprocessorSwitch readSwitch(TokenReader reader, string current_block = "")
	{
		Caret caret_start = reader.start();
		Collection items = [];
		
		reader.matchToken("#switch");
		while (not reader.eof() and reader.nextToken() != "#endswitch")
		{
			reader.matchToken("#case");
			BaseOpCode op_code_item = null;
			if (reader.nextToken() == "ifdef")
			{
				op_code_item = this.readIfDef(reader, current_block);
			}
			else
			{
				op_code_item = this.readIfCode(reader);
			}
			items.push(op_code_item);
		}
		reader.matchToken("#endswitch");
		
		return new OpPreprocessorSwitch
		{
			"items": items,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read preprocessor ifcode
	 */
	OpPreprocessorIfCode readIfCode(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		bool is_switch = false;
		if (reader.nextToken() == "#ifcode") reader.matchToken("#ifcode");
		else
		{
			is_switch = true;
			reader.matchToken("ifcode");
		}
		
		bool save_find_variable = this.parser.find_variable;
		this.parser.find_variable = false;
		BaseOpCode expression = this.parser.parser_expression.readExpression(reader);
		this.parser.find_variable = save_find_variable;
		reader.matchToken("then");
		
		/* Read content */
		Collection<char> content = [];
		Caret caret = reader.caret();
		while (not caret.eof() and not (
			caret.isNextString("#endif") or caret.isNextString("#case") or
			caret.isNextString("#endswitch")
		))
		{
			content.push(caret.readChar());
		}
		
		reader.init(caret);
		if (not is_switch) reader.matchToken("#endif");
		
		return new OpPreprocessorIfCode
		{
			"condition": expression,
			"content": rs::trim(rs::join("", content)),
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read preprocessor ifdef
	 */
	OpPreprocessorIfDef readIfDef(TokenReader reader, string current_block)
	{
		Caret caret_start = reader.start();
		
		bool is_switch = false;
		if (reader.nextToken() == "#ifdef") reader.matchToken("#ifdef");
		else
		{
			is_switch = true;
			reader.matchToken("ifdef");
		}
		
		/* Read expression */
		bool save_find_variable = this.parser.find_variable;
		this.parser.find_variable = false;
		BaseOpCode expression = this.parser.parser_expression.readExpression(reader);
		this.parser.find_variable = save_find_variable;
		reader.matchToken("then");
		
		/* Read content */
		BaseOpCode content = null;
		if (current_block == OpPreprocessorIfDef::KIND_PROGRAM)
		{
			content = this.parser.parser_program.parse(reader);
		}
		else if (current_block == OpPreprocessorIfDef::KIND_CLASS_BODY)
		{
			content = this.parser.parser_class.readBody(reader, false);
		}
		else if (current_block == OpPreprocessorIfDef::KIND_OPERATOR)
		{
			content = this.parser.parser_operator.parse(reader, false);
		}
		else if (current_block == OpPreprocessorIfDef::KIND_COLLECTION)
		{
			Collection items = [];
			while (not reader.eof() and reader.nextToken() != "#endif")
			{
				BaseOpCode op_code_item = this.parser.parser_expression.readExpression(reader);
				items.push(op_code_item);
				if (reader.nextToken() == "," or reader.nextToken() != "#endif")
				{
					reader.matchToken(",");
				}
			}
			content = new OpItems
			{
				"items": items,
				"caret_start": caret_start,
				"caret_end": reader.caret(),
			};
		}
		else if (current_block == OpPreprocessorIfDef::KIND_EXPRESSION)
		{
			content = this.parser.parser_expression.readExpression(reader);
			if (reader.nextToken() == ",") reader.matchToken(",");
		}
		else
		{
			throw reader.error("Unknown block '" ~ current_block ~ "'");
		}
		
		if (not is_switch) reader.matchToken("#endif");
		
		return new OpPreprocessorIfDef
		{
			"condition": expression,
			"content": content,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read namespace
	 */
	BaseOpCode readPreprocessor(TokenReader reader, string current_block = "")
	{
		if (reader.nextToken() == "#switch")
		{
			return this.readSwitch(reader, current_block);
		}
		else if (reader.nextToken() == "#ifcode")
		{
			return this.readIfCode(reader);
		}
		else if (reader.nextToken() == "#ifdef")
		{
			return this.readIfDef(reader, current_block);
		}
		
		return null;
	}
}