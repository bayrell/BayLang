/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang.LangBay;

use Runtime.Reference;
use BayLang.Caret;
use BayLang.CoreToken;
use BayLang.Exceptions.ParserEOF;
use BayLang.Exceptions.ParserError;
use BayLang.Exceptions.ParserExpected;
use BayLang.LangBay.ParserBay;
use BayLang.OpCodes.BaseOpCode;
use BayLang.OpCodes.OpAttr;
use BayLang.OpCodes.OpCall;
use BayLang.OpCodes.OpComment;
use BayLang.OpCodes.OpClassOf;
use BayLang.OpCodes.OpClassRef;
use BayLang.OpCodes.OpCollection;
use BayLang.OpCodes.OpCurry;
use BayLang.OpCodes.OpCurryArg;
use BayLang.OpCodes.OpDeclareFunction;
use BayLang.OpCodes.OpDeclareFunctionArg;
use BayLang.OpCodes.OpDict;
use BayLang.OpCodes.OpDictPair;
use BayLang.OpCodes.OpEntityName;
use BayLang.OpCodes.OpIdentifier;
use BayLang.OpCodes.OpMethod;
use BayLang.OpCodes.OpNew;
use BayLang.OpCodes.OpNumber;
use BayLang.OpCodes.OpNegative;
use BayLang.OpCodes.OpPreprocessorIfDef;
use BayLang.OpCodes.OpString;
use BayLang.OpCodes.OpTypeConvert;
use BayLang.OpCodes.OpTypeIdentifier;


class ParserBayBase
{
	
	/**
	 * Return true if is char
	 * @param char ch
	 * @return boolean
	 */
	pure memorize bool isChar (char ch) =>
		rs::indexOf('qazwsxedcrfvtgbyhnujmikolp', rs::lower(ch)) !== -1
	;
	
	
	
	/**
	 * Return true if is number
	 * @param char ch
	 * @return boolean
	 */
	pure memorize bool isNumber (char ch) =>
		rs::indexOf('0123456789', ch) !== -1
	;
	
	
	
	/**
	 * Return true if char is number
	 * @param char ch
	 * @return boolean
	 */
	pure memorize bool isHexChar (char ch) =>
		rs::indexOf('0123456789abcdef', rs::lower(ch)) !== -1;
	
	
	
	/**
	 * Return true if is string of numbers
	 * @param string s
	 * @return boolean
	 */
	pure memorize bool isStringOfNumbers (string s)
	{
		int sz = rs::strlen(s);
		for (int i=0; i<sz; i++)
		{
			if (not static::isNumber( rs::charAt(s, i) )) return false;
		}
		return true;
	}
	
	
	
	/**
	 * Is system type
	 */
	pure memorize bool isSystemType (string name)
	{
		if (name == "var") return true;
		if (name == "void") return true;
		if (name == "bool") return true;
		if (name == "byte") return true;
		if (name == "int") return true;
		if (name == "double") return true;
		if (name == "float") return true;
		if (name == "char") return true;
		if (name == "string") return true;
		if (name == "list") return true;
		if (name == "scalar") return true;
		if (name == "primitive") return true;
		if (name == "html") return true;
		if (name == "Error") return true;
		if (name == "Object") return true;
		if (name == "DateTime") return true;
		if (name == "Collection") return true;
		if (name == "Dict") return true;
		if (name == "Vector") return true;
		if (name == "Map") return true;
		if (name == "rs") return true;
		if (name == "rtl") return true;
		if (name == "ArrayInterface") return true;
		return false;
	}
	
	
	
	/**
	 * Returns true if name is identifier
	 */
	pure memorize bool isIdentifier(string name)
	{
		if (name == "") return false;
		if (name == "@") return true;
		if (static::isNumber( rs::charAt(name, 0) )) return false;
		int sz = rs::strlen(name);
		for (int i=0; i<sz; i++)
		{
			string ch = rs::charAt(name, i);
			if (static::isChar(ch) or static::isNumber(ch) or ch == "_") continue;
			return false;
		}
		return true;
	}
	
	
	
	/**
	 * Returns true if reserved words
	 */
	pure memorize bool isReserved(string name)
	{
		if (name == "__async_t") return true;
		if (name == "__async_var") return true;
		/*if (name == "__ctx") return true;*/
		/*if (name == "ctx") return true;*/
		if (rs::substr(name, 0, 3) == "__v") return true;
		return false;
	}
	
	
	
	/**
	 * Returns kind of identifier or thrown Error
	 */
	pure string findIdentifier(ParserBay parser, string name, Caret caret)
	{
		string kind = "";
		if (parser.vars.has(name))
		{
			kind = OpIdentifier::KIND_VARIABLE;
		}
		else if (parser.uses.has(name))
		{
			kind = OpIdentifier::KIND_CLASS;
		}
		else if (static::isSystemType(name))
		{
			kind = OpIdentifier::KIND_SYS_TYPE;
		}
		else if (name == "log")
		{
			kind = OpIdentifier::KIND_SYS_FUNCTION;
		}
		else if (name == "window" or name == "document")
		{
			kind = OpIdentifier::KIND_VARIABLE;
		}
		else if (name == "null" or name == "true" or name == "false")
		{
			kind = OpIdentifier::KIND_CONSTANT;
		}
		else if (name == "fn")
		{
			kind = OpIdentifier::KIND_FUNCTION;
		}
		else if (name == "@" or name == "_")
		{
			kind = OpIdentifier::KIND_CONTEXT;
		}
		else if (name == "static" or name == "self" or name == "this" or name == "parent")
		{
			kind = OpIdentifier::KIND_CLASSREF;
		}
		return kind;
	}
	
	
	
	/**
	 * Return true if char is token char
	 * @param {char} ch
	 * @return {boolean}
	 */
	pure memorize bool isTokenChar(char ch)
	{
		return rs::indexOf('qazwsxedcrfvtgbyhnujmikolp0123456789_', rs::lower(ch)) !== -1;
	}
	
	
	
	/**
	 * Return true if char is system or space. ASCII code <= 32.
	 * @param char ch
	 * @return boolean
	 */
	pure memorize bool isSkipChar (char ch)
	{
		if (rs::ord(ch) <= 32) return true;
		return false;
	}
	
	
	
	/**
	 * Returns next X
	 */
	pure int nextX(ParserBay parser, char ch, int x, int direction = 1)
	{
		if (ch == "\t") return x + parser.tab_size * direction;
		if (ch == "\n") return 0;
		return x + direction;
	}
	
	
	
	/**
	 * Returns next Y
	 */
	pure int nextY(ParserBay parser, char ch, int y, int direction = 1)
	{
		if (ch == "\n") return y + direction;
		return y;
	}
	
	
	/**
	 * Returns next
	 */
	pure list<int, int, int> next(ParserBay parser, string s, int x, int y, int pos)
	{
		int sz = rs::strlen(s);
		for (int i=0; i<sz; i++)
		{
			string ch = rs::substr(s, i, 1);
			x = static::nextX(parser, ch, x);
			y = static::nextY(parser, ch, y);
			pos = pos + 1;
		}
		return [x, y, pos];
	}
	
	
	
	/**
	 * Open comment
	 */
	pure bool isCommentOpen(ParserBay parser, string str) =>
		parser.skip_comments and
			( parser.is_html ? str == "<!--" : str == "/*" )
		;
	
	
	
	/**
	 * Close comment
	 */
	pure bool isCommentClose(ParserBay parser, string str) =>
		parser.is_html ? str == "-->" : str == "*/"
	;
	
	
	
	/**
	 * Skip char
	 */
	pure Caret skipChar(ParserBay parser, Reference<string> content, Caret start_pos)
	{
		int x = start_pos.x;
		int y = start_pos.y;
		int pos = start_pos.pos;
		bool skip_comments = parser.skip_comments;
		
		/* Check boundaries */
		if (pos >= parser.content_sz)
		{
			throw new ParserEOF();
		}
		
		string ch = rs::charAt(content.ref, pos);
		string ch2 = rs::substr(content.ref, pos, 2);
		string ch4 = rs::substr(content.ref, pos, 4);
		while
		(
			(
				static::isSkipChar(ch) or
				static::isCommentOpen(parser, ch2) or
				static::isCommentOpen(parser, ch4)
			) and pos < parser.content_sz
		)
		{
			if (static::isCommentOpen(parser, ch2))
			{
				ch2 = rs::substr(content.ref, pos, 2);
				while (not static::isCommentClose(parser, ch2) and pos < parser.content_sz)
				{
					x = static::nextX(parser, ch, x);
					y = static::nextY(parser, ch, y);
					pos = pos + 1;
					if (pos >= parser.content_sz)
					{
						break;
					}
					ch = rs::charAt(content.ref, pos);
					ch2 = rs::substr(content.ref, pos, 2);
				}
				if (static::isCommentClose(parser, ch2))
				{
					x = x + 2;
					pos = pos + 2;
				}
			}
			
			else if (static::isCommentOpen(parser, ch4))
			{
				string ch3 = rs::substr(content.ref, pos, 3);
				while (not static::isCommentClose(parser, ch3) and pos < parser.content_sz)
				{
					x = static::nextX(parser, ch, x);
					y = static::nextY(parser, ch, y);
					pos = pos + 1;
					if (pos >= parser.content_sz)
					{
						break;
					}
					ch = rs::charAt(content.ref, pos);
					ch3 = rs::substr(content.ref, pos, 3);
				}
				if (static::isCommentClose(parser, ch3))
				{
					x = x + 3;
					pos = pos + 3;
				}
			}
			
			else
			{
				x = static::nextX(parser, ch, x);
				y = static::nextY(parser, ch, y);
				pos = pos + 1;
			}
			if (pos >= parser.content_sz)
			{
				break;
			}
			ch = rs::charAt(content.ref, pos);
			ch2 = rs::substr(content.ref, pos, 2);
			ch4 = rs::substr(content.ref, pos, 4);
		}
		return new Caret{ "pos": pos, "x": x, "y": y };
	}
	
	
	
	/**
	 * Read special token
	 */
	pure string readSpecialToken(ParserBay parser, Reference<string> content, Caret start_pos)
	{
		int pos = start_pos.pos;
		string s = "";
		
		s = rs::substr(content.ref, pos, 10);
		if (s == "#endswitch") return s;
		
		s = rs::substr(content.ref, pos, 7);
		if (s == "#ifcode" or s == "#switch" or s == "#elseif" or s == "%render") return s;
		
		s = rs::substr(content.ref, pos, 6);
		if (s == "#endif" or s == "#ifdef" or s == "%while") return s;
		
		s = rs::substr(content.ref, pos, 5);
		if (s == "#case" or s == "%else") return s;
		
		s = rs::substr(content.ref, pos, 4);
		if (s == "@css" or s == "%for" or s == "%var" or s == "%set") return s;
		
		s = rs::substr(content.ref, pos, 3);
		if (
			s == "!--" or
			s == "!==" or
			s == "===" or
			s == "..." or
			s == "#if" or
			s == "%if"
		)
			return s;
		
		s = rs::substr(content.ref, pos, 2);
		if (
			s == "==" or
			s == "!=" or
			s == "<=" or
			s == ">=" or
			s == "=>" or
			s == "->" or
			s == "|>" or
			s == "::" or
			s == "+=" or
			s == "-=" or
			s == "~=" or
			s == "**" or
			s == "<<" or
			s == ">>" or
			s == "++" or
			s == "--"
		)
			return s;
			
		return "";
		
	}
	
	
	
	/**
	 * Read next token and return caret end
	 */
	pure Caret nextToken(ParserBay parser, Reference<string> content, Caret start_pos)
	{
		bool is_first = true;
		int x = start_pos.x;
		int y = start_pos.y;
		int pos = start_pos.pos;
		
		/* Check boundaries */
		if (pos >= parser.content_sz)
		{
			throw new ParserEOF();
		}
		
		string s = static::readSpecialToken(parser, content, start_pos);
		if (s != "")
		{
			int sz = rs::strlen(s);
			for (int i=0; i<sz; i++)
			{
				char ch = rs::charAt(s, i);
				x = static::nextX(parser, ch, x);
				y = static::nextY(parser, ch, y);
				pos = pos + 1;
			}
			return new Caret{ "pos": pos, "x": x, "y": y };
		}
		
		char ch = rs::charAt(content.ref, pos);
		if ( not static::isTokenChar(ch) )
		{
			x = static::nextX(parser, ch, x);
			y = static::nextY(parser, ch, y);
			pos = pos + 1;
		}
		else
		{
			while (static::isTokenChar(ch))
			{
				x = static::nextX(parser, ch, x);
				y = static::nextY(parser, ch, y);
				pos = pos + 1;
				if (pos >= parser.content_sz)
				{
					break;
				}
				ch = rs::charAt(content.ref, pos);
			}
		}
		return new Caret{ "pos": pos, "x": x, "y": y };
	}
	
	
	
	/**
	 * Read back
	 */
	pure ParserBay readBack(ParserBay parser, string search = "")
	{
		Reference<string> content = parser.content;
		Caret caret = parser.caret;
		int x = caret.x;
		int y = caret.y;
		int pos = caret.pos;
		int search_sz = rs::strlen(search);
		string s = "";
		
		while (pos >= 0)
		{
			char ch = rs::charAt(content.ref, pos);
			x = static::nextX(parser, ch, x, -1);
			y = static::nextY(parser, ch, y, -1);
			pos--;
			
			s = rs::substr(content.ref, pos, search_sz);
			if (s == search)
			{
				break;
			}
		}
		
		return parser.copy{ "caret": new Caret{ "pos": pos, "x": x, "y": y } };
	}
	
	
	
	/**
	 * Read next token
	 */
	pure list<ParserBay, CoreToken> readToken(ParserBay parser)
	{
		Caret caret_start = null;
		Caret caret_end = null;
		bool eof = false;
		
		try
		{
			caret_start = static::skipChar(parser, parser.content, parser.caret);
			caret_end = static::nextToken(parser, parser.content, caret_start);
		}
		catch (ParserEOF e)
		{
			if (caret_start == null) caret_start = parser.caret;
			if (caret_end == null) caret_end = caret_start;
			eof = true;
		}
		catch (var e)
		{
			throw e;
		}
		
		return 
		[
			parser.copy({ "caret": caret_end }),
			new CoreToken
			{
				"content": rs::substr(parser.content.ref, caret_start.pos, caret_end.pos - caret_start.pos),
				"caret_start": caret_start,
				"caret_end": caret_end,
				"eof": eof,
			}
		];
	}
	
	
	
	/**
	 * Look next token
	 */
	pure list<ParserBay, bool> lookToken(ParserBay parser, string token)
	{
		string token_content = "";
		Reference<string> content = parser.content;
		Caret caret_start = null;
		Caret caret_end = null;
		int sz = rs::strlen(token);
		bool eof = false;
		bool find = false;
		
		try
		{
			caret_start = static::skipChar(parser, content, parser.caret);
			int pos = caret_start.pos;
			int x = caret_start.x;
			int y = caret_start.y;
			token_content = rs::substr(content.ref, pos, sz);
			if (token_content == token) find = true;
			list res = static::next(parser, token_content, x, y, pos);
			x = res[0]; y = res[1]; pos = res[2];
			caret_end = new Caret{ "pos": pos, "x": x, "y": y }
		}
		catch (ParserEOF e)
		{
			if (caret_start == null) caret_start = parser.caret;
			if (caret_end == null) caret_end = caret_start;
			eof = true;
		}
		catch (var e)
		{
			throw e;
		}
		
		return 
		[
			parser.copy({ "caret": caret_end }),
			new CoreToken
			{
				"content": token_content,
				"caret_start": caret_start,
				"caret_end": caret_end,
				"eof": eof,
			},
			find
		];
	}
	
	
	
	/**
	 * Match next token
	 */
	pure list<ParserBay, CoreToken> matchToken(ParserBay parser, string next_token)
	{
		CoreToken token = null;
		
		/* Look token */
		list res = static::lookToken(parser, next_token);
		parser = res[0]; token = res[1]; bool find = res[2];
		if (not find)
		{
			throw new ParserExpected(next_token, token.caret_start, parser.file_name);
		}
		
		return [parser, token];
	}
	
	
	
	/**
	 * Match next string
	 */
	pure list<ParserBay, CoreToken> matchString(ParserBay parser, string str1)
	{
		Caret caret = parser.caret;
		int sz = rs::strlen(str1);
		string str2 = rs::substr(parser.content.ref, caret.pos, sz);
		
		if (str1 != str2)
		{
			throw new ParserExpected(str1, caret, parser.file_name);
		}
		
		list res = static::next(parser, str1, caret.x, caret.y, caret.pos);
		caret = new Caret{ "x": res[0], "y": res[1], "pos": res[2] };
		
		parser <= caret <= caret;
		
		return [parser, null];
	}
	
	
	
	/**
	 * Read number
	 */
	pure list<ParserBay, OpNumber> readNumber(ParserBay parser, bool flag_negative = false)
	{
		CoreToken token = null;
		ParserBay start = parser;
		
		/* Read token */
		list res = static::readToken(parser); parser = res[0]; token = res[1];
		
		Caret caret_start = token.caret_start;
		if (token.content == "")
		{
			throw new ParserExpected("Number", caret_start, parser.file_name);
		}
		if (not static::isStringOfNumbers(token.content))
		{
			throw new ParserExpected("Number", caret_start, parser.file_name);
		}
		
		string value = token.content;
		
		/* Look dot */
		list res = static::readToken(parser);
		ParserBay look = res[0]; token = res[1];
		
		if (token.content == ".")
		{
			value ~= ".";
			list res = static::readToken(look);
			parser = res[0];
			token = res[1];
			value ~= token.content;
		}
		
		return
		[
			parser,
			new OpNumber
			{
				"value": value,
				"caret_start": caret_start,
				"caret_end": parser.caret,
				"negative": flag_negative,
			}
		];
	}
	
	
	
	/**
	 * Read string
	 */
	pure list<ParserBay, OpString> readUntilStringArr
	(
		ParserBay parser, Collection arr, bool flag_include = true
	)
	{
		CoreToken token = null;
		ParserBay look = null;
		Reference<string> content = parser.content;
		int content_sz = parser.content_sz;
		int pos = parser.caret.pos;
		int x = parser.caret.x;
		int y = parser.caret.y;
		
		/* Search next string in arr */
		fn<int, int> search = int (int pos) use (content, arr)
		{
			for (int i=0; i<arr.count(); i++)
			{
				string item = arr.item(i);
				int sz = rs::strlen(item);
				string str = rs::substr(content.ref, pos, sz);
				if (str == item)
				{
					return i;
				}
			}
			return -1;
		};
		
		/* Start and end positionss */
		int start_pos = pos;
		int end_pos = pos;
		
		/* Read string value */
		string ch = "";
		int arr_pos = search(pos);
		while ( pos < content_sz and arr_pos == -1 )
		{
			ch = rs::charAt(content.ref, pos);
			x = static::nextX(parser, ch, x);
			y = static::nextY(parser, ch, y);
			pos = pos + 1;
			
			if (pos >= content_sz)
			{
				throw new ParserExpected
				(
					rs::join(",", arr),
					new Caret{ "x": x, "y": y, "pos": pos },
					parser.file_name
				);
			}
			
			arr_pos = search(pos);
		}
		
		if (arr_pos == -1)
		{
			throw new ParserExpected
			(
				"End of string",
				new Caret{ "x": x, "y": y, "pos": pos },
				parser.file_name
			);
		}
		
		if (not flag_include) end_pos = pos;
		else
		{
			string item = arr.item(arr_pos);
			int sz = rs::strlen(item);
			for (int i=0; i<sz; i++)
			{
				ch = rs::charAt(content.ref, pos);
				x = static::nextX(parser, ch, x);
				y = static::nextY(parser, ch, y);
				pos = pos + 1;
			}
			end_pos = pos;
		}
		
		/* Return result */
		Caret caret_end = new Caret{ "x": x, "y": y, "pos": end_pos };
		return 
		[
			parser.copy({ "caret": caret_end }),
			rs::substr(content.ref, start_pos, end_pos - start_pos),
		];
	}
	
	
	
	/**
	 * Read string
	 */
	pure list<ParserBay, OpString> readString(ParserBay parser)
	{
		CoreToken token = null;
		ParserBay look = null;
		
		/* Read token */
		list res = static::readToken(parser); look = res[0]; token = res[1];
		
		Caret caret_start = token.caret_start;
		string str_char = token.content;
		
		/* Read begin string char */
		if (str_char != "'" and str_char != '"') /* " */
		{
			throw new ParserExpected("String", caret_start, parser.file_name);
		}
		string content = look.content;
		int content_sz = look.content_sz;
		int pos = look.caret.pos;
		int x = look.caret.x;
		int y = look.caret.y;
		
		/* Read string value */
		string value_str = "";
		string ch = rs::charAt(content.ref, pos);
		while ( pos < content_sz and ch != str_char )
		{
			if (ch == "\\")
			{
				x = static::nextX(parser, ch, x);
				y = static::nextY(parser, ch, y);
				pos = pos + 1;
				if (pos >= content_sz)
				{
					throw new ParserExpected
					(
						"End of string",
						new Caret{ "x": x, "y": y, "pos": pos },
						parser.file_name
					);
				}
				
				string ch2 = rs::charAt(content.ref, pos);
				if (ch2 == "n") value_str ~= "\n";
				else if (ch2 == "r") value_str ~= "\r";
				else if (ch2 == "t") value_str ~= "\t";
				else if (ch2 == "s") value_str ~= " ";
				else if (ch2 == "\\") value_str ~= "\\";
				else if (ch2 == "'") value_str ~= "'";
				else if (ch2 == '"') value_str ~= '"';
				else value_str ~= ch ~ ch2;
				x = static::nextX(parser, ch2, x);
				y = static::nextY(parser, ch2, y);
				pos = pos + 1;
			}
			else
			{
				value_str ~= ch;
				x = static::nextX(parser, ch, x);
				y = static::nextY(parser, ch, y);
				pos = pos + 1;
			}
			
			if (pos >= content_sz)
			{
				throw new ParserExpected
				(
					"End of string",
					new Caret{ "x": x, "y": y, "pos": pos },
					parser.file_name
				);
			}
			ch = rs::charAt(content.ref, pos);
		}
		
		/* Read end string char */
		if (ch != "'" and ch != '"') /* " */
		{
			throw new ParserExpected
			(
				"End of string",
				new Caret{ "x": x, "y": y, "pos": pos },
				parser.file_name
			);
		}
		x = static::nextX(parser, ch, x);
		y = static::nextY(parser, ch, y);
		pos = pos + 1;
		
		/* Return result */
		Caret caret_end = new Caret{ "x": x, "y": y, "pos": pos };
		return 
		[
			parser.copy({ "caret": caret_end }),
			new OpString
			{
				"value": value_str,
				"caret_start": caret_start,
				"caret_end": caret_end,
			}
		];
	}
	
	
	
	/**
	 * Read comment
	 */
	pure list<ParserBay, OpComment> readComment(ParserBay parser)
	{
		ParserBay start = parser;
		CoreToken token = null;
		ParserBay look = null;
		
		parser <= skip_comments <= false;
		list res = ParserBayBase::readToken(parser); look = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		parser <= skip_comments <= true;
		
		if (token.content == "/") /* */
		{
			parser = look;
			string content = look.content;
			int content_sz = look.content_sz;
			int pos = look.caret.pos;
			int x = look.caret.x;
			int y = look.caret.y;
			int pos_start = pos;
			
			string ch = rs::charAt(content.ref, pos);
			string ch2 = rs::substr(content.ref, pos, 2);
			while (not static::isCommentClose(parser, ch2) and pos < content_sz)
			{
				x = static::nextX(parser, ch, x);
				y = static::nextY(parser, ch, y);
				pos = pos + 1;
				if (pos >= parser.content_sz)
				{
					break;
				}
				ch = rs::charAt(content.ref, pos);
				ch2 = rs::substr(content.ref, pos, 2);
			}
			
			int pos_end = pos;
			if (static::isCommentClose(parser, ch2))
			{
				x = x + 2;
				pos = pos + 2;
			}
			else
			{
				throw new ParserExpected
				(
					"End of comment",
					new Caret{ "x": x, "y": y, "pos": pos },
					start.file_name
				);
			}
			
			/* Return result */
			string value_str = rs::substr(content.ref, pos_start + 1, pos_end - pos_start - 1);
			Caret caret_end = new Caret{ "x": x, "y": y, "pos": pos };
			
			return
			[
				start.copy({ "caret": caret_end }),
				new OpComment
				{
					"value": value_str,
					"caret_start": caret_start,
					"caret_end": caret_end,
				}
			];
		}
		
		return [parser, null];
	}
	
	
	
	/**
	 * Read identifier
	 */
	pure list<ParserBay, OpIdentifier> readIdentifier(ParserBay parser, bool find_ident = false)
	{
		ParserBay start = parser;
		CoreToken token = null;
		ParserBay look = null;
		string name = "";
		
		list res = ParserBayBase::readToken(parser); parser = res[0]; token = res[1];
		if (token.content == "")
		{
			throw new ParserExpected("Identifier", token.caret_start, parser.file_name);
		}
		if (not static::isIdentifier(token.content))
		{
			throw new ParserExpected("Identifier", token.caret_start, parser.file_name);
		}
		if (static::isReserved(token.content))
		{
			throw new ParserExpected
			(
				"Identifier " ~ token.content ~ " is reserverd",
				token.caret_start, parser.file_name
			);
		}
		
		name = token.content;
		bool kind = static::findIdentifier(parser, name, token.caret_start);
		
		if (parser.find_ident and find_ident and kind == "")
		{
			throw new ParserError(
				"Unknown identifier '" ~ name ~ "'",
				token.caret_start, parser.file_name
			);
		}
		
		return 
		[
			parser,
			new OpIdentifier
			{
				"kind": kind,
				"value": name,
				"caret_start": token.caret_start,
				"caret_end": token.caret_end,
			}
		];
	}
	
	
	
	/**
	 * Read entity name
	 */
	pure list<ParserBay, OpEntityName> readEntityName(ParserBay parser, bool find_ident = true)
	{
		ParserBay look = null;
		CoreToken token = null;
		OpIdentifier ident = null;
		Vector<string> names = new Vector();
		
		list res = parser.parser_base::readIdentifier(parser, find_ident);
		parser = res[0]; ident = res[1];
		Caret caret_start = ident.caret_start;
		
		string name = ident.value;
		names.push(name);
		
		list res = parser.parser_base::readToken(parser);
		look = res[0]; token = res[1];
		
		while (not token.eof and token.content == ".")
		{
			list res = parser.parser_base::matchToken(parser, "."); parser = res[0];
			list res = parser.parser_base::readIdentifier(parser); 
			parser = res[0]; ident = res[1];
			
			name = ident.value;
			names.push(name);
			
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		}
		
		return 
		[
			parser,
			new OpEntityName
			{
				"caret_start": caret_start,
				"caret_end": parser.caret,
				"names": names,
			}
		];
	}
	
	
	
	/**
	 * Read type identifier
	 */
	pure list<ParserBay, BaseOpCode> readTypeIdentifier(ParserBay parser, bool find_ident = true)
	{
		ParserBay start = parser;
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		BaseOpCode entity_name = null;
		Vector<OpTypeIdentifier> template = null;
		
		list res = static::readEntityName(parser, find_ident);
		parser = res[0]; entity_name = res[1];
		Caret caret_start = entity_name.caret_start;
		
		bool flag_open_caret = false;
		bool flag_end_caret = false;
		list res = static::lookToken(parser, "<");
		look = res[0]; token = res[1]; flag_open_caret = res[2];
		if (flag_open_caret)
		{
			template = new Vector<OpTypeIdentifier>();
			list res = static::matchToken(parser, "<"); parser = res[0];
			list res = static::lookToken(parser, ">");
			look = res[0]; token = res[1]; flag_end_caret = res[2];
			
			while (not token.eof and not flag_end_caret)
			{
				BaseOpCode parser_value = null;
				list res = static::readTypeIdentifier(parser);
				parser = res[0]; parser_value = res[1];
				
				template.push(parser_value);
				
				list res = static::lookToken(parser, ">");
				look = res[0]; token = res[1]; flag_end_caret = res[2];
				if (not flag_end_caret)
				{
					list res = static::matchToken(parser, ","); parser = res[0];
					list res = static::lookToken(parser, ">");
					look = res[0]; token = res[1]; flag_end_caret = res[2];
				}
			}
			list res = static::matchToken(parser, ">"); parser = res[0];
		}
		
		return
		[
			parser,
			new OpTypeIdentifier
			{
				"entity_name": entity_name,
				"template": template,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	
	/**
	 * Read collection
	 */
	pure list<ParserBay, BaseOpCode> readCollection(ParserBay parser)
	{
		ParserBay start = parser;
		ParserBay look = null;
		CoreToken token = null;
		Vector<BaseOpCode> values = new Vector();
		BaseOpCode ifdef_condition = null;
		bool flag_ifdef = false;
		
		list res = static::matchToken(parser, "["); parser = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		while (not token.eof and token.content != "]")
		{
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			if (token.content == "#ifdef")
			{
				parser = look;
				parser <= find_ident <= false;
				list res = parser.parser_expression::readExpression(parser);
				parser = res[0]; ifdef_condition = res[1];
				parser <= find_ident <= true;
				list res = parser.parser_base::matchToken(parser, "then");
				parser = res[0]; token = res[1];
				flag_ifdef = true;
			}
			
			BaseOpCode parser_value = null;
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; parser_value = res[1];
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
			if (token.content == ",")
			{
				parser = look;
				list res = static::readToken(parser); look = res[0]; token = res[1];
			}
			
			if (flag_ifdef)
			{
				parser_value = new OpPreprocessorIfDef
				{
					"items": parser_value,
					"condition": ifdef_condition,
				}
			}
			values.push(parser_value);
			
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			if (token.content == "#endif")
			{
				parser = look;
				flag_ifdef = false;
				ifdef_condition = null;
			}
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
		}
		
		list res = static::matchToken(parser, "]"); parser = res[0]; token = res[1];
		return 
		[
			parser,
			new OpCollection
			{
				"values": values,
				"caret_start": caret_start,
				"caret_end": token.caret_end,
			}
		];
	}
	
	
	
	/**
	 * Read collection
	 */
	pure list<ParserBay, BaseOpCode> readDict(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		Vector<BaseOpCode> values = new Vector();
		BaseOpCode ifdef_condition = null;
		bool flag_ifdef = false;
		
		list res = static::matchToken(parser, "{"); parser = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		while (not token.eof and token.content != "}")
		{
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			if (token.content == "#ifdef")
			{
				parser = look;
				parser <= find_ident <= false;
				list res = parser.parser_expression::readExpression(parser);
				parser = res[0]; ifdef_condition = res[1];
				parser <= find_ident <= true;
				list res = parser.parser_base::matchToken(parser, "then"); parser = res[0]; token = res[1];
				flag_ifdef = true;
			}
			
			BaseOpCode parser_value = null;
			list res = static::readString(parser); parser = res[0]; parser_value = res[1];
			string key = parser_value.value;
			
			list res = static::matchToken(parser, ":"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; parser_value = res[1];
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
			if (token.content == ",")
			{
				parser = look;
			}
			
			values.push(
				new OpDictPair{
					"key": key,
					"value": parser_value,
					"condition": ifdef_condition
				}
			);
			
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			if (token.content == "#endif")
			{
				parser = look;
				flag_ifdef = false;
				ifdef_condition = null;
			}
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
		}
		
		list res = static::matchToken(parser, "}"); parser = res[0]; token = res[1];
		return 
		[
			parser,
			new OpDict
			{
				"values": values,
				"caret_start": caret_start,
				"caret_end": token.caret_end,
			}
		];
	}
	
	
	
	/**
	 * Read fixed
	 */
	pure list<ParserBay, BaseOpCode> readFixed(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		ParserBay start = parser;
		Caret caret_start = parser.caret;
		bool flag_negative = false;
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "")
		{
			throw new ParserExpected("Identifier", token.caret_start, look.file_name);
		}
		
		/* Read string */
		if (token.content == "'" or token.content == '"') /* " */
		{
			return static::readString(parser);
		}
		
		/* Read Collection */
		if (token.content == "[")
		{
			return static::readCollection(parser);
		}
		
		/* Read Dict */
		if (token.content == "{")
		{
			return static::readDict(parser);
		}
		
		/* Negative number */
		if (token.content == "-")
		{
			flag_negative = true;
			parser = look;
			list res = static::readToken(look); look = res[0]; token = res[1];
		}
		
		/* Read Number */
		if (static::isStringOfNumbers(token.content))
		{
			return static::readNumber(parser, flag_negative);
		}
		
		return static::readIdentifier(parser, true);
	}
	
	
	
	/**
	 * Read call args
	 */
	pure list<ParserBay, Collection> readCallArgs(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		Vector<BaseOpCode> items = new Vector();
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "{")
		{
			list res = static::readDict(parser); parser = res[0]; OpDict d = res[1];
			items = [ d ];
		}
		else if (token.content == "(")
		{
			list res = static::matchToken(parser, "("); parser = res[0];
			list res = static::readToken(parser); look = res[0]; token = res[1];
			while (not token.eof and token.content != ")")
			{
				ParserBay parser_value = null;
				list res = parser.parser_expression::readExpression(parser);
				parser = res[0]; parser_value = res[1];
				items.push(parser_value);
				
				list res = static::readToken(parser); look = res[0]; token = res[1];
				if (token.content == ",")
				{
					parser = look;
					list res = static::readToken(parser); look = res[0]; token = res[1];
				}
			}
			
			list res = static::matchToken(parser, ")"); parser = res[0];
		}
		
		return [parser, items];
	}
	
	
	
	/**
	 * Read new instance
	 */
	pure list<ParserBay, BaseOpCode> readNew(ParserBay parser, bool match_new = true)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		Caret caret_start = parser.caret;
		
		Collection<BaseOpCode> args = [];
		if (match_new)
		{
			list res = static::matchToken(parser, "new"); parser = res[0]; token = res[1];
			caret_start = token.caret_start;
		}
		list res = static::readTypeIdentifier(parser); parser = res[0]; op_code = res[1];
		
		list res = static::readToken(parser); token = res[1];
		if (token.content == "(" or token.content == "{")
		{
			list res = static::readCallArgs(parser); parser = res[0]; args = res[1];
		}
		
		return 
		[
			parser,
			new OpNew
			{
				"args": args,
				"value": op_code,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	
	/**
	 * Read method
	 */
	pure list<ParserBay, BaseOpCode> readMethod(ParserBay parser, bool match = true)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode parser_value = null;
		BaseOpCode op_code = null;
		BaseOpCode value1 = "";
		string value2 = "";
		string kind = "";
		
		Caret caret_start = parser.caret;
		if (match)
		{
			list res = static::matchToken(parser, "method"); parser = res[0]; token = res[1];
		}
		
		ParserBay save = parser;
		
		/* Read static method */
		try
		{
			list res = static::readIdentifier(parser); parser = res[0]; op_code = res[1];
			list res = static::matchToken(parser, "::"); parser = res[0];
			list res = static::readToken(parser); parser = res[0]; token = res[1];
			if (op_code.kind == OpIdentifier::KIND_VARIABLE) kind = OpMethod::KIND_STATIC;
			else kind = OpMethod::KIND_CLASS;
			value1 = op_code;
			value2 = token.content;
		}
		catch (ParserError e)
		{
		}
		
		/* Read instance method */
		if (kind == "")
		{
			parser = save;
			try
			{
				list res = static::readIdentifier(parser); parser = res[0]; op_code = res[1];
				list res = static::matchToken(parser, "."); parser = res[0];
				list res = static::readToken(parser); parser = res[0]; token = res[1];
				kind = OpMethod::KIND_ATTR;
				value1 = op_code;
				value2 = token.content;
			}
			catch (ParserError e)
			{
			}
		}
		
		/* Error */
		if (kind == "")
		{
			throw new ParserExpected("'.' or '::'", parser.caret, parser.file_name);
		}
		
		return 
		[
			parser,
			new OpMethod
			{
				"value1": value1,
				"value2": value2,
				"kind": kind,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	
	/**
	 * Read curry
	 */
	pure list<ParserBay, BaseOpCode> readCurry(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode obj = null;
		Vector<BaseOpCode> args = new Vector();
		
		list res = static::matchToken(parser, "curry"); parser = res[0]; token = res[1];
		list res = static::readDynamic(parser, 14); parser = res[0]; obj = res[1];
		list res = static::matchToken(parser, "("); parser = res[0];
		list res = static::readToken(parser); look = res[0]; token = res[1];
		while (not token.eof and token.content != ")")
		{
			BaseOpCode arg = null;
			if (token.content == "?")
			{
				int pos = 0;
				parser = look;
				list res = static::readToken(look); look = res[0]; token = res[1];
				if (static::isStringOfNumbers(token.content))
				{
					pos = (int)token.content;
					parser = look;
				}
				arg = new OpCurryArg
				{
					"pos": pos,
				};
				args.push(arg);
			}
			else
			{
				list res = parser.parser_expression::readExpression(parser);
				parser = res[0]; arg = res[1];
				args.push(arg);
			}
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
			if (token.content == ",")
			{
				parser = look;
				list res = static::readToken(parser); look = res[0]; token = res[1];
			}
		}
		
		list res = static::matchToken(parser, ")"); parser = res[0];
		
		return
		[
			parser,
			new OpCurry
			{
				"obj": obj,
				"args": args,
			}
		];
	}
	
	
	
	/**
	 * Read base item
	 */
	pure list<ParserBay, BaseOpCode> readBaseItem(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		Caret caret_start = look.caret;
		if (token.content == "new")
		{
			list res = static::readNew(parser); parser = res[0]; op_code = res[1];
		}
		else if (token.content == "method")
		{
			list res = static::readMethod(parser); parser = res[0]; op_code = res[1];
		}
		else if (token.content == "classof")
		{
			list res = static::readClassOf(parser); parser = res[0]; op_code = res[1];
		}
		else if (token.content == "classref")
		{
			list res = static::readClassRef(parser); parser = res[0]; op_code = res[1];
		}
		else if (token.content == "(")
		{
			ParserBay save_parser = parser; parser = look;
			
			/* Try to read OpTypeConvert */
			try
			{
				list res = static::readTypeIdentifier(parser);
				parser = res[0]; OpTypeIdentifier op_type = res[1];
				
				list res = static::readToken(parser); parser = res[0]; token = res[1];
				if (token.content == ")")
				{
					list res = static::readDynamic(parser); parser = res[0]; op_code = res[1];
					return
					[
						parser,
						new OpTypeConvert
						{
							"pattern": op_type,
							"value": op_code,
							"caret_start": caret_start,
							"caret_end": parser.caret,
						}
					];
				}
			}
			catch (ParserError e)
			{
			}			
			
			/* Read Expression */
			list res = static::matchToken(save_parser, "("); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; op_code = res[1];
			list res = static::matchToken(parser, ")"); parser = res[0];
		}
		else
		{
			list res = static::readFixed(parser); parser = res[0]; op_code = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	
	/**
	 * Read classof
	 */
	pure list<ParserBay, BaseOpCode> readClassOf(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		
		list res = static::matchToken(parser, "classof"); parser = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		
		list res = static::readEntityName(parser); parser = res[0]; op_code = res[1];
		return 
		[
			parser,
			new OpClassOf
			{
				"entity_name": op_code,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	
	/**
	 * Read classref
	 */
	pure list<ParserBay, BaseOpCode> readClassRef(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		
		list res = static::matchToken(parser, "classref");
		parser = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		
		list res = parser.parser_expression::readExpression(parser);
		parser = res[0]; op_code = res[1];
		
		return 
		[
			parser, 
			new OpClassRef
			{
				"value": op_code,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	
	/**
	 * Read dynamic
	 */
	pure list<ParserBay, BaseOpCode> readDynamic(ParserBay parser, int dynamic_flags = -1)
	{
		ParserBay look = null;
		CoreToken token = null;
		Collection<BaseOpCode> parser_items = null;
		BaseOpCode op_code = null
		BaseOpCode op_code_first = null;
		bool is_await = false;
		bool is_context_call = true;
		Caret caret_start = null;
		
		/* Dynamic flags */
		int flag_call = 1;
		int flag_attr = 2;
		int flag_static = 4;
		int flag_dynamic = 8;
		
		fn f_next = bool (string s) use (dynamic_flags)
		{
			if (dynamic_flags & 1 == 1)
			{
				if (s == "{" or s == "(" or s == "@") return true;
			}
			if (dynamic_flags & 2 == 2)
			{
				if (s == ".") return true;
			}
			if (dynamic_flags & 4 == 4)
			{
				if (s == "::") return true;
			}
			if (dynamic_flags & 8 == 8)
			{
				if (s == "[") return true;
			}
			return false;
		}
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "await")
		{
			caret_start = token.caret_start;
			is_await = true;
			parser = look;
		}
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "@")
		{
			list res = static::readToken(look);
			ParserBay look2 = res[0]; CoreToken token2 = res[1];
			if (not f_next(token2.content))
			{
				if (static::isIdentifier(token2.content))
				{
					parser = look;
					is_context_call = false;
				}
			}
		}
		list res = static::readBaseItem(parser); parser = res[0]; op_code = res[1];
		
		op_code_first = op_code;
		if (caret_start == null) caret_start = op_code.caret_start;		
		if (
			op_code instanceof OpIdentifier and
			(
				op_code.kind == OpIdentifier::KIND_CONTEXT or
				op_code.kind == OpIdentifier::KIND_SYS_FUNCTION
			)
		)
		{
			is_context_call = false;
		}
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (f_next(token.content))
		{
			if (op_code instanceof OpIdentifier)
			{
				if (
					parser.find_ident and
					op_code.kind != OpIdentifier::KIND_SYS_TYPE and
					op_code.kind != OpIdentifier::KIND_SYS_FUNCTION and
					op_code.kind != OpIdentifier::KIND_VARIABLE and
					op_code.kind != OpIdentifier::KIND_CLASS and
					op_code.kind != OpIdentifier::KIND_CLASSREF and
					op_code.kind != OpIdentifier::KIND_CONTEXT
				)
				{
					throw new ParserExpected
					(
						"Module or variable '" ~ op_code.value ~ "'",
						op_code.caret_start, parser.file_name
					);
				}
			}
			else if (op_code instanceof OpNew or op_code instanceof OpCollection or op_code instanceof OpDict){}
			else
			{
				throw new ParserExpected
				(
					"Module or variable",
					op_code.caret_start
					parser.file_name
				);
			}
		}
		
		/* If is pipe */
		if (parser.is_pipe and op_code instanceof OpIdentifier)
		{
			op_code = new OpAttr
			{
				"kind": parser.pipe_kind,
				"obj": new OpIdentifier
				{
					"kind": OpIdentifier::KIND_PIPE,
					"caret_start": op_code.caret_start,
					"caret_end": op_code.caret_end,
				},
				"value": op_code,
				"caret_start": op_code.caret_start,
				"caret_end": op_code.caret_end,
			};
		}
		
		while (not token.eof and f_next(token.content))
		{
			string token_content = token.content;
			
			/* Static call */
			if (token_content == "(" or token_content == "{" or token_content == "@")
			{
				if (dynamic_flags & flag_call != flag_call)
				{
					throw new ParserError
					(
						"Call are not allowed",
						token.caret_start, parser.file_name
					);
				}
				
				if (token_content == "@")
				{
					parser = look;
					is_context_call = false;
				}
				
				list res = static::readCallArgs(parser); parser = res[0]; parser_items = res[1];
				op_code = new OpCall
				{
					"obj": op_code,
					"args": parser_items,
					"caret_start": caret_start,
					"caret_end": parser.caret,
					"is_await": is_await,
					"is_context": is_context_call,
				};
				is_context_call = true;
			}
			
			/* Object access */
			else if (token_content == "." or token_content == "::" or token_content == "[")
			{
				string kind = "";
				Vector<BaseOpCode> look_values = null;
				BaseOpCode look_value = null;
				parser = look;
				is_context_call = true;
				
				if (token_content == ".")
				{
					kind = OpAttr::KIND_ATTR;
					if (dynamic_flags & flag_attr != flag_attr)
					{
						throw new ParserError
						(
							"Attr are not allowed",
							token.caret_start, parser.file_name
						);
					}
				}
				else if (token_content == "::")
				{
					kind = OpAttr::KIND_STATIC;
					if (dynamic_flags & flag_static != flag_static)
					{
						throw new ParserError
						(
							"Static attr are not allowed",
							token.caret_start, parser.file_name
						);
					}
				}
				else if (token_content == "[")
				{
					kind = OpAttr::KIND_DYNAMIC;
					if (dynamic_flags & flag_dynamic != flag_dynamic)
					{
						throw new ParserError
						(
							"Dynamic attr are not allowed",
							token.caret_start, parser.file_name
						);
					}
				}
				
				if (token_content == "[")
				{
					list res = parser.parser_expression::readExpression(parser);
					parser = res[0]; look_value = res[1];
					
					list res = static::readToken(parser); look = res[0]; token = res[1];
					if (token.content == ",")
					{
						look_values = new Vector();
						look_values.push(look_value);
					}
					while (token.content == ",")
					{
						parser = look;
						list res = parser.parser_expression::readExpression(parser);
						parser = res[0]; look_value = res[1];
						look_values.push(look_value);
						list res = static::readToken(parser); look = res[0]; token = res[1];
					}
					
					list res = static::matchToken(parser, "]"); parser = res[0];
					if (look_values != null)
					{
						kind = OpAttr::KIND_DYNAMIC_ATTRS;
					}
				}
				else
				{
					list res = static::readToken(parser); look = res[0]; token = res[1];
					if (token.content == "@")
					{
						parser = look;
						is_context_call = false;
					}
					list res = static::readIdentifier(parser); parser = res[0]; look_value = res[1];
				}
				
				op_code = new OpAttr
				{
					"kind": kind,
					"obj": op_code,
					"attrs": look_values != null ? look_values : null,
					"value": look_values == null ? look_value : null,
					"caret_start": caret_start,
					"caret_end": parser.caret,
				};
			}
			else
			{
				throw new ParserExpected("Next attr", token.caret_start, parser.file_name);
			}
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
			if 
			(
				op_code instanceof OpAttr and op_code.kind == OpAttr::KIND_PIPE and
				token.content != "(" and token.content != "{"
			)
			{
				throw new ParserExpected("Call", token.caret_start, parser.file_name);
			}
			
		}
		
		return [parser, op_code];
	}
	
}