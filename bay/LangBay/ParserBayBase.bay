/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2025 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang.LangBay;

use Runtime.BaseObject;
use Runtime.Reference;
use BayLang.Caret;
use BayLang.CoreToken;
use BayLang.TokenReader;
use BayLang.Exceptions.ParserEOF;
use BayLang.Exceptions.ParserError;
use BayLang.Exceptions.ParserExpected;
use BayLang.LangBay.ParserBay;
use BayLang.OpCodes.BaseOpCode;
use BayLang.OpCodes.OpAttr;
use BayLang.OpCodes.OpCall;
use BayLang.OpCodes.OpComment;
use BayLang.OpCodes.OpClassOf;
use BayLang.OpCodes.OpClassRef;
use BayLang.OpCodes.OpCollection;
use BayLang.OpCodes.OpCurry;
use BayLang.OpCodes.OpCurryArg;
use BayLang.OpCodes.OpDeclareFunction;
use BayLang.OpCodes.OpDeclareFunctionArg;
use BayLang.OpCodes.OpDict;
use BayLang.OpCodes.OpDictPair;
use BayLang.OpCodes.OpEntityName;
use BayLang.OpCodes.OpIdentifier;
use BayLang.OpCodes.OpMethod;
use BayLang.OpCodes.OpNew;
use BayLang.OpCodes.OpNumber;
use BayLang.OpCodes.OpNegative;
use BayLang.OpCodes.OpPreprocessorIfDef;
use BayLang.OpCodes.OpString;
use BayLang.OpCodes.OpTypeConvert;
use BayLang.OpCodes.OpTypeIdentifier;


class ParserBayBase extends BaseObject
{
	ParserBay parser = null;
	
	
	/**
	 * Constructor
	 */
	void constructor(ParserBay parser)
	{
		parent();
		this.parser = parser;
	}
	
	
	/**
	 * Returns true if name is identifier
	 */
	static bool isIdentifier(string name)
	{
		if (name == "") return false;
		if (name == "@") return true;
		if (Caret::isNumber(rs::charAt(name, 0))) return false;
		int sz = rs::strlen(name);
		for (int i=0; i<sz; i++)
		{
			string ch = rs::charAt(name, i);
			if (Caret::isChar(ch) or Caret::isNumber(ch) or ch == "_") continue;
			return false;
		}
		return true;
	}
	
	
	/**
	 * Returns true if reserved words
	 */
	static bool isReserved(string name)
	{
		if (rs::substr(name, 0, 3) == "__v") return true;
		return false;
	}
	
	
	/**
	 * Read number
	 */
	OpNumber readNumber(TokenReader reader, bool flag_negative = false)
	{
		Caret caret_start = reader.start();
		
		/* Read number */
		string value = reader.readToken();
		if (value == "")
		{
			throw caret_start.expected("Number");
		}
		if (not Caret::isNumber(value))
		{
			throw caret_start.expected("Number");
		}
		
		/* Look dot */
		if (reader.nextToken() == ".")
		{
			value ~= reader.readToken();
			value ~= reader.readToken();
		}
		
		/* Returns op_code */
		return new OpNumber
		{
			"value": flag_negative ? "-" ~ value : value,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read string
	 */
	OpString readString(TokenReader reader)
	{
		Caret caret_start = reader.caret();
		string str_char = reader.readToken();
		
		/* Read begin string char */
		if (str_char != "'" and str_char != '"') /* " */
		{
			throw caret_start.expected("String");
		}
		
		/* Read string value */
		Caret caret = reader.caret();
		string value_str = "";
		string ch = caret.nextChar();
		while (not caret.eof() and ch != str_char)
		{
			if (ch == "\\")
			{
				caret.readChar();
				if (caret.eof())
				{
					throw caret.expected("End of string");
				}
				string ch2 = caret.readChar();
				if (ch2 == "n") value_str ~= "\n";
				else if (ch2 == "r") value_str ~= "\r";
				else if (ch2 == "t") value_str ~= "\t";
				else if (ch2 == "s") value_str ~= " ";
				else if (ch2 == "\\") value_str ~= "\\";
				else if (ch2 == "'") value_str ~= "'";
				else if (ch2 == '"') value_str ~= '"';
				else value_str ~= ch ~ ch2;
			}
			else
			{
				value_str ~= caret.readChar();
			}
			if (caret.eof())
			{
				throw caret.expected("End of string");
			}
			ch = caret.nextChar();
		}
		
		/* Read end string char */
		caret.matchString(str_char);
		
		/* Restore reader */
		reader.init(caret);
		
		/* Returns op_code */
		return new OpString
		{
			"value": value_str,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read comment
	 */
	OpComment readComment(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		/* Read begin coment */
		caret_start.matchString("/*");
		reader.init(caret_start);
		
		/* Read comment value */
		Caret caret = reader.caret();
		string value_str = "";
		string ch2 = caret.nextString(2);
		while (not caret.eof() and ch2 != "*/")
		{
			value_str ~= caret.readChar();
			if (caret.eof())
			{
				throw caret.expected("End of comment");
			}
			ch2 = caret.nextString(2);
		}
		
		/* Restore reader */
		reader.init(caret);
		
		/* Read end coment */
		reader.matchToken("*");
		reader.matchToken("/");
		
		/* Returns op_code */
		return new OpComment
		{
			"value": value_str,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Skip comment
	 */
	bool skipComment(TokenReader reader)
	{
		if (reader.nextToken() != "/") return false;
		this.readComment(reader);
		return true;
	}
	
	
	/**
	 * Read identifier
	 */
	OpIdentifier readIdentifier(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		/* Read identifier */
		string name = reader.readToken();
		if (not static::isIdentifier(name) or static::isReserved(name))
		{
			throw reader.expected("Identifier");
		}
		
		/* Returns op_code */
		return new OpIdentifier
		{
			"value": name,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read entity name
	 */
	OpEntityName readEntityName(TokenReader reader)
	{
		Caret caret_start = reader.start();
		Collection<string> items = [];
		
		/* Read name */
		items.push(this.readIdentifier(reader));
		
		/* Read names */
		while (reader.nextToken() == ".")
		{
			reader.readToken();
			items.push(this.readIdentifier(reader));
		}
		
		/* Returns op_code */
		return new OpEntityName
		{
			"items": items,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read type identifier
	 */
	OpTypeIdentifier readTypeIdentifier(TokenReader reader,
		bool find_entity = true, bool read_generic = true
	)
	{
		Caret caret_start = reader.start();
		OpEntityName entity_name = this.readEntityName(reader);
		
		/* Find entity */
		if (find_entity) this.parser.findEntity(entity_name);
		
		/* Read generics */
		Collection<OpTypeIdentifier> generics = [];
		if (reader.nextToken() == "<" and read_generic)
		{
			reader.matchToken("<");
			reader.main_caret.skipSpace();
			while (not reader.eof() and reader.main_caret.nextChar() != ">")
			{
				generics.push(this.readTypeIdentifier(reader, false));
				reader.main_caret.skipSpace();
				reader.init(reader.main_caret);
				if (reader.main_caret.nextChar() != ">")
				{
					reader.matchToken(",");
				}
			}
			reader.main_caret.matchString(">");
			reader.init(reader.main_caret);
		}
		
		return new OpTypeIdentifier
		{
			"entity_name": entity_name,
			"generics": generics,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read collection
	 */
	OpCollection readCollection(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		reader.matchToken("[");
		Collection items = [];
		while (not reader.eof() and reader.nextToken() != "]")
		{
			if (this.skipComment(reader))
			{
				continue;
			}
			
			BaseOpCode op_code_item = null;
			
			/* Prepocessor */
			bool is_preprocessor = false;
			string next_token = reader.nextToken();
			if (next_token == "#switch" or next_token == "#ifcode" or next_token == "#ifdef")
			{
				is_preprocessor = true;
				op_code_item = this.parser.parser_preprocessor.readPreprocessor(
					reader, OpPreprocessorIfDef::KIND_COLLECTION
				);
			}
			
			/* Expression */
			else
			{
				op_code_item = this.parser.parser_expression.readExpression(reader);
			}
			
			items.push(op_code_item);
			if ((reader.nextToken() == "," or reader.nextToken() != "]") and not is_preprocessor)
			{
				reader.matchToken(",");
			}
		}
		reader.matchToken("]");
		
		return new OpCollection
		{
			"items": items,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read collection
	 */
	OpDict readDict(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		reader.matchToken("{");
		Collection items = [];
		while (not reader.eof() and reader.nextToken() != "}")
		{
			if (reader.nextToken() == "/")
			{
				this.readComment(reader);
				continue;
			}
			
			bool is_preprocessor = false;
			BaseOpCode condition = null;
			
			/* Prepocessor */
			string next_token = reader.nextToken();
			if (next_token == "#ifdef")
			{
				is_preprocessor = true;
				reader.matchToken("#ifdef");
				condition = this.parser.parser_expression.readExpression(reader);
				reader.matchToken("then");
			}
			
			OpString op_code_name = this.readString(reader);
			reader.matchToken(":");
			BaseOpCode op_code_item = this.parser.parser_expression.readExpression(reader);
			
			items.push(new OpDictPair{
				"key": op_code_name,
				"expression": op_code_item,
				"condition": condition,
			});
			if (reader.nextToken() == "," or reader.nextToken() != "}")
			{
				reader.matchToken(",");
			}
			if (is_preprocessor)
			{
				reader.matchToken("#endif");
			}
		}
		reader.matchToken("}");
		
		return new OpDict
		{
			"items": items,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read fixed
	 */
	pure list<ParserBay, BaseOpCode> readFixed(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		ParserBay start = parser;
		Caret caret_start = parser.caret;
		bool flag_negative = false;
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "")
		{
			throw new ParserExpected("Identifier", token.caret_start, look.file_name);
		}
		
		/* Read string */
		if (token.content == "'" or token.content == '"') /* " */
		{
			return static::readString(parser);
		}
		
		/* Read Collection */
		if (token.content == "[")
		{
			return static::readCollection(parser);
		}
		
		/* Read Dict */
		if (token.content == "{")
		{
			return static::readDict(parser);
		}
		
		/* Negative number */
		if (token.content == "-")
		{
			flag_negative = true;
			parser = look;
			list res = static::readToken(look); look = res[0]; token = res[1];
		}
		
		/* Read Number */
		if (static::isNumber(token.content))
		{
			return static::readNumber(parser, flag_negative);
		}
		
		return static::readIdentifier(parser, true);
	}
	
	
	/**
	 * Read call args
	 */
	pure list<ParserBay, Collection> readCallArgs(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		Vector<BaseOpCode> items = new Vector();
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "{")
		{
			list res = static::readDict(parser); parser = res[0]; OpDict d = res[1];
			items = [ d ];
		}
		else if (token.content == "(")
		{
			list res = static::matchToken(parser, "("); parser = res[0];
			list res = static::readToken(parser); look = res[0]; token = res[1];
			while (not token.eof and token.content != ")")
			{
				ParserBay parser_value = null;
				list res = parser.parser_expression::readExpression(parser);
				parser = res[0]; parser_value = res[1];
				items.push(parser_value);
				
				list res = static::readToken(parser); look = res[0]; token = res[1];
				if (token.content == ",")
				{
					parser = look;
					list res = static::readToken(parser); look = res[0]; token = res[1];
				}
			}
			
			list res = static::matchToken(parser, ")"); parser = res[0];
		}
		
		return [parser, items];
	}
	
	
	/**
	 * Read new instance
	 */
	BaseOpCode readNew(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		reader.matchToken("new");
		OpTypeIdentifier pattern = this.readTypeIdentifier(reader);
		Collection<OpDeclareFunctionArg> args = [];
		
		if (reader.nextToken() == "{")
		{
			BaseOpCode item = this.readDict(reader);
			args = [item];
		}
		else if (reader.nextToken() == "(")
		{
			args = this.parser.parser_function.readFunctionArgs(reader);
		}
		
		return new OpNew
		{
			"args": args,
			"pattern": pattern,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read method
	 */
	pure list<ParserBay, BaseOpCode> readMethod(ParserBay parser, bool match = true)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode parser_value = null;
		BaseOpCode op_code = null;
		BaseOpCode value1 = "";
		string value2 = "";
		string kind = "";
		
		Caret caret_start = parser.caret;
		if (match)
		{
			list res = static::matchToken(parser, "method"); parser = res[0]; token = res[1];
		}
		
		ParserBay save = parser;
		
		/* Read static method */
		try
		{
			list res = static::readIdentifier(parser); parser = res[0]; op_code = res[1];
			list res = static::matchToken(parser, "::"); parser = res[0];
			list res = static::readToken(parser); parser = res[0]; token = res[1];
			if (op_code.kind == OpIdentifier::KIND_VARIABLE) kind = OpMethod::KIND_STATIC;
			else kind = OpMethod::KIND_CLASS;
			value1 = op_code;
			value2 = token.content;
		}
		catch (ParserError e)
		{
		}
		
		/* Read instance method */
		if (kind == "")
		{
			parser = save;
			try
			{
				list res = static::readIdentifier(parser); parser = res[0]; op_code = res[1];
				list res = static::matchToken(parser, "."); parser = res[0];
				list res = static::readToken(parser); parser = res[0]; token = res[1];
				kind = OpMethod::KIND_ATTR;
				value1 = op_code;
				value2 = token.content;
			}
			catch (ParserError e)
			{
			}
		}
		
		/* Error */
		if (kind == "")
		{
			throw new ParserExpected("'.' or '::'", parser.caret, parser.file_name);
		}
		
		return 
		[
			parser,
			new OpMethod
			{
				"value1": value1,
				"value2": value2,
				"kind": kind,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	/**
	 * Read curry
	 */
	pure list<ParserBay, BaseOpCode> readCurry(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode obj = null;
		Vector<BaseOpCode> args = new Vector();
		
		list res = static::matchToken(parser, "curry"); parser = res[0]; token = res[1];
		list res = static::readDynamic(parser, 14); parser = res[0]; obj = res[1];
		list res = static::matchToken(parser, "("); parser = res[0];
		list res = static::readToken(parser); look = res[0]; token = res[1];
		while (not token.eof and token.content != ")")
		{
			BaseOpCode arg = null;
			if (token.content == "?")
			{
				int pos = 0;
				parser = look;
				list res = static::readToken(look); look = res[0]; token = res[1];
				if (static::isNumber(token.content))
				{
					pos = (int)token.content;
					parser = look;
				}
				arg = new OpCurryArg
				{
					"pos": pos,
				};
				args.push(arg);
			}
			else
			{
				list res = parser.parser_expression::readExpression(parser);
				parser = res[0]; arg = res[1];
				args.push(arg);
			}
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
			if (token.content == ",")
			{
				parser = look;
				list res = static::readToken(parser); look = res[0]; token = res[1];
			}
		}
		
		list res = static::matchToken(parser, ")"); parser = res[0];
		
		return
		[
			parser,
			new OpCurry
			{
				"obj": obj,
				"args": args,
			}
		];
	}
	
	
	/**
	 * Read base item
	 */
	pure list<ParserBay, BaseOpCode> readBaseItem(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		Caret caret_start = look.caret;
		if (token.content == "new")
		{
			list res = static::readNew(parser); parser = res[0]; op_code = res[1];
		}
		else if (token.content == "method")
		{
			list res = static::readMethod(parser); parser = res[0]; op_code = res[1];
		}
		else if (token.content == "classof")
		{
			list res = static::readClassOf(parser); parser = res[0]; op_code = res[1];
		}
		else if (token.content == "classref")
		{
			list res = static::readClassRef(parser); parser = res[0]; op_code = res[1];
		}
		else if (token.content == "(")
		{
			ParserBay save_parser = parser; parser = look;
			
			/* Try to read OpTypeConvert */
			try
			{
				list res = static::readTypeIdentifier(parser);
				parser = res[0]; OpTypeIdentifier op_type = res[1];
				
				list res = static::readToken(parser); parser = res[0]; token = res[1];
				if (token.content == ")")
				{
					list res = static::readDynamic(parser); parser = res[0]; op_code = res[1];
					return
					[
						parser,
						new OpTypeConvert
						{
							"pattern": op_type,
							"value": op_code,
							"caret_start": caret_start,
							"caret_end": parser.caret,
						}
					];
				}
			}
			catch (ParserError e)
			{
			}			
			
			/* Read Expression */
			list res = static::matchToken(save_parser, "("); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; op_code = res[1];
			list res = static::matchToken(parser, ")"); parser = res[0];
		}
		else
		{
			list res = static::readFixed(parser); parser = res[0]; op_code = res[1];
		}
		
		return [parser, op_code];
	}
	
	
	/**
	 * Read classof
	 */
	BaseOpCode readClassOf(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		reader.matchToken("classof");
		OpEntityName entity_name = this.readEntityName(reader);
		
		return new OpClassOf
		{
			"entity_name": entity_name,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read classref
	 */
	pure list<ParserBay, BaseOpCode> readClassRef(ParserBay parser)
	{
		ParserBay look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		
		list res = static::matchToken(parser, "classref");
		parser = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		
		list res = parser.parser_expression::readExpression(parser);
		parser = res[0]; op_code = res[1];
		
		return 
		[
			parser, 
			new OpClassRef
			{
				"value": op_code,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	/**
	 * Read item
	 */
	BaseOpCode readItem(TokenReader reader)
	{
		string next_token = reader.nextToken();
		if (Caret::isNumber(next_token))
		{
			return this.readNumber(reader);
		}
		else if (next_token == "'" or next_token == '"') /* " */
		{
			return this.readString(reader);
		}
		else if (next_token == "new")
		{
			return this.readNew(reader);
		}
		else if (next_token == "classof")
		{
			return this.readClassOf(reader);
		}
		return this.readIdentifier(reader);
	}
	
	
	/**
	 * Read dynamic
	 */
	BaseOpCode readDynamic(TokenReader reader, bool read_function = true)
	{
		Caret caret_start = reader.start();
		
		/* Read await */
		bool is_await = false;
		if (reader.nextToken() == "await")
		{
			is_await = true;
			reader.matchToken("await");
		}
		
		BaseOpCode item = this.readItem(reader);
		
		if (reader.nextToken() == ".")
		{
			this.parser.findVariable(item);
		}
		
		Collection operations = [".", "::", "[", "("];
		while (not reader.eof() and (operations.indexOf(reader.nextToken()) >= 0))
		{
			string next_token = reader.nextToken();
			if (next_token == "." or next_token == "::")
			{
				if (next_token == "::" and item instanceof OpIdentifier)
				{
					item = new OpTypeIdentifier
					{
						"entity_name": new OpEntityName
						{
							"items": [item],
							"caret_start": item.caret_start,
							"caret_end": item.caret_end,
						},
						"caret_start": item.caret_start,
						"caret_end": item.caret_end,
					};
				}
				reader.matchToken(next_token);
				BaseOpCode op_code_item = this.readIdentifier(reader);
				item = new OpAttr
				{
					"kind": next_token == "." ? OpAttr::KIND_ATTR : OpAttr::KIND_STATIC,
					"prev": item,
					"next": op_code_item,
					"caret_start": caret_start,
					"caret_end": reader.caret(),
				};
			}
			else if (next_token == "(")
			{
				if (read_function)
				{
					item = this.parser.parser_function.readCallFunction(reader, item);
					item.is_await = is_await;
					item.caret_start = caret_start;
				}
				else
				{
					break;
				}
			}
			else if (next_token == "[")
			{
				BaseOpCode op_code_item = this.readCollection(reader);
				item = new OpAttr
				{
					"kind": OpAttr::KIND_DYNAMIC,
					"prev": item,
					"next": op_code_item,
					"caret_start": caret_start,
					"caret_end": reader.caret(),
				};
			}
		}
		
		return item;
	}
}