/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2025 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang;

use Runtime.BaseObject;
use Runtime.Reference;
use Runtime.SerializeInterface;
use Runtime.Serializer;
use BayLang.BaseOpCode;
use BayLang.Exceptions.ParserError;
use BayLang.Exceptions.ParserExpected;
use BayLang.Exceptions.ParserIdentifier;
use BayLang.OpCodes.OpIdentifier;


class Caret extends BaseObject implements SerializeInterface
{
	/**
	 * Content
	 */
	string file_name = null;
	Reference<string> content = null;
	int content_sz = 0;
	
	
	/**
	 * Caret pos in file
	 */
	int pos = 0;
	
	
	/**
	 * Caret pos X
	 */
	int x = 0;
	
	
	/**
	 * Caret pos Y
	 */
	int y = 0;
	
	
	/**
	 * Tab size
	 */
	int tab_size = 4;
	
	
	/**
	 * Skip comments
	 */
	bool skip_comments = true;
	
	
	/**
	 * Constructor
	 */
	public void constructor(Dict items = null)
	{
		parent();
		
		if (items)
		{
			if (items.has("file_name")) this.file_name = items.get("file_name");
			if (items.has("content")) this.content = items.get("content");
			if (items.has("content_sz")) this.content_sz = items.get("content_sz");
			if (items.has("content") and not items.has("content_sz"))
			{
				this.content_sz = rs::strlen(this.content.ref);
			}
			if (items.has("tab_size")) this.tab_size = items.get("tab_size");
			if (items.has("pos")) this.pos = items.get("pos");
			if (items.has("x")) this.x = items.get("x");
			if (items.has("y")) this.y = items.get("y");
		}
	}
	
	
	/**
	 * Clone
	 */
	Caret clone(Dict items = null) => new Caret{
		"file_name": items ? items.get("file_name", this.file_name) : this.file_name,
		"content": items ? items.get("content", this.content) : this.content,
		"content_sz": items ? items.get("content_sz", this.content_sz) : this.content_sz,
		"tab_size": items ? items.get("tab_size", this.tab_size) : this.tab_size,
		"pos": items ? items.get("pos", this.pos) : this.pos,
		"x": items ? items.get("x", this.x) : this.x,
		"y": items ? items.get("y", this.y) : this.y,
	};
	
	
	/**
	 * Copy caret
	 */
	Caret copy(Dict items = null) => this.clone(items);
	
	
	/**
	 * Serialize object
	 */
	void serialize(Serializer serializer, Map data)
	{
		serializer.process(this, "pos", data);
		serializer.process(this, "x", data);
		serializer.process(this, "y", data);
	}
	
	
	/**
	 * Seek caret
	 */
	void seek(Caret caret)
	{
		this.pos = caret.pos;
		this.x = caret.x;
		this.y = caret.y;
	}
	
	
	/**
	 * Returns caret position
	 */
	Dict getPosition() => {
		"offset": this.x + 1,
		"line": this.y + 1,
	};
	
	
	/**
	 * Returns true if eof
	 */
	bool eof() => this.pos >= this.content_sz;
	
	
	/**
	 * Returns next X
	 */
	int nextX(char ch, int direction = 1)
	{
		if (ch == "\t") return this.x + this.tab_size * direction;
		if (ch == "\n") return 0;
		return this.x + direction;
	}
	
	
	/**
	 * Returns next Y
	 */
	int nextY(char ch, int direction = 1)
	{
		if (ch == "\n") return this.y + direction;
		return this.y;
	}
	
	
	/**
	 * Returns next char
	 */
	char nextChar() => rs::charAt(this.content.ref, this.pos, 1);
	
	
	/**
	 * Returns string
	 */
	string getString(int start_pos, int count) => rs::substr(this.content.ref, start_pos, count);
	
	
	/**
	 * Returns next string
	 */
	string nextString(int count) => rs::substr(this.content.ref, this.pos, count);
	
	
	/**
	 * Returns true if next char
	 */
	bool isNextChar(char ch) => this.nextChar() == ch;
	
	
	/**
	 * Returns true if next string
	 */
	bool isNextString(string s) => this.nextString(rs::strlen(s)) == s;
	
	
	/**
	 * Shift by char
	 */
	void shift(char ch)
	{
		this.x = this.nextX(ch);
		this.y = this.nextY(ch);
		this.pos = this.pos + 1;
	}
	
	
	/**
	 * Read char
	 */
	char readChar()
	{
		char ch = rs::charAt(this.content.ref, this.pos);
		this.shift(ch);
		return ch;
	}
	
	
	/**
	 * Read char
	 */
	string readString(int count)
	{
		string s = this.nextString(count);
		int count = rs::strlen(s);
		for (int i=0; i<count; i++)
		{
			char ch = rs::charAt(s, i);
			this.shift(ch);
		}
		return s;
	}
	
	
	/**
	 * Returns parser error
	 */
	void error(string message)
	{
		return new ParserError(message, this, this.file_name);
	}
	
	
	/**
	 * Returns expected error
	 */
	void expected(string message)
	{
		return new ParserExpected(message, this, this.file_name);
	}
	
	
	/**
	 * Match char
	 */
	void matchChar(char ch)
	{
		char next = this.nextChar();
		if (next != ch)
		{
			throw this.expected(ch);
		}
		this.readChar();
	}
	
	
	/**
	 * Match string
	 */
	void matchString(string s)
	{
		int count = rs::strlen(s);
		string next_string = this.nextString(count);
		if (next_string != s)
		{
			throw this.expected(s);
		}
		this.readString(count);
	}
	
	
	/**
	 * Return true if is char
	 * @param char ch
	 * @return boolean
	 */
	static bool isChar(char ch) =>
		rs::indexOf('qazwsxedcrfvtgbyhnujmikolp', rs::lower(ch)) !== -1
	;
	
	
	/**
	 * Return true if is number
	 * @param char ch
	 * @return boolean
	 */
	static bool isNumberChar(char ch) =>
		rs::indexOf('0123456789', ch) !== -1
	;
	
	
	/**
	 * Return true if char is number
	 * @param char ch
	 * @return boolean
	 */
	static bool isHexChar(char ch) =>
		rs::indexOf('0123456789abcdef', rs::lower(ch)) !== -1
	;
	
	
	/**
	 * Return true if is string of numbers
	 * @param string s
	 * @return boolean
	 */
	static bool isNumber(string s)
	{
		int sz = rs::strlen(s);
		for (int i=0; i<sz; i++)
		{
			if (not static::isNumberChar(rs::charAt(s, i))) return false;
		}
		return true;
	}
	
	
	/**
	 * Return true if char is system or space. ASCII code <= 32.
	 * @param char ch
	 * @return boolean
	 */
	static bool isSkipChar(char ch)
	{
		if (rs::ord(ch) <= 32) return true;
		return false;
	}
	
	
	/**
	 * Skip chars
	 */
	bool skipChar(char ch)
	{
		if (this.nextChar() == ch)
		{
			this.readChar();
			return true;
		}
		return false;
	}
	
	
	/**
	 * Skip space
	 */
	Caret skipSpace()
	{
		while (not this.eof() and static::isSkipChar(this.nextChar())) this.readChar();
		return this;
	}
	
	
	/**
	 * Skip comment
	 */
	Caret skipComment()
	{
		if (this.nextString(2) == "/*")
		{
			this.readChar();
			while (not this.eof() and this.nextString(2) != "*/") this.readChar();
			this.readString(2);
		}
		return this;
	}
	
	
	/**
	 * Skip token
	 */
	Caret skipToken()
	{
		this.skipSpace();
		if (this.skip_comments)
		{
			while (not this.eof() and this.nextString(2) == "/*")
			{
				this.skipComment();
				this.skipSpace();
			}
		}
		return this;
	}
	
	
	/**
	 * Returns true if token char
	 */
	bool isTokenChar(char ch)
	{
		return rs::indexOf('qazwsxedcrfvtgbyhnujmikolp0123456789_', rs::lower(ch)) !== -1;
	}
	
	
	/**
	 * Read next token
	 */
	string readToken()
	{
		/* Skip token */
		this.skipToken();
		if (this.eof()) return "";
		
		/* Read special token */
		string token = this.readSpecialToken();
		if (token)
		{
			this.readString(rs::strlen(token));
			return token;
		}
		
		/* Read char */
		if (not this.isTokenChar(this.nextChar())) return this.readChar();
		
		/* Read token */
		Vector items = [];
		while (not this.eof() and this.isTokenChar(this.nextChar()))
		{
			items.push(this.readChar());
		}
		return rs::join("", items);
	}
	
	
	/**
	 * Read special token
	 */
	string readSpecialToken()
	{
		if (this.eof()) return "";
		
		string s = this.nextString(10);
		if (s == "#endswitch") return s;
		
		s = this.nextString(7);
		if (s == "#ifcode" or s == "#switch" or s == "#elseif" or s == "%render") return s;
		
		s = this.nextString(6);
		if (s == "#endif" or s == "#ifdef" or s == "%while") return s;
		
		s = this.nextString(5);
		if (s == "#case" or s == "%else" or s == "<?php") return s;
		
		s = this.nextString(4);
		if (s == "@css" or s == "%for" or s == "%var" or s == "%set") return s;
		
		s = this.nextString(3);
		if (
			s == "!--" or
			s == "!==" or
			s == "===" or
			s == "..." or
			s == "#if" or
			s == "%if"
		)
			return s;
		
		s = this.nextString(2);
		if (
			s == "{{" or
			s == "}}" or
			s == "==" or
			s == "!=" or
			s == "<=" or
			s == ">=" or
			s == "=>" or
			s == "->" or
			s == "|>" or
			s == "||" or
			s == "&&" or
			s == "::" or
			s == "+=" or
			s == "-=" or
			s == "~=" or
			s == "**" or
			s == "</" or
			s == "<<" or
			s == ">>" or
			s == "++" or
			s == "--"
		)
			return s;
			
		return "";
	}
}