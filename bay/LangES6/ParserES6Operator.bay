/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2025 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang.LangES6;

use Runtime.BaseObject;
use Runtime.Reference;
use BayLang.Caret;
use BayLang.CoreToken;
use BayLang.TokenReader;
use BayLang.Exceptions.ParserError;
use BayLang.Exceptions.ParserExpected;
use BayLang.LangES6.ParserES6;
use BayLang.OpCodes.BaseOpCode;
use BayLang.OpCodes.OpAnnotation;
use BayLang.OpCodes.OpAssign;
use BayLang.OpCodes.OpAssignStruct;
use BayLang.OpCodes.OpAssignValue;
use BayLang.OpCodes.OpAttr;
use BayLang.OpCodes.OpBreak;
use BayLang.OpCodes.OpCall;
use BayLang.OpCodes.OpComment;
use BayLang.OpCodes.OpContinue;
use BayLang.OpCodes.OpDeclareFunction;
use BayLang.OpCodes.OpDeclareFunctionArg;
use BayLang.OpCodes.OpDelete;
use BayLang.OpCodes.OpEntityName;
use BayLang.OpCodes.OpFlags;
use BayLang.OpCodes.OpFor;
use BayLang.OpCodes.OpIdentifier;
use BayLang.OpCodes.OpIf;
use BayLang.OpCodes.OpIfElse;
use BayLang.OpCodes.OpInc;
use BayLang.OpCodes.OpItems;
use BayLang.OpCodes.OpPipe;
use BayLang.OpCodes.OpPreprocessorIfDef;
use BayLang.OpCodes.OpReturn;
use BayLang.OpCodes.OpThrow;
use BayLang.OpCodes.OpTryCatch;
use BayLang.OpCodes.OpTryCatchItem;
use BayLang.OpCodes.OpTypeIdentifier;
use BayLang.OpCodes.OpWhile;


class ParserES6Operator extends BaseObject
{
	ParserES6 parser = null;
	
	
	/**
	 * Constructor
	 */
	void constructor(ParserES6 parser)
	{
		parent();
		this.parser = parser;
	}
	
	
	/**
	 * Read return
	 */
	pure list<ParserES6, BaseOpCode> readReturn(ParserES6 parser)
	{
		CoreToken token = null;
		BaseOpCode op_code = null;
		ParserES6 look = null;
		
		list res = parser.parser_base::matchToken(parser, "return"); parser = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content != ";")
		{
			list res = parser.parser_expression::readExpression(parser); parser = res[0]; op_code = res[1];
		}
		
		return
		[
			parser,
			new OpReturn
			{
				"expression": op_code,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	/**
	 * Read delete
	 */
	pure list<ParserES6, BaseOpCode> readDelete(ParserES6 parser)
	{
		CoreToken token = null;
		BaseOpCode op_code = null;
		
		list res = parser.parser_base::matchToken(parser, "delete"); parser = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		
		list res = parser.parser_base::readDynamic(parser); parser = res[0]; op_code = res[1];
		
		return
		[
			parser,
			new OpDelete
			{
				"op_code": op_code,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	/**
	 * Read throw
	 */
	pure list<ParserES6, BaseOpCode> readThrow(ParserES6 parser)
	{
		CoreToken token = null;
		BaseOpCode op_code = null;
		
		list res = parser.parser_base::matchToken(parser, "throw"); parser = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		
		list res = parser.parser_expression::readExpression(parser); parser = res[0]; op_code = res[1];
		
		return
		[
			parser,
			new OpThrow
			{
				"expression": op_code,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	/**
	 * Read try
	 */
	pure list<ParserES6, BaseOpCode> readTry(ParserES6 parser)
	{
		ParserES6 look = null;
		CoreToken token = null;
		BaseOpCode op_try = null;
		Vector<OpTryCatchItem> items = new Vector();
		
		list res = parser.parser_base::matchToken(parser, "try"); parser = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		
		/* Try */
		list res = static::readOperators(parser); parser = res[0]; op_try = res[1];
		
		/* Catch */
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		while (not token.eof and token.content == "catch")
		{
			parser = look;
			
			BaseOpCode op_catch = null;
			BaseOpCode var_op_code = null;
			OpTypeIdentifier pattern = null;
			Caret item_caret_start = token.caret_start;
			
			/* Read ident */
			list res = parser.parser_base::matchToken(parser, "("); parser = res[0];
			list res = parser.parser_base::readTypeIdentifier(parser); parser = res[0]; pattern = res[1];
			list res = parser.parser_base::readIdentifier(parser); parser = res[0]; var_op_code = res[1];
			string var_name = var_op_code.value;
			list res = parser.parser_base::matchToken(parser, ")"); parser = res[0];
			
			/* Save vars */
			Dict<bool> save_vars = parser.vars;
			parser <= vars <= parser.vars.setIm(var_name, true);
			
			/* Catch operators */
			list res = static::readOperators(parser); parser = res[0]; op_catch = res[1];
			
			/* Restore vars */
			parser <= vars <= save_vars;
			
			OpTryCatchItem item = new OpTryCatchItem
			{
				"name": var_name,
				"pattern": pattern,
				"value": op_catch,
				"caret_start": item_caret_start,
				"caret_end": parser.caret,
			};
			items.push(item);
			
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		}
		
		return
		[
			parser,
			new OpTryCatch
			{
				"op_try": op_try,
				"items": items,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	/**
	 * Read then
	 */
	pure list<ParserES6, CoreToken> readThen(ParserES6 parser)
	{
		ParserES6 look = null;
		CoreToken token = null;
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "then")
		{
			return [look, token];
		}
		return [parser, token];
	}
	
	
	/**
	 * Read do
	 */
	pure list<ParserES6, CoreToken> readDo(ParserES6 parser)
	{
		ParserES6 look = null;
		CoreToken token = null;
		list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "do")
		{
			return [look, token];
		}
		return [parser, token];
	}
	
	
	/**
	 * Read if
	 */
	BaseOpCode readIf(TokenReader reader)
	{
		Caret caret_start = reader.start();
		BaseOpCode if_true = null;
		BaseOpCode if_false = null;
		Collection if_else = [];
		
		/* Read condition */
		reader.matchToken("if");
		reader.matchToken("(");
		BaseOpCode condition = this.parser.parser_expression.readExpression(reader);
		reader.matchToken(")");
		
		/* Read content */
		if_true = this.readContent(reader);
		
		/* Read content */
		Collection operations = ["else", "elseif"];
		while (not reader.eof() and (operations.indexOf(reader.nextToken()) >= 0))
		{
			string token = reader.readToken();
			if (token == "elseif" or token == "else" and reader.nextToken() == "if")
			{
				/* Read condition */
				if (reader.nextToken() == "if") reader.readToken();
				reader.matchToken("(");
				BaseOpCode if_else_condition = this.parser.parser_expression.readExpression(reader);
				reader.matchToken(")");
				
				/* Read content */
				BaseOpCode if_else_content = this.readContent(reader);
				
				/* Add op_code */
				if_else.push(new OpIfElse
				{
					"condition": if_else_condition,
					"content": if_else_content,
					"caret_start": caret_start,
					"caret_end": reader.caret(),
				});
			}
			else if (token == "else")
			{
				if_false = this.readContent(reader);
			}
		}
		
		return new OpIf
		{
			"condition": condition,
			"if_true": if_true,
			"if_false": if_false,
			"if_else": if_else,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read For
	 */
	BaseOpCode readFor(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		/* Read for */
		reader.matchToken("for");
		reader.matchToken("(");
		
		/* Read assing */
		BaseOpCode expr1 = this.readAssign(reader);
		reader.matchToken(";");
		
		/* Read expression */
		BaseOpCode expr2 = this.parser.parser_expression.readExpression(reader);
		reader.matchToken(";");
		
		/* Read operator */
		BaseOpCode expr3 = this.readInc(reader);
		reader.matchToken(")");
		
		/* Read content */
		OpItems content = this.readContent(reader);
		
		/* Returns op_code */
		return new OpFor
		{
			"expr1": expr1,
			"expr2": expr2,
			"expr3": expr3,
			"content": content,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		}
	}
	
	
	/**
	 * Read While
	 */
	BaseOpCode readWhile(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		/* Read condition */
		reader.matchToken("while");
		reader.matchToken("(");
		BaseOpCode condition = this.parser.parser_expression.readExpression(reader);
		reader.matchToken(")");
		
		/* Read items */
		OpItems content = null;
		if (reader.nextToken() == "{")
		{
			content = this.parse(reader);
		}
		else
		{
			content = this.readOperator(reader);
		}
		
		/* Returns op_code */
		return new OpWhile
		{
			"content": content,
			"condition": condition,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		}
	}
	
	
	/**
	 * Read assign
	 */
	OpAssign readAssign(TokenReader reader, BaseOpCode pattern = null)
	{
		Caret caret_start = reader.start();
		Collection<OpAssignValue> items = [];
		
		/* Read pattern */
		if (pattern == null)
		{
			pattern = this.parser.parser_base.readTypeIdentifier(reader);
		}
		
		/* Read increment */
		if (reader.nextToken() == "++" or reader.nextToken() == "--")
		{
			string kind = "";
			string operation = reader.readToken();
			if (operation == "++") kind = OpInc::KIND_INC;
			else if (operation == "--") kind = OpInc::KIND_DEC;
			
			/* Find identifier */
			if (pattern instanceof OpTypeIdentifier)
			{
				pattern = pattern.entity_name.items.last();
			}
			if (not(pattern instanceof OpIdentifier))
			{
				throw pattern.caret_end.error("Wrong type identifier");
			}
			this.parser.findVariable(pattern);
			
			/* Returns op_code */
			return new OpInc
			{
				"kind": kind,
				"item": pattern,
				"caret_start": caret_start,
				"caret_end": reader.caret(),
			};
		}
		
		/* Read items */
		if (reader.nextToken() != "=")
		{
			while (not reader.eof())
			{
				Caret caret_value_start = reader.start();
				
				/* Read assign value */
				OpIdentifier value = this.parser.parser_base.readIdentifier(reader);
				
				/* Register variable */
				this.parser.addVariable(value, pattern);
				
				/* Read expression */
				BaseOpCode expression = null;
				if (reader.nextToken() == "=")
				{
					reader.matchToken("=");
					expression = this.parser.parser_expression.readExpression(reader);
				}
				
				/* Add op_code */
				items.push(new OpAssignValue{
					"value": value,
					"expression": expression,
					"caret_start": caret_value_start,
					"caret_end": reader.caret(),
				});
				
				/* Read next token */
				if (reader.nextToken() != ",") break;
				reader.readToken();
			}
		}
		
		/* Assign single value */
		else
		{
			/* Get value */
			BaseOpCode value = pattern;
			pattern = null;
			
			/* Find identifier */
			if (value instanceof OpTypeIdentifier)
			{
				value = value.entity_name.items.last();
			}
			if (not(value instanceof OpIdentifier))
			{
				throw value.caret_end.error("Wrong type identifier");
			}
			this.parser.findVariable(value);
			
			/* Read expression */
			reader.matchToken("=");
			BaseOpCode expression = this.parser.parser_expression.readExpression(reader);
			items.push(new OpAssignValue{
				"value": value,
				"expression": expression,
				"caret_start": caret_start,
				"caret_end": reader.caret(),
			});
		}
		
		/* Returns op_code */
		return new OpAssign
		{
			"flags": new OpFlags(),
			"pattern": pattern,
			"items": items,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read operator
	 */
	BaseOpCode readInc(TokenReader reader)
	{
		Caret caret_start = reader.start();
		
		/* Read identifier */
		BaseOpCode item = this.parser.parser_base.readIdentifier(reader);
		
		/* Read kind */
		string kind = reader.readToken();
		if (kind == "++") kind = OpInc::KIND_INC;
		else if (kind == "--") kind = OpInc::KIND_DEC;
		else throw reader.expected("++ or --");
		
		/* Returns op_code */
		return new OpInc
		{
			"kind": kind,
			"item": item,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read operator
	 */
	BaseOpCode readOperator(TokenReader reader)
	{
		string next_token = reader.nextToken();
		Caret caret_start = reader.start();
		
		/* Comment */
		if (next_token == "/")
		{
			return this.parser.parser_base.readComment(reader);
		}
		
		/* Break */
		else if (next_token == "break")
		{
			return new OpBreak
			{
				"caret_start": caret_start,
				"caret_end": reader.caret(),
			};
		}
		
		/* Continue */
		else if (next_token == "continue")
		{
			return new OpContinue
			{
				"caret_start": caret_start,
				"caret_end": reader.caret(),
			};
		}
		
		/* Delete */
		else if (next_token == "delete")
		{
			return this.readDelete(reader);
		}
		
		/* Return */
		else if (next_token == "return")
		{
			return this.readReturn(reader);
		}
		
		/* Throw */
		else if (next_token == "throw")
		{
			return this.readThrow(reader);
		}
		
		/* Try catch */
		else if (next_token == "try")
		{
			return this.readTry(reader);
		}
		
		/* If operator */
		else if (next_token == "if")
		{
			return this.readIf(reader);
		}
		
		/* For operator */
		else if (next_token == "for")
		{
			return this.readFor(reader);
		}
		
		/* While operator */
		else if (next_token == "while")
		{
			return this.readWhile(reader);
		}
		
		/* Save caret */
		Caret save_caret = reader.caret();
		
		/* Try to read call function */
		OpCall op_code = this.parser.parser_function.readCallFunction(reader);
		if (op_code) return op_code;
		
		/* Restore reader */
		reader.init(save_caret);
		
		/* Assign operator */
		return this.readAssign(reader);
	}
	
	
	/**
	 * Read content
	 */
	BaseOpCode readContent(TokenReader reader)
	{
		if (reader.nextToken() == "{")
		{
			return this.parse(reader);
		}
		BaseOpCode content = this.readOperator(reader);
		reader.matchToken(";");
		return content;
	}
	
	
	/**
	 * Read operators
	 */
	BaseOpCode parse(TokenReader reader)
	{
		Caret caret_start = reader.start();
		Collection<BaseOpCode> items = [];
		
		/* Read begin tag */
		reader.matchToken("{");
		
		/* Read operators */
		while (not reader.eof() and reader.nextToken() != "}")
		{
			BaseOpCode op_code = this.readOperator(reader);
			if (op_code)
			{
				items.push(op_code);
			}
			else
			{
				break;
			}
			
			/* Match semicolon */
			if (reader.nextToken() == ";")
			{
				reader.matchToken(";");
			}
		}
		
		/* Read end tag */
		reader.matchToken("}");
		
		/* Returns value */
		return new OpItems
		{
			"items": items,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
}