/*!
 *  Bayrell Language
 *
 *  (c) Copyright 2016-2019 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayrellLang.Compile;

use Runtime.RuntimeUtils;
use BayrellParser.Exceptions.ParserError;
use BayrellLang.Compile.CompileInfo;
use BayrellLang.Compile.CompileModule;
use BayrellLang.Compile.CompileResult;
use BayrellLang.Compile.ModuleJson;
use BayrellLang.Compile.ProjectJson;
use BayrellLang.LangBay.ParserBayFactory;
use BayrellLang.LangPHP.TranslatorPHPFactory;
use BayrellLang.LangES6.TranslatorES6Factory;
use BayrellLang.LangNodeJS.TranslatorNodeJSFactory;
use BayrellLang.Utils as BayrellLangUtils;


class CompileProvider
{
	
	
	/**
	 * Find module by file path
	 */
	lambda CompileModule findModuleByFile
	(
		ContextInterface context, 
		string file_path,
		string base_path = ""
	)
	{
		FileSystemInterface fs = context.get("provider.default.fs");
		file_path = rs::normalize( file_path );
		
		ModuleJson module_json = null;
		ProjectJson project_json = null;
		
		string json_file = "";
		string json_file_path = "";
		string folder_path = rs::dirname(file_path);
		Vector<string> arr = rs::explode("/", folder_path);
		
		while (arr.count() != 0)
		{
			folder_path = rs::implode("/", arr);
			
			/* Find module.json */
			json_file = folder_path ~ "/module.json";
			json_file_path = base_path ~ "/" ~ json_file;
			if (fs.isFile(json_file_path))
			{
				string content = fs.readFile(json_file_path);
				module_json = ModuleJson::createFromContent(json_file, content);
			}
			
			/* Find project.json */
			json_file = folder_path ~ "/project.json";
			json_file_path = base_path ~ "/" ~ json_file;
			if (fs.isFile(json_file_path))
			{
				string content = fs.readFile(json_file_path);
				project_json = ProjectJson::createFromContent(json_file, content);
			}
			
			if (module_json != null and project_json != null)
			{
				break;
			}
			arr.pop();
		}
		
		CompileModule module = null;
		if (module_json != null and project_json != null)
		{
			string module_path = rs::dirname(module_json.file_path);
			bool is_editable = false;
			if (fs.isDir(base_path ~ "/" ~ module_path ~ "/bay"))
			{
				is_editable = true;
			}
			
			module = new CompileModule
			{
				"name": module_json.name,
				"space": module_json.space,
				"path": module_path,
				"lang": project_json.lang,
				"is_editable": is_editable,
			};
			
			module = CompileModule::initLangPath(module);
		}
		
		return module;
	}
	
	
	
	/**
	 * Compile file
	 */
	lambda CompileResult compile
	(
		ContextInterface context,
		string file_path,
		string base_path = ""
	)
	{
		FileSystemInterface fs = context.get("provider.default.fs");
		CompileResult res = new CompileResult{ "src": file_path, "success": false };
		CompileModule module = static::findModuleByFile(context, file_path, base_path);
		
		if (module == null)
		{
			res <= error <= "module not found";
			return res;
		}
		res <= module <= module;
		
		Vector<CompileInfo> info = new Vector();
		string extname = rs::extname(file_path);		
		if (extname == "bay" or extname == 'es6')
		{
			for (var i=0; i<module.lang.count(); i++)
			{
				string lang = module.lang.item(i);
				CompileInfo compile_info = static::compileFile(
					context, module, 
					file_path, base_path,
					extname, lang
				);
				
				string content = compile_info.content;
				compile_info <= content <= "";
				info.push(compile_info);
				if (not compile_info.success)
				{
					res <= error <= res.error;
					break;
				}
				
				/* Save file to dest */
				string dest_path = base_path ~ "/" ~ compile_info.dest;
				string dir_path = rs::dirname(dest_path);
				fs.makeDir(dir_path);
				fs.saveFile(dest_path, content);
			}
		}
		
		res <= info <= info.toCollection();
		
		return res;
	}
	
	
	
	/**
	 * Compile file
	 */
	lambda CompileInfo compileFile
	(
		ContextInterface context, CompileModule module, 
		string file_path, string base_path,
		string lang_from, string lang_to
	)
	{
		string lib_path = module.path ~ "/bay";
		string relative_path = rs::substr(file_path, rs::strlen(lib_path) + 1 );
		string dir_path = rs::dirname(relative_path);
		string filename = rs::filename(file_path);
		string save_dir = "";
		string save_ext = "";
		string translator = null;
		
		
		if (lang_from == "bay" and lang_to == "php")
		{
			save_dir = "php";
			save_ext = ".php";
			translator = new TranslatorPHPFactory(context);
		}
		if (lang_from == "bay" and lang_to == "es6")
		{
			save_dir = "es6";
			save_ext = ".js";
			translator = new TranslatorES6Factory(context);
		}
		if (lang_from == "bay" and lang_to == "nodejs")
		{
			save_dir = "nodejs";
			save_ext = ".js";
			translator = new TranslatorNodeJSFactory(context);
		}
		if (lang_from == "es6" and lang_to == "es6")
		{
			save_dir = "es6";
			save_ext = ".js";
			translator = null;
		}
		
		
		if (save_dir == "" or save_ext == "") return null;
		var save_path = rs::normalize(module.path ~ "/" ~ save_dir ~ "/" ~ dir_path ~ "/" ~ filename ~ save_ext);
		
		
		/* Compile */
		FileSystemInterface fs = context.get("provider.default.fs");
		string res = "";
		string content = fs.readFile(base_path ~ "/" ~ file_path);
		if (translator != null)
		{
			bool success = true;
			string err = "";
			
			try
			{
				res = BayrellLangUtils::translateSource(
					context, 
					new ParserBayFactory(context), 
					translator,
					content
				);
			}
			catch (ParserError e)
			{
				err = e.toString();
				success = false;
			}
			
			if (not success)
			{
				return new CompileInfo
				{ 
					"src": file_path, 
					"dest": save_path, 
					"module": module, 
					"error": err, 
					"success": false, 
					"lang_from": lang_from, 
					"lang_to": lang_to 
				};
			}
		}
		else
		{
			res = content;
		}
		
		
		return new CompileInfo
		{ 
			"src": file_path, 
			"dest": save_path, 
			"module": module, 
			"content": res, 
			"success": true, 
			"lang_from": lang_from, 
			"lang_to": lang_to 
		};
	}
	
	
}