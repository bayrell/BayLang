/*!
 *  BayLang Technology
 *
 *  (c) Copyright 2016-2024 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayLang.LangPHP;

use Runtime.BaseObject;
use Runtime.Reference;
use BayLang.Caret;
use BayLang.CoreToken;
use BayLang.TokenReader;
use BayLang.Exceptions.ParserEOF;
use BayLang.Exceptions.ParserError;
use BayLang.Exceptions.ParserExpected;
use BayLang.LangPHP.ParserPHP;
use BayLang.OpCodes.BaseOpCode;
use BayLang.OpCodes.OpAttr;
use BayLang.OpCodes.OpCall;
use BayLang.OpCodes.OpComment;
use BayLang.OpCodes.OpClassOf;
use BayLang.OpCodes.OpClassRef;
use BayLang.OpCodes.OpCollection;
use BayLang.OpCodes.OpCurry;
use BayLang.OpCodes.OpCurryArg;
use BayLang.OpCodes.OpDeclareFunction;
use BayLang.OpCodes.OpDeclareFunctionArg;
use BayLang.OpCodes.OpDict;
use BayLang.OpCodes.OpDictPair;
use BayLang.OpCodes.OpEntityName;
use BayLang.OpCodes.OpIdentifier;
use BayLang.OpCodes.OpMethod;
use BayLang.OpCodes.OpNew;
use BayLang.OpCodes.OpNumber;
use BayLang.OpCodes.OpNegative;
use BayLang.OpCodes.OpPreprocessorIfDef;
use BayLang.OpCodes.OpString;
use BayLang.OpCodes.OpTypeConvert;
use BayLang.OpCodes.OpTypeIdentifier;


class ParserPHPBase extends BaseObject
{
	ParserPHP parser = null;
	
	
	/**
	 * Constructor
	 */
	void constructor(ParserPHP parser)
	{
		parent();
		this.parser = parser;
	}
	
	
	/**
	 * Is system type
	 */
	static bool isSystemType (string name)
	{
		if (name == "var") return true;
		if (name == "void") return true;
		if (name == "bool") return true;
		if (name == "byte") return true;
		if (name == "int") return true;
		if (name == "double") return true;
		if (name == "float") return true;
		if (name == "char") return true;
		if (name == "string") return true;
		if (name == "list") return true;
		if (name == "scalar") return true;
		if (name == "primitive") return true;
		if (name == "html") return true;
		if (name == "Error") return true;
		if (name == "Object") return true;
		if (name == "DateTime") return true;
		if (name == "Collection") return true;
		if (name == "Dict") return true;
		if (name == "Vector") return true;
		if (name == "Map") return true;
		if (name == "rs") return true;
		if (name == "rtl") return true;
		if (name == "ArrayInterface") return true;
		return false;
	}
	
	
	/**
	 * Returns true if name is identifier
	 */
	static bool isIdentifier(string name)
	{
		if (name == "") return false;
		if (Caret::isNumber(rs::charAt(name, 0))) return false;
		int sz = rs::strlen(name);
		for (int i=0; i<sz; i++)
		{
			string ch = rs::charAt(name, i);
			if (Caret::isChar(ch) or Caret::isNumber(ch) or ch == "_") continue;
			return false;
		}
		return true;
	}
	
	
	/**
	 * Returns true if reserved words
	 */
	static bool isReserved(string name)
	{
		if (rs::substr(name, 0, 3) == "__v") return true;
		return false;
	}
	
	
	/**
	 * Read number
	 */
	OpNumber readNumber(TokenReader reader, bool flag_negative = false)
	{
		Caret caret_start = reader.caret();
		
		/* Read number */
		string value = reader.readToken();
		if (value == "")
		{
			throw caret_start.expected("Number");
		}
		if (not Caret::isNumber(value))
		{
			throw caret_start.expected("Number");
		}
		
		/* Look dot */
		if (reader.nextToken() == ".")
		{
			value ~= reader.readToken();
			value ~= reader.readToken();
		}
		
		/* Returns op_code */
		return new OpNumber
		{
			"value": flag_negative ? "-" ~ value : value,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read string
	 */
	OpString readString(TokenReader reader)
	{
		Caret caret_start = reader.caret();
		string str_char = reader.readToken();
		
		/* Read begin string char */
		if (str_char != "'" and str_char != '"') /* " */
		{
			throw caret_start.expected("String");
		}
		
		/* Read string value */
		Caret caret = reader.caret();
		string value_str = "";
		string ch = caret.nextChar();
		while (not caret.eof() and ch != str_char)
		{
			if (ch == "\\")
			{
				caret.readChar();
				if (caret.eof())
				{
					throw caret.expected("End of string");
				}
				string ch2 = caret.readChar();
				if (ch2 == "n") value_str ~= "\n";
				else if (ch2 == "r") value_str ~= "\r";
				else if (ch2 == "t") value_str ~= "\t";
				else if (ch2 == "s") value_str ~= " ";
				else if (ch2 == "\\") value_str ~= "\\";
				else if (ch2 == "'") value_str ~= "'";
				else if (ch2 == '"') value_str ~= '"';
				else value_str ~= ch ~ ch2;
			}
			else
			{
				value_str ~= caret.readChar();
			}
			if (caret.eof())
			{
				throw caret.expected("End of string");
			}
			ch = caret.nextChar();
		}
		
		/* Read end string char */
		if (ch != "'" and ch != '"') /* " */
		{
			throw caret.expected("End of string");
		}
		
		/* Restore reader */
		reader.init(caret);
		
		/* Returns op_code */
		return new OpString
		{
			"value": value_str,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read comment
	 */
	OpComment readComment(TokenReader reader)
	{
		Caret caret_start = reader.caret();
		string str_char = reader.readToken();
		
		/* Read begin coment */
		reader.matchToken("/");
		reader.matchToken("*");
		
		/* Read comment value */
		Caret caret = reader.caret();
		string value_str = "";
		string ch2 = caret.nextString(2);
		while (not caret.eof() and ch2 != "*/")
		{
			value_str ~= caret.readChar();
			if (caret.eof())
			{
				throw caret.expected("End of comment");
			}
			ch2 = caret.nextString(2);
		}
		
		/* Restore reader */
		reader.init(caret);
		
		/* Read end coment */
		reader.matchToken("*");
		reader.matchToken("/");
		
		/* Returns op_code */
		return new OpComment
		{
			"value": value_str,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read identifier
	 */
	OpIdentifier readIdentifier(TokenReader reader)
	{
		Caret caret_start = reader.caret();
		
		/* Skip $ */
		if (reader.nextToken() == "$") reader.readToken();
		
		/* Read identifier */
		string name = reader.readToken();
		if (not static::isIdentifier(name) or static::isReserved(name))
		{
			throw reader.expected("Identifier");
		}
		
		/* Returns op_code */
		return new OpIdentifier
		{
			"value": name,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read entity name
	 */
	OpEntityName readEntityName(TokenReader reader)
	{
		Caret caret_start = reader.caret();
		Collection<string> items = [];
		
		/* Read name */
		items.push(this.readIdentifier(reader));
		
		/* Read names */
		while (reader.nextToken() == ".")
		{
			reader.readToken();
			items.push(this.readIdentifier(reader));
		}
		
		/* Returns op_code */
		return new OpEntityName
		{
			"items": items,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read type identifier
	 */
	OpTypeIdentifier readTypeIdentifier(TokenReader reader, bool read_generic = true)
	{
		Caret caret_start = reader.caret();
		OpEntityName entity_name = this.readEntityName(reader);
		
		/* Read generics */
		Collection<OpTypeIdentifier> generics = [];
		if (reader.nextToken() == "<" and read_generic)
		{
			while (not reader.eof() and reader.nextToken() != ">")
			{
				generics.push(this.readTypeIdentifier);
				if (reader.nextToken() != ">")
				{
					reader.matchToken(",");
				}
			}
		}
		
		return new OpTypeIdentifier
		{
			"entity_name": entity_name,
			"generics": generics,
			"caret_start": caret_start,
			"caret_end": reader.caret(),
		};
	}
	
	
	/**
	 * Read collection
	 */
	pure list<ParserPHP, BaseOpCode> readCollection(ParserPHP parser)
	{
		ParserPHP start = parser;
		ParserPHP look = null;
		CoreToken token = null;
		Vector<BaseOpCode> values = new Vector();
		BaseOpCode ifdef_condition = null;
		bool flag_ifdef = false;
		
		list res = static::matchToken(parser, "["); parser = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		while (not token.eof and token.content != "]")
		{
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			if (token.content == "#ifdef")
			{
				parser = look;
				parser <= find_ident <= false;
				list res = parser.parser_expression::readExpression(parser);
				parser = res[0]; ifdef_condition = res[1];
				parser <= find_ident <= true;
				list res = parser.parser_base::matchToken(parser, "then");
				parser = res[0]; token = res[1];
				flag_ifdef = true;
			}
			
			BaseOpCode parser_value = null;
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; parser_value = res[1];
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
			if (token.content == ",")
			{
				parser = look;
				list res = static::readToken(parser); look = res[0]; token = res[1];
			}
			
			if (flag_ifdef)
			{
				parser_value = new OpPreprocessorIfDef
				{
					"items": parser_value,
					"condition": ifdef_condition,
				}
			}
			values.push(parser_value);
			
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			if (token.content == "#endif")
			{
				parser = look;
				flag_ifdef = false;
				ifdef_condition = null;
			}
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
		}
		
		list res = static::matchToken(parser, "]"); parser = res[0]; token = res[1];
		return
		[
			parser,
			new OpCollection
			{
				"values": values,
				"caret_start": caret_start,
				"caret_end": token.caret_end,
			}
		];
	}
	
	
	/**
	 * Read collection
	 */
	pure list<ParserPHP, BaseOpCode> readDict(ParserPHP parser)
	{
		ParserPHP look = null;
		CoreToken token = null;
		Vector<BaseOpCode> values = new Vector();
		BaseOpCode ifdef_condition = null;
		bool flag_ifdef = false;
		
		list res = static::matchToken(parser, "{"); parser = res[0]; token = res[1];
		Caret caret_start = token.caret_start;
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		while (not token.eof and token.content != "}")
		{
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			if (token.content == "#ifdef")
			{
				parser = look;
				parser <= find_ident <= false;
				list res = parser.parser_expression::readExpression(parser);
				parser = res[0]; ifdef_condition = res[1];
				parser <= find_ident <= true;
				list res = parser.parser_base::matchToken(parser, "then"); parser = res[0]; token = res[1];
				flag_ifdef = true;
			}
			
			BaseOpCode parser_value = null;
			list res = static::readString(parser); parser = res[0]; parser_value = res[1];
			string key = parser_value.value;
			
			list res = static::matchToken(parser, ":"); parser = res[0];
			list res = parser.parser_expression::readExpression(parser);
			parser = res[0]; parser_value = res[1];
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
			if (token.content == ",")
			{
				parser = look;
			}
			
			values.push(
				new OpDictPair{
					"key": key,
					"value": parser_value,
					"condition": ifdef_condition
				}
			);
			
			list res = parser.parser_base::readToken(parser); look = res[0]; token = res[1];
			if (token.content == "#endif")
			{
				parser = look;
				flag_ifdef = false;
				ifdef_condition = null;
			}
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
		}
		
		list res = static::matchToken(parser, "}"); parser = res[0]; token = res[1];
		return
		[
			parser,
			new OpDict
			{
				"values": values,
				"caret_start": caret_start,
				"caret_end": token.caret_end,
			}
		];
	}
	
	
	/**
	 * Read fixed
	 */
	pure list<ParserPHP, BaseOpCode> readFixed(ParserPHP parser)
	{
		ParserPHP look = null;
		CoreToken token = null;
		ParserPHP start = parser;
		Caret caret_start = parser.caret;
		bool flag_negative = false;
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "")
		{
			throw new ParserExpected("Identifier", token.caret_start, look.file_name);
		}
		
		/* Read string */
		if (token.content == "'" or token.content == '"') /* " */
		{
			return static::readString(parser);
		}
		
		/* Read Collection */
		if (token.content == "[")
		{
			return static::readCollection(parser);
		}
		
		/* Read Dict */
		if (token.content == "{")
		{
			return static::readDict(parser);
		}
		
		/* Negative number */
		if (token.content == "-")
		{
			flag_negative = true;
			parser = look;
			list res = static::readToken(look); look = res[0]; token = res[1];
		}
		
		/* Read Number */
		if (static::isNumber(token.content))
		{
			return static::readNumber(parser, flag_negative);
		}
		
		return static::readIdentifier(parser, true);
	}
	
	
	/**
	 * Read call args
	 */
	pure list<ParserPHP, Collection> readCallArgs(ParserPHP parser)
	{
		ParserPHP look = null;
		CoreToken token = null;
		Vector<BaseOpCode> items = new Vector();
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "{")
		{
			list res = static::readDict(parser); parser = res[0]; OpDict d = res[1];
			items = [ d ];
		}
		else if (token.content == "(")
		{
			list res = static::matchToken(parser, "("); parser = res[0];
			list res = static::readToken(parser); look = res[0]; token = res[1];
			while (not token.eof and token.content != ")")
			{
				ParserPHP parser_value = null;
				list res = parser.parser_expression::readExpression(parser);
				parser = res[0]; parser_value = res[1];
				items.push(parser_value);
				
				list res = static::readToken(parser); look = res[0]; token = res[1];
				if (token.content == ",")
				{
					parser = look;
					list res = static::readToken(parser); look = res[0]; token = res[1];
				}
			}
			
			list res = static::matchToken(parser, ")"); parser = res[0];
		}
		
		return [parser, items];
	}
	
	
	/**
	 * Read new instance
	 */
	pure list<ParserPHP, BaseOpCode> readNew(ParserPHP parser, bool match_new = true)
	{
		ParserPHP look = null;
		CoreToken token = null;
		BaseOpCode op_code = null;
		Caret caret_start = parser.caret;
		
		Collection<BaseOpCode> args = [];
		if (match_new)
		{
			list res = static::matchToken(parser, "new"); parser = res[0]; token = res[1];
			caret_start = token.caret_start;
		}
		list res = static::readTypeIdentifier(parser); parser = res[0]; op_code = res[1];
		
		list res = static::readToken(parser); token = res[1];
		if (token.content == "(" or token.content == "{")
		{
			list res = static::readCallArgs(parser); parser = res[0]; args = res[1];
		}
		
		return
		[
			parser,
			new OpNew
			{
				"args": args,
				"value": op_code,
				"caret_start": caret_start,
				"caret_end": parser.caret,
			}
		];
	}
	
	
	/**
	 * Read dynamic identifier
	 */
	BaseOpCode readItem(TokenReader reader)
	{
		if (Caret::isNumber(reader.nextToken()))
		{
			return this.readNumber(reader);
		}
		return this.readIdentifier(reader);
	}
	
	
	/**
	 * Read dynamic
	 */
	pure list<ParserPHP, BaseOpCode> readDynamic(ParserPHP parser, int dynamic_flags = -1)
	{
		ParserPHP look = null;
		CoreToken token = null;
		Collection<BaseOpCode> parser_items = null;
		BaseOpCode op_code = null
		BaseOpCode op_code_first = null;
		bool is_await = false;
		bool is_context_call = true;
		Caret caret_start = null;
		
		/* Dynamic flags */
		int flag_call = 1;
		int flag_attr = 2;
		int flag_static = 4;
		int flag_dynamic = 8;
		
		fn f_next = bool (string s) use (dynamic_flags)
		{
			if (dynamic_flags & 1 == 1)
			{
				if (s == "{" or s == "(" or s == "@") return true;
			}
			if (dynamic_flags & 2 == 2)
			{
				if (s == ".") return true;
			}
			if (dynamic_flags & 4 == 4)
			{
				if (s == "::") return true;
			}
			if (dynamic_flags & 8 == 8)
			{
				if (s == "[") return true;
			}
			return false;
		}
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "await")
		{
			caret_start = token.caret_start;
			is_await = true;
			parser = look;
		}
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (token.content == "@")
		{
			list res = static::readToken(look);
			ParserPHP look2 = res[0]; CoreToken token2 = res[1];
			if (not f_next(token2.content))
			{
				if (static::isIdentifier(token2.content))
				{
					parser = look;
					is_context_call = false;
				}
			}
		}
		list res = static::readBaseItem(parser); parser = res[0]; op_code = res[1];
		
		op_code_first = op_code;
		if (caret_start == null) caret_start = op_code.caret_start;
		if (
			op_code instanceof OpIdentifier and
			(
				op_code.kind == OpIdentifier::KIND_CONTEXT or
				op_code.kind == OpIdentifier::KIND_SYS_FUNCTION
			)
		)
		{
			is_context_call = false;
		}
		
		list res = static::readToken(parser); look = res[0]; token = res[1];
		if (f_next(token.content))
		{
			if (op_code instanceof OpIdentifier)
			{
				if (
					parser.find_ident and
					op_code.kind != OpIdentifier::KIND_SYS_TYPE and
					op_code.kind != OpIdentifier::KIND_SYS_FUNCTION and
					op_code.kind != OpIdentifier::KIND_VARIABLE and
					op_code.kind != OpIdentifier::KIND_CLASS and
					op_code.kind != OpIdentifier::KIND_CLASSREF and
					op_code.kind != OpIdentifier::KIND_CONTEXT
				)
				{
					throw new ParserExpected
					(
						"Module or variable '" ~ op_code.value ~ "'",
						op_code.caret_start, parser.file_name
					);
				}
			}
			else if (op_code instanceof OpNew or op_code instanceof OpCollection or op_code instanceof OpDict){}
			else
			{
				throw new ParserExpected
				(
					"Module or variable",
					op_code.caret_start
					parser.file_name
				);
			}
		}
		
		/* If is pipe */
		if (parser.is_pipe and op_code instanceof OpIdentifier)
		{
			op_code = new OpAttr
			{
				"kind": parser.pipe_kind,
				"obj": new OpIdentifier
				{
					"kind": OpIdentifier::KIND_PIPE,
					"caret_start": op_code.caret_start,
					"caret_end": op_code.caret_end,
				},
				"value": op_code,
				"caret_start": op_code.caret_start,
				"caret_end": op_code.caret_end,
			};
		}
		
		while (not token.eof and f_next(token.content))
		{
			string token_content = token.content;
			
			/* Static call */
			if (token_content == "(" or token_content == "{" or token_content == "@")
			{
				if (dynamic_flags & flag_call != flag_call)
				{
					throw new ParserError
					(
						"Call are not allowed",
						token.caret_start, parser.file_name
					);
				}
				
				if (token_content == "@")
				{
					parser = look;
					is_context_call = false;
				}
				
				list res = static::readCallArgs(parser); parser = res[0]; parser_items = res[1];
				op_code = new OpCall
				{
					"obj": op_code,
					"args": parser_items,
					"caret_start": caret_start,
					"caret_end": parser.caret,
					"is_await": is_await,
					"is_context": is_context_call,
				};
				is_context_call = true;
			}
			
			/* Object access */
			else if (token_content == "." or token_content == "::" or token_content == "[")
			{
				string kind = "";
				Vector<BaseOpCode> look_values = null;
				BaseOpCode look_value = null;
				parser = look;
				is_context_call = true;
				
				if (token_content == ".")
				{
					kind = OpAttr::KIND_ATTR;
					if (dynamic_flags & flag_attr != flag_attr)
					{
						throw new ParserError
						(
							"Attr are not allowed",
							token.caret_start, parser.file_name
						);
					}
				}
				else if (token_content == "::")
				{
					kind = OpAttr::KIND_STATIC;
					if (dynamic_flags & flag_static != flag_static)
					{
						throw new ParserError
						(
							"Static attr are not allowed",
							token.caret_start, parser.file_name
						);
					}
				}
				else if (token_content == "[")
				{
					kind = OpAttr::KIND_DYNAMIC;
					if (dynamic_flags & flag_dynamic != flag_dynamic)
					{
						throw new ParserError
						(
							"Dynamic attr are not allowed",
							token.caret_start, parser.file_name
						);
					}
				}
				
				if (token_content == "[")
				{
					list res = parser.parser_expression::readExpression(parser);
					parser = res[0]; look_value = res[1];
					
					list res = static::readToken(parser); look = res[0]; token = res[1];
					if (token.content == ",")
					{
						look_values = new Vector();
						look_values.push(look_value);
					}
					while (token.content == ",")
					{
						parser = look;
						list res = parser.parser_expression::readExpression(parser);
						parser = res[0]; look_value = res[1];
						look_values.push(look_value);
						list res = static::readToken(parser); look = res[0]; token = res[1];
					}
					
					list res = static::matchToken(parser, "]"); parser = res[0];
					if (look_values != null)
					{
						kind = OpAttr::KIND_DYNAMIC_ATTRS;
					}
				}
				else
				{
					list res = static::readToken(parser); look = res[0]; token = res[1];
					if (token.content == "@")
					{
						parser = look;
						is_context_call = false;
					}
					list res = static::readIdentifier(parser); parser = res[0]; look_value = res[1];
				}
				
				op_code = new OpAttr
				{
					"kind": kind,
					"obj": op_code,
					"attrs": look_values != null ? look_values : null,
					"value": look_values == null ? look_value : null,
					"caret_start": caret_start,
					"caret_end": parser.caret,
				};
			}
			else
			{
				throw new ParserExpected("Next attr", token.caret_start, parser.file_name);
			}
			
			list res = static::readToken(parser); look = res[0]; token = res[1];
			if
			(
				op_code instanceof OpAttr and op_code.kind == OpAttr::KIND_PIPE and
				token.content != "(" and token.content != "{"
			)
			{
				throw new ParserExpected("Call", token.caret_start, parser.file_name);
			}
			
		}
		
		return [parser, op_code];
	}
}