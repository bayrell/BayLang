/*!
 *  Bayrell Common Languages Transcompiler
 *
 *  (c) Copyright 2016-2018 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayrellLang;

use BayrellRtl.Lib.rs;
use BayrellLang.OpCodes.BaseOpCode;
use BayrellParser.ParserToken;
use BayrellParser.CoreParser;


export class CommonParser extends CoreParser{
	
	
	protected BaseOpCode _result = null;
	
	
	
	/**
	 * Return true if char is alfa symbol
	 * @param char ch
	 * @return boolean
	 */
	bool isSymbolChar (char ch){
		return rs::strpos('qazwsxedcrfvtgbyhnujmikolp', rs::strtolower(ch)) !== -1;
	}
	
	
	
	/**
	 * Return true if char is number
	 * @param char ch
	 * @return boolean
	 */
	bool isNumChar (char ch){
		return rs::strpos('0123456789', ch) !== -1;
	}
	
	
	
	/**
	 * Return true if string is alfa string
	 * @param string ch
	 * @return boolean
	 */
	bool isSymbolString (string s){
		int sz = rs::strlen(s);
		for (var i=0; i<sz; i++){
			if (not this.isSymbolChar(s[i]))
				return false;
		}
		return true;
	}
	
	
	
	/**
	 * Return true if string is number
	 * @param string ch
	 * @return boolean
	 */
	bool isNumString (string s){
		int sz = rs::strlen(s);
		for (var i=0; i<sz; i++){
			if (not this.isNumChar(s[i]))
				return false;
		}
		return true;
	}
	
	
	
	/**
	 * Return true if string is alfa string
	 * @param string ch
	 * @return boolean
	 */
	bool isSymbolOrNumString (string s){
		int sz = rs::strlen(s);
		for (var i=0; i<sz; i++){
			if (not this.isAlphaChar(s[i]) and not this.isNumChar(s[i]))
				return false;
		}
		return true;
	}
	
	
	
	
	/**
	 * Return if next token is number
	 * @return boolean
	 */
	bool isNextTokenNumber(){
		return 
			this.isNumString(this.next_token.token) and 
			this.next_token.tp == ParserToken::TOKEN_BASE;
	}
	
	
	
	/**
	 * Return if next token is alfa string
	 * @return boolean
	 */
	bool isNextTokenSymbol(){
		return 
			this.isSymbolString(this.next_token.token) and 
			this.next_token.tp == ParserToken::TOKEN_BASE;
	}
	
	
	
	/**
	 * Check next string is number
	 * @return {string} number
	 */
	string matchNumber(){
		
		if (not this.isNextTokenNumber()){
			this.nextTokenExpected("number");
		}
		
		string value = this.readNextToken().token;
		if (this.findNextToken(".")){
			this.matchNextToken(".");
			
			if (not this.isNextTokenNumber()){
				this.nextTokenExpected("double");
			}
			value ~= "." ~ this.readNextToken().token;
		}
		
		return value;
	}
	
	
	
	/**
	 * Returns abstract syntax tree
	 */
	BaseOpCode getAST(){
		return this._result;
	}
	
	
	
	/**
	 * Parser function
	 */
	void runParser(){
		this._result = null;
	}
	
	
	
}