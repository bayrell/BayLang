/*!
 *  Bayrell Common Languages Transcompiler
 *
 *  (c) Copyright 2016-2018 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayrellLang;

use BayrellRtl.Lib.rs;
use BayrellParser.ParserToken;
use BayrellParser.CoreParser;
use BayrellLang.Exceptions.HexNumberExpected;
use BayrellLang.OpCodes.BaseOpCode;


export class CommonParser extends CoreParser{
	
	
	protected BaseOpCode _result = null;
	
	
	
	/**
	 * Return true if char is alfa symbol
	 * @param char ch
	 * @return boolean
	 */
	bool isLetterChar (char ch){
		return rs::strpos('qazwsxedcrfvtgbyhnujmikolp', rs::strtolower(ch)) !== -1;
	}
	
	
	
	/**
	 * Return true if char is number
	 * @param char ch
	 * @return boolean
	 */
	bool isNumChar (char ch){
		return rs::strpos('0123456789', ch) !== -1;
	}
	
	
	
	/**
	 * Return true if char is number
	 * @param char ch
	 * @return boolean
	 */
	bool isHexChar (char ch){
		return rs::strpos('0123456789abcdef', rs::strtolower(ch)) !== -1;
	}
	
	
	
	/**
	 * Return true if string is alfa string
	 * @param string ch
	 * @return boolean
	 */
	bool isLetterString (string s){
		int sz = rs::strlen(s);
		for (var i=0; i<sz; i++){
			if (not this.isLetterChar(s[i]))
				return false;
		}
		return true;
	}
	
	
	
	/**
	 * Return true if string is number
	 * @param string ch
	 * @return boolean
	 */
	bool isNumString (string s){
		int sz = rs::strlen(s);
		for (var i=0; i<sz; i++){
			if (not this.isNumChar(s[i]))
				return false;
		}
		return true;
	}
	
	
	
	/**
	 * Return true if string is number
	 * @param string ch
	 * @return boolean
	 */
	bool isHexStringBegin (string s){
		int sz = rs::strlen(s);
		if (sz < 2)
			return false;
		if (s[0] == '0' and (s[1] == 'x' or s[1] == 'X')){
			return true;
		}
		return false;
	}
	
	
	
	/**
	 * Return true if string is number
	 * @param string ch
	 * @return boolean
	 */
	bool isHexString (string s){
		int sz = rs::strlen(s);
		if (sz < 2)
			return false;
		
		if (s[0] == '0' and (s[1] == 'x' or s[1] == 'X')){
			for (var i=2; i<sz; i++){
				if (not this.isHexChar(s[i]))
					return false;
			}
			return true;
		}
		
		return false;
	}
	
	
	
	/**
	 * Return true if string is alfa string
	 * @param string ch
	 * @return boolean
	 */
	bool isSymbolOrNumString (string s){
		int sz = rs::strlen(s);
		for (var i=0; i<sz; i++){
			if (not this.isAlphaChar(s[i]) and not this.isNumChar(s[i]))
				return false;
		}
		return true;
	}
	
	
	
	
	/**
	 * Return if next token is number
	 * @return boolean
	 */
	bool isNextTokenNumber(){
		return 
			this.isNumString(this.next_token.token) and 
			this.next_token.tp == ParserToken::TOKEN_BASE;
	}
	
	
	
	/**
	 * Return if next token is number
	 * @return boolean
	 */
	bool isNextTokenHexNumber(){
		return 
			this.isHexString(this.next_token.token) and 
			this.next_token.tp == ParserToken::TOKEN_BASE;
	}
	
	
	
	/**
	 * Return if next token is alfa string
	 * @return boolean
	 */
	bool isNextTokenLetters(){
		return 
			this.isLetterString(this.next_token.token) and 
			this.next_token.tp == ParserToken::TOKEN_BASE;
	}
	
	
	
	/**
	 * Check next string is number
	 * @return {string} number
	 */
	string matchDouble(){
		
		string sign = "";
		if (this.findNextToken("+")){
			this.matchNextToken("+");
		}
		else if (this.findNextToken("-")){
			this.matchNextToken("-");
			sign = "-";
		}
		
		if (not this.isNextTokenNumber()){
			this.nextTokenExpected("number");
		}
		
		string value = this.readNextToken().token;
		if (this.findNextToken(".")){
			this.matchNextToken(".");
			
			if (not this.isNextTokenNumber()){
				this.nextTokenExpected("double");
			}
			value ~= "." ~ this.readNextToken().token;
		}
		
		return value;
	}
	
	
	
	/**
	 * Check next string is number
	 * @return {string} number
	 */
	string matchHexNumber(){
	
		string sign = "";
		if (this.findNextToken("+")){
			this.matchNextToken("+");
		}
		else if (this.findNextToken("-")){
			this.matchNextToken("-");
			sign = "-";
		}
		
		if (not this.isNextTokenHexNumber()){
			if (this.lookType() == ParserToken::TOKEN_BASE and this.isHexStringBegin(this.lookToken())){
				int start_line = this.next_token.start_line;
				int start_col = this.next_token.start_col;
				throw new HexNumberExpected(this.context(), start_line, start_col);					
			}
			else{
				this.nextTokenExpected(this.translate("ERROR_PARSER_HEX_NUMBER_EXPECTED"));
			}
		}
		
		return sign ~ this.readNextToken().token;
	}
	
	
	
	/**
	 * Returns abstract syntax tree
	 */
	BaseOpCode getAST(){
		return this._result;
	}
	
	
	
	/**
	 * Parser function
	 */
	void runParser(){
		this._result = null;
	}
	
	
	
}