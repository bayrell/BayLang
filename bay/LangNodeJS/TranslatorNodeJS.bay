/*!
 *  Bayrell Common Languages Transcompiler
 *
 *  (c) Copyright 2016-2018 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayrellLang.LangNodeJS;

use BayrellRtl.Lib.rs;
use BayrellRtl.Lib.re;
use BayrellLang.LangES6.TranslatorES6;
use BayrellLang.CommonTranslator;


export class TranslatorNodeJS extends TranslatorES6 {
	
	
	
	/**
	 * Identifier
	 */
	string OpIdentifier(OpIdentifier op_code){
		if (op_code.value == 'parent'){
			return "super";
		}
		else if (op_code.value == 'self'){
			return this.current_class_name;
		}
		
		return op_code.value;
	}
	
	
	
	/**
	 * Use
	 */
	string OpUse(OpUse op_code){
		
		string res = "";
		string lib_name = op_code.value;
		string var_name = "m_" ~ re::replace("\\.", "_", lib_name);
		
		array arr1 = rs::explode(".", lib_name);
		array arr2 = rs::explode(".", this.current_namespace);
		int sz_arr1 = arr1.count();
		int sz_arr2 = arr2.count();
		
		if (sz_arr1 < 2)
			return "";
		
		string class_name = arr1.getLastItem();
		
		/* If same modules */
		if (arr1.item(0) == arr2.item(0)){
			int pos = 0;
			while (pos < sz_arr1 and pos < sz_arr2 and arr1.item(pos) == arr2.item(pos)){
				pos++;
			}
			
			string js_path = "";
			if (pos == arr2.count()){
				js_path = "./";
			}
			else{
				for (int j=pos; j<sz_arr2; j++){
					js_path = js_path ~ "../";
				}
			}
			
			string ch = "";
			for (int j=pos; j<sz_arr1; j++){
				js_path = js_path ~ ch ~ arr1.item(j);
				ch = "/";
			}
			
			string module_name = arr1.shift();
			string module_path = rs::implode(".", arr1);
			
			js_path = js_path ~ ".js";
			res = "var " ~ class_name ~ " = require('" ~ js_path ~ "');";
		}
		
		/* If different modules */
		else{
			string module_name = arr1.shift();
			string module_path = rs::implode(".", arr1);
			res = "var " ~ class_name ~ " = require('" ~ module_name ~ "')." ~ module_path ~ ";";
		}
		
		return res;
	}
	
	
	/**
	 * Class declare header
	 */
	string OpClassDeclareHeader(OpClassDeclare op_code){
		string res = "";
		
		this.beginOperation();
		res ~= "class " ~ op_code.class_name;
		if (op_code.class_extends != ""){
			res ~= " extends " ~ this.translateRun(op_code.class_extends);
		}
		if (op_code.class_implements != null and op_code.class_implements.count() > 0){
			res ~= " implements " ~ rs::implode(", ", op_code.class_implements);
		}
		res ~= "{";
		this.endOperation();
		this.levelInc();
		
		return res;
	}
	
	
	
	/**
	 * Class declare footer
	 */
	string OpClassDeclareFooter(OpClassDeclare op_code){
		string  res = "";
		
		for (int i=0; i<op_code.class_variables.count(); i++){
			OpAssignDeclare variable = op_code.class_variables.item(i);
			if (variable.flags != null and variable.flags.p_static == true){
				this.beginOperation();
				string s = op_code.class_name ~ "." ~ variable.name ~ " = " ~
					this.translateRun(variable.value) ~ ";";
				this.endOperation();
				res ~= this.s(s);
			}
		}
		
		res ~= this.s("module.exports = "~op_code.class_name~";");
		
		return res;
	}
	
	
}