/*!
 *  Bayrell Common Languages Transcompiler
 *
 *  (c) Copyright 2016-2018 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace BayrellLang.LangNodeJS;

use Runtime.re;
use Runtime.rs;
use BayrellLang.OpCodes.OpAssignDeclare;
use BayrellLang.OpCodes.OpIdentifier;
use BayrellLang.OpCodes.OpPreprocessorCase;
use BayrellLang.LangES6.TranslatorES6;
use BayrellLang.CommonTranslator;


export class TranslatorNodeJS extends TranslatorES6 {
	
	
	
	/**
	 * Get name
	 */
	string getName(string name){
		if (name == 'parent'){
			return "super";
		}
		else if (name == 'self'){
			return this.current_class_name;
		}
		else if (name == 'static'){
			return "this";
		}
		
		return name;
	}
	
	
	
	/**
	 * Namespace
	 */
	string OpNamespace(OpNamespace op_code){
		this.current_namespace = op_code.value;
		Vetor<string> arr = rs::explode(".", this.current_namespace);
		this.current_module_name = arr.item(0);
		this.modules.clear();
		if (this.current_module_name != 'Runtime'){
			return "var rtl = require('bayrell-runtime-nodejs').rtl;" ~
				this.s("var Map = require('bayrell-runtime-nodejs').Map;") ~
				this.s("var Vector = require('bayrell-runtime-nodejs').Vector;") ~
				this.s("var IntrospectionInfo = require('bayrell-runtime-nodejs').IntrospectionInfo;")
			;
		}
		return "";
	}
	
	
	
	/**
	 * Use
	 */
	string OpUse(OpUse op_code){
		
		string res = "";
		string lib_name = op_code.value;
		string var_name = "m_" ~ re::replace("\\.", "_", lib_name);
		
		array arr1 = rs::explode(".", lib_name);
		array arr2 = rs::explode(".", this.current_namespace);
		int sz_arr1 = arr1.count();
		int sz_arr2 = arr2.count();
		
		if (sz_arr1 < 2)
			return "";
		
		string class_name = arr1.getLastItem();
		if (op_code.alias_name != ""){
			class_name = op_code.alias_name;
		}
		
		/* Add modules */
		this.modules.set(class_name, lib_name);
		
		/* If same modules */
		if (arr1.item(0) == arr2.item(0)){
			int pos = 0;
			while (pos < sz_arr1 and pos < sz_arr2 and arr1.item(pos) == arr2.item(pos)){
				pos++;
			}
			
			string js_path = "";
			if (pos == arr2.count()){
				js_path = "./";
			}
			else{
				for (int j=pos; j<sz_arr2; j++){
					js_path = js_path ~ "../";
				}
			}
			
			string ch = "";
			for (int j=pos; j<sz_arr1; j++){
				js_path = js_path ~ ch ~ arr1.item(j);
				ch = "/";
			}
			
			string module_name = arr1.shift();
			string module_path = rs::implode(".", arr1);
			
			js_path = js_path ~ ".js";
			res = "var " ~ class_name ~ " = require('" ~ js_path ~ "');";
		}
		
		/* If different modules */
		else{
			string module_name = arr1.shift();
			string module_path = rs::implode(".", arr1);
			if (module_name == 'Runtime') module_name = 'BayrellRuntime';
			if (module_name == 'RuntimeWeb') module_name = 'BayrellRuntimeWeb';
			module_name = rtl::convertNodeJSModuleName(module_name);
			res = "var " ~ class_name ~ " = require('" ~ module_name ~ "')." ~ module_path ~ ";";
		}
		
		return res;
	}
	
	
	
	/**
	 * Class declare header
	 */
	string OpClassDeclareHeader(OpClassDeclare op_code){
		string res = "";
		
		this.beginOperation();
		res ~= "class " ~ op_code.class_name;
		if (op_code.class_extends != ""){
			res ~= " extends " ~ this.translateRun(op_code.class_extends);
		}
		res ~= "{";
		this.endOperation();
		this.levelInc();
		
		return res;
	}
	
	
	
	/**
	 * Class declare footer
	 */
	string OpClassDeclareFooter(OpClassDeclare op_code){
		string  res = "";
		
		/* Static variables */
		for (int i=0; i<op_code.childs.count(); i++){
			BaseOpCode variable = op_code.childs.item(i);
			if (not (variable instanceof OpAssignDeclare))
				continue;
			if (variable.flags != null and (variable.isFlag('static') or variable.isFlag('const'))){
				this.beginOperation();
				string s = op_code.class_name ~ "." ~ variable.name ~ " = " ~
					this.translateRun(variable.value) ~ ";";
				this.endOperation();
				res ~= this.s(s);
			}
		}
		
		
		/* Static implements */
		Vector<string> class_implements = op_code.class_implements;
		if (class_implements != null and class_implements.count() > 0){
			string name = op_code.class_name;
			res ~= this.s( name ~ ".__static_implements__ = [];" );
			for (int i=0; i<class_implements.count(); i++){
				string value = class_implements.item(i);
				res ~= this.s( name ~ ".__static_implements__.push(" ~ this.getName(value) ~ ")" );
			}
		}
		
		res ~= this.s("module.exports = "~op_code.class_name~";");
		
		return res;
	}
	
	
	
	/**
	 * Class declare footer
	 */
	string OpClassDeclareFooterNew(OpClassDeclare op_code){
		
		string ch = "";
		string res = "";
		string current_namespace = "";
		
		Vector<string> v = rs::explode(".", this.current_namespace);
		res ~= this.s("module.exports = {};");
		
		for (int i=0; i<v.count(); i++){
			if (i == 0)
				continue;
			current_namespace ~= ch ~ v.item(i);
			s = "if (typeof module.exports."~current_namespace~" == 'undefined') "~
				"module.exports."~current_namespace~" = {};";
			res ~= this.s(s);
			ch = ".";
		}
		
		if (current_namespace == "") current_namespace = "module.exports";
		else current_namespace = "module.exports." ~ current_namespace;
		res ~= this.s( current_namespace ~ "." ~ op_code.class_name ~ " = " ~ op_code.class_name );
		
		for (int i=0; i<op_code.class_variables.count(); i++){
			OpAssignDeclare variable = op_code.class_variables.item(i);
			if (variable.flags != null and variable.flags.p_static == true){
				this.beginOperation();
				string s = current_namespace ~ "." ~ op_code.class_name ~ "." ~ variable.name ~ " = " ~
					this.translateRun(variable.value) ~ ";";
				this.endOperation();
				res ~= this.s(s);
			}
		}
		
		
		/* Static implements */
		Vector<string> class_implements = op_code.class_implements;
		if (class_implements != null and class_implements.count() > 0){
			string name = op_code.class_name;
			res ~= this.s( current_namespace ~ "." ~ name ~ ".__static_implements__ = [];" );
			for (int i=0; i<class_implements.count(); i++){
				string value = class_implements.item(i);
				res ~= this.s(
					current_namespace ~ "." ~ name ~ 
						".__static_implements__.push(" ~ this.getName(value) ~ ")" 
				);
			}
		}
		
		return res;
	}
	
	
	
	/**
	 * Calc preprocessor condition
	 */
	bool calcPreprocessorCondition(OpPreprocessorCase op_case){
		if (op_case.condition instanceof OpIdentifier){
			if (op_case.condition.value == "JAVASCRIPT" or op_case.condition.value == "NODEJS"){
				return true;
			}
		}
		return false;
	}
	
}