/*!
 *  Bayrell Common Languages Transcompiler
 *
 *  (c) Copyright 2016-2017 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace bayrell_lang;
use bayrell_rtl import BayrellError, BayrellObject, rtl;
use .BayrellCode import BayrellCode;
use .BayrellInterpreter import BayrellInterpreter;



export class BayrellTranslator extends BayrellObject {
	
	protected string _indent = "";
	protected string _clr = "";
	
	
	string getClassName(){
		return "bayrell_lang.BayrellTranslator";
	}
	
	void constructor (){
		this._indent = rtl::INDENT;
		this._clr = rtl::CLR;
	}
	
	
	void setIndent(string val){
		this._indent = val;
	}
	
	void getIndent(){
		return this._indent;
	}
	
	void setClr(string val){
		this._clr = val;
	}
	
	void getClr(){
		return this._clr;
	}
	
	
	BayrellInterpreter createInterpreter(){
		BayrellInterpreter runtime = new BayrellInterpreter();
		runtime.addData({
			'BAYRELL': false,
			'JAVASCRIPT': false,
			'NODEJS': false,
			'ES5': false,
			'ES6': false,
			'PHP': false,
			'PYTHON': false,
			'LUA': false,
			'CPP': false,
			'JAVA': false,
			'CSHARP': false,
		});
		return runtime;
	}
	
	string out(string s, int level){
		return rtl::str_repeat(this._indent, level) ~ s ~ this._clr;
	}
	
	
	static bool isJsonChilds(array childs){
		int sz = rtl::count(childs);
		for (int i=0;i<sz;i++){
			json code_tree = childs[i];
			
			if (
				rtl::in_array( 
					code_tree['op'], 
					[
						BayrellCode::OP_ARRAY,
						BayrellCode::OP_JSON,
					] 
				)
			){
				return true;
			}
			
		}
		return false;
	}
	
	
	/* Операторы */
	string op_nope(json code_tree, int level){
		var _res = '';
		var i = 0;
		array arr = link code_tree['arr'];
		int sz = rtl::count(arr);
		while (i < sz){
			var code = arr[i];
			if (code != null)
				_res = _res ~ this.run(code, level);
			i = i + 1;
		}
		return _res;
	}
	
	string op_namespace(json code_tree, int level){
		return "";
	}
	
	string op_use(json code_tree, int level){
		return "";
	}
	
	string op_comment(json code_tree, int level){
		return "";
	}
	
	string op_assign(json code_tree, int level){
		return "";
	}
	
	string op_assign_inc(json code_tree, int level){
		return "";
	}
	
	string op_assign_dec(json code_tree, int level){
		return "";
	}
	
	string op_assign_concat(json code_tree, int level){
		return "";
	}
	
	string op_declare_var(json code_tree, int level){
		return "";
	}
	
	string op_declare_func(json code_tree, int level){
		return "";
	}
	
	string op_declare_class(json code_tree, int level){
		return "";
	}
	
	string op_ret(json code_tree, int level){
		return "";
	}
	
	string op_if(json code_tree, int level){
		return "";
	}
	
	string op_while(json code_tree, int level){
		return "";
	}
	
	string op_for(json code_tree, int level){
		return "";
	}
	
	string op_foreach(json code_tree, int level){
		return "";
	}
	
	string op_throw(json code_tree, int level){
		return "";
	}
	
	string op_break(json code_tree, int level){
		return "";
	}
	
	string op_continue(json code_tree, int level){
		return "";
	}
	
	string op_call_func(json code_tree, int level){
		return "";
	}
	
	/* Операции */
	string op_calc(json code_tree, int level){
		return "";
	}
	
	string op_calc_nope(json code_tree, int level){
		return "";
	}
	
	string op_fixed(json code_tree, int level){
		return "";
	}
	
	string op_string(json code_tree, int level){
		return "";
	}
	
	string op_json(json code_tree, int level){
		return "";
	}
	
	string op_array(json code_tree, int level){
		return "";
	}
	
	string op_load(json code_tree, int level){
		return "";
	}
	
	string op_load_names(json code_tree, int level){
		return "";
	}
	
	string op_load_names_calc(json code_tree, int level){
		return "";
	}
	
	string op_load_arr(json code_tree, int level){
		return "";
	}
	
	string op_load_static(json code_tree, int level){
		return "";
	}
	
	string op_load_dynamic(json code_tree, int level){
		return "";
	}
	
	string op_clone(json code_tree, int level){
		return "";
	}
	
	string op_link(json code_tree, int level){
		return "";
	}
	
	string op_new(json code_tree, int level){
		return "";
	}
	
	string op_del(json code_tree, int level){
		return "";
	}
	
	string op_neg(json code_tree, int level){
		return "";
	}
	
	string op_add(json code_tree, int level){
		return "";
	}
	
	string op_sub(json code_tree, int level){
		return "";
	}
	
	string op_mult(json code_tree, int level){
		return "";
	}
	
	string op_div(json code_tree, int level){
		return "";
	}
	
	string op_mod(json code_tree, int level){
		return "";
	}
	
	string op_not(json code_tree, int level){
		return "";
	}
	
	string op_or(json code_tree, int level){
		return "";
	}
	
	string op_and(json code_tree, int level){
		return "";
	}
	
	string op_pow(json code_tree, int level){
		return "";
	}
	
	string op_pre_inc(json code_tree, int level){
		return "";
	}
	
	string op_pre_dec(json code_tree, int level){
		return "";
	}
	
	string op_post_inc(json code_tree, int level){
		return "";
	}
	
	string op_post_dec(json code_tree, int level){
		return "";
	}
	
	string op_inc(json code_tree, int level){
		return "";
	}
	
	string op_dec(json code_tree, int level){
		return "";
	}
	
	string op_call(json code_tree, int level){
		return "";
	}
	
	string op_cmp(json code_tree, int level){
		return "";
	}
	
	string op_instanceof(json code_tree, int level){
		return "";
	}
	
	string op_ternary(json code_tree, int level){
		return "";
	}
	
	string op_concat(json code_tree, int level){
		return "";
	}
	
	string op_directive_ifcode(json code_tree, int level){
		BayrellInterpreter runtime = this.createInterpreter();
		json expr = code_tree['expr'];
		
		runtime.run(expr);
		var _res = runtime.getRegister(0);
		
		if (_res)
			return this.out(rtl::trim(code_tree.code_str), level);
		
		return "";
	}
	
	
	/* Поехали */
	string run(json code_tree, int level){
		string _res = '';
		
		if (!rtl::exists(code_tree))
			return "";
		
		bool is_json = rtl::is_json(code_tree);
		bool is_array = rtl::is_array(code_tree);
		
		if (!is_json and !is_array)
			return "";
		
		string op = rtl::attr(code_tree, 'op');
		
		if (is_json and op == BayrellCode::OP_NOPE){
			_res = this.op_nope(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_USE){
			_res = this.op_use(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_NAMESPACE){
			_res = this.op_namespace(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_COMMENT){
			_res = this.op_comment(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_CALC){
			_res = this.op_calc(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_CALC_NOPE){
			_res = this.op_calc_nope(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_FIXED){
			_res = this.op_fixed(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_STRING){
			_res = this.op_string(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_JSON){
			_res = this.op_json(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_ARRAY){
			_res = this.op_array(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_LOAD){
			_res = this.op_load(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_LOAD_NAMES){
			_res = this.op_load_names(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_LOAD_NAMES_CALC){
			_res = this.op_load_names_calc(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_LOAD_ARR){
			_res = this.op_load_arr(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_LOAD_STATIC){
			_res = this.op_load_static(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_LOAD_DYNAMIC){
			_res = this.op_load_dynamic(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_CLONE){
			_res = this.op_clone(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_LINK){
			_res = this.op_link(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_NEW){
			_res = this.op_new(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_DEL){
			_res = this.op_del(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_NEG){
			_res = this.op_neg(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_ADD){
			_res = this.op_add(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_SUB){
			_res = this.op_sub(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_MULT){
			_res = this.op_mult(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_DIV){
			_res = this.op_div(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_MOD){
			_res = this.op_mod(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_NOT){
			_res = this.op_not(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_AND){
			_res = this.op_and(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_OR){
			_res = this.op_or(code_tree, level);
		}		
		else if (is_json and op == BayrellCode::OP_CONCAT){
			_res = this.op_concat(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_POW){
			_res = this.op_pow(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_PRE_INC){
			_res = this.op_pre_inc(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_PRE_DEC){
			_res = this.op_pre_dec(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_POST_INC){
			_res = this.op_post_inc(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_POST_DEC){
			_res = this.op_post_dec(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_INC){
			_res = this.op_inc(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_DEC){
			_res = this.op_dec(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_CALL){
			_res = this.op_call(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_RET){
			_res = this.op_ret(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_DECLARE_VAR){
			_res = this.op_declare_var(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_DECLARE_FUNC){
			_res = this.op_declare_func(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_DECLARE_CLASS){
			_res = this.op_declare_class(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_ASSIGN){
			_res = this.op_assign(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_TERNARY){
			_res = this.op_ternary(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_ASSIGN_INC){
			_res = this.op_assign_inc(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_ASSIGN_DEC){
			_res = this.op_assign_dec(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_ASSIGN_CONCAT){
			_res = this.op_assign_concat(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_IF){
			_res = this.op_if(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_WHILE){
			_res = this.op_while(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_FOR){
			_res = this.op_for(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_FOREACH){
			_res = this.op_foreach(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_THROW){
			_res = this.op_throw(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_BREAK){
			_res = this.op_break(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_CONTINUE){
			_res = this.op_continue(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_CMP){
			_res = this.op_cmp(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_INSTANCEOF){
			_res = this.op_instanceof(code_tree, level);
		}
		else if (is_json and op == BayrellCode::OP_DIRECTIVE_IFCODE){
			_res = this.op_directive_ifcode(code_tree, level);
		}
		
		else if (rtl::is_array(code_tree)){
			int i = 0;
			int sz = rtl::count(code_tree);
			while (i < sz){
				var code = code_tree[i];
				if (code != null)
					_res = _res ~ this.run(code, level);
				i = i + 1;
			}
		}
		
		return _res;
	}
	
	
	string translate(json code_tree){
		var _res = this.run(code_tree, 0);
		return _res;
	}
	
}