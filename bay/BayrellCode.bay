/*!
 *  Bayrell Common Languages Transcompiler
 *
 *  (c) Copyright 2016-2017 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.bayrell.org/licenses/APACHE-LICENSE-2.0.html
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
 
namespace bayrell_lang;
use bayrell_rtl import rtl;


export class BayrellCode{
	
	string getClassName(){
		return "bayrell_lang.BayrellCode";
	}
	
	/* Операции */
	static const string OP_NOPE = 'nope';
	static const string OP_CALC_NOPE = 'calc_nope';
	static const string OP_OPERATOR = 'op';
	static const string OP_COMMENT = 'comment';
	static const string OP_FIXED = 'fix';
	static const string OP_STRING = 'string';
	static const string OP_ARRAY = 'array';
	static const string OP_JSON = 'json';
	static const string OP_LOAD = 'load';
	static const string OP_LOAD_ARR = 'load_arr';
	static const string OP_LOAD_STATIC = 'op_load_static';
	static const string OP_LOAD_DYNAMIC = 'op_load_dynamic';
	static const string OP_LOAD_NAMES = 'op_load_names';
	static const string OP_LOAD_NAMES_CALC = 'op_load_names_calc';
	static const string OP_NOT = 'not';
	static const string OP_CLONE = 'clone';
	static const string OP_LINK = 'link';
	static const string OP_NEW = 'new';
	static const string OP_DEL = 'del';
	static const string OP_COPY = 'copy';
	static const string OP_NEG = 'neg';
	static const string OP_ADD = 'add';
	static const string OP_SUB = 'sub';
	static const string OP_MULT = 'mult';
	static const string OP_DIV = 'div';
	static const string OP_MOD = 'mod';
	static const string OP_POW = 'pow';
	static const string OP_AND = 'and';
	static const string OP_OR = 'or';
	static const string OP_PRE_INC = 'pre_inc';
	static const string OP_PRE_DEC = 'pre_dec';
	static const string OP_POST_INC = 'post_inc';
	static const string OP_POST_DEC = 'post_dec';
	static const string OP_INC = 'inc';
	static const string OP_DEC = 'dec';
	static const string OP_CONCAT = 'concat';

	/* Операторы */
	static const string OP_CALL = 'call';
	static const string OP_CALC = 'calc';
	static const string OP_RET = 'ret';
	static const string OP_CMP = 'cmp';
	static const string OP_INSTANCEOF = 'instanceof';
	static const string OP_DECLARE_VAR = 'var';
	static const string OP_DECLARE_FUNC = 'func';
	static const string OP_DECLARE_CLASS = 'class';
	static const string OP_TERNARY = 'ternary';
	static const string OP_ASSIGN = 'assign';
	static const string OP_ASSIGN_ARR = 'assign_arr';
	static const string OP_ASSIGN_INC = 'assign_inc';
	static const string OP_ASSIGN_DEC = 'assign_dec';
	static const string OP_ASSIGN_CONCAT = 'assign_concat';
	static const string OP_IF = 'if';
	static const string OP_WHILE = 'while';
	static const string OP_FOR = 'for';
	static const string OP_FOREACH = 'foreach';
	static const string OP_THROW = 'throw';
	static const string OP_BREAK = 'break';
	static const string OP_CONTINUE = 'continue';
	static const string OP_NAMESPACE = 'namespace';
	static const string OP_PACKAGE = 'package';
	static const string OP_USE = 'use';
	
	/* Директивы */
	static const string OP_DIRECTIVE_IFCODE = 'ifcode';
	
	/* список зарезервированных слов */
	static const array ReservedWords = [
		'for', 'if', 'while', 'foreach', 'class', 'dict', 'int', 'int64', 'int32', 'float', 
		'bool', 'boolean', 'func', 'def', 'function', 'void', 'export', 'ifdef', 'define', 'use', 
		'as', 'import', 'from', 'async', 'await', 'call', 'module', 'namespace', 'using', 'try', 
		'catch', 'declare', 'forward', 'list', 'array', 'json', 'var', 'include', 'require',
		'str', 'static', 'const', 'default', 'result'
	];
	
	/* список зарезервированных слов в PHP */
	static const array PHP_RTL_FUNC = [
		'var_dump', 'ord', 'trim', 'strlen', 'str_repeat', 'strpos',
		'strfind', 'strtoupper', 'substr', 'base64_encode', 'base64_decode',
		'json_decode_ex', 'json_encode', 'explode', 'implode', 
		'preg_replace', 'preg_match', 'time', 'microtime', 'array_reverse',
		'array_sort', 'array_pop', 'array_push', 'array_merge', 'count', 
		'is_array', 'is_string', 'is_json', 'is_numeric', 'gettype', 
		'isset', 'in_array', 'rand', 'mt_rand', 'dirname',
		'file_get_contents', 'file_put_contents', 'file_exists', 
		'filemtime', 'mkdir', 'strtolower', 'key_exists'
	];
	
	/* Операции */
	static json op_comment (string value){
		return {'op': BayrellCode::OP_COMMENT,'str': value};
	}
	static json op_calc (array childs){
		return {'op': BayrellCode::OP_CALC,'childs': childs};
	}
	static json op_calc_nope (array childs){
		return {'op': BayrellCode::OP_CALC_NOPE,'childs': childs};
	}
	static json op_fixed (string value){
		return {'op': BayrellCode::OP_FIXED,'str': value};
	}
	static json op_string (string value){
		return {'op': BayrellCode::OP_STRING,'str': value};
	}
	static json op_array (array values){
		return {'op': BayrellCode::OP_ARRAY,'values': values};
	}
	static json op_json (json obj){
		return {'op': BayrellCode::OP_JSON,'obj': obj};
	}
	static json op_load (string str_name){
		return {'op': BayrellCode::OP_LOAD,'str_name': str_name};
	}
	static json op_load_names (array arr){
		return {'op': BayrellCode::OP_LOAD_NAMES,'arr': arr};
	}
	static json op_load_names_calc (array arr){
		return {'op': BayrellCode::OP_LOAD_NAMES_CALC,'arr': arr};
	}
	static json op_load_arr (json pos){
		return {'op': BayrellCode::OP_LOAD_ARR, 'pos': pos};
	}
	static json op_load_static (string str_name){
		return {'op': BayrellCode::OP_LOAD_STATIC,'str_name': str_name};
	}
	static json op_load_dynamic (string str_name){
		return {'op': BayrellCode::OP_LOAD_DYNAMIC,'str_name': str_name};
	}
	static json op_clone (json value){
		return {'op': BayrellCode::OP_CLONE,'value': value};
	}
	static json op_link (json value){
		return {'op': BayrellCode::OP_LINK,'value': value};
	}
	static json op_new (json value){
		return {'op': BayrellCode::OP_NEW,'value': value};
	}
	static json op_del (json value){
		return {'op': BayrellCode::OP_DEL,'value': value};
	}
	static json op_neg (json value){
		return {'op': BayrellCode::OP_NEG,'value': value};
	}
	static json op_add (json value){
		return {'op': BayrellCode::OP_ADD,'value': value};
	}
	static json op_sub (json value){
		return {'op': BayrellCode::OP_SUB,'value': value};
	}
	static json op_mult (json value){
		return {'op': BayrellCode::OP_MULT,'value': value};
	}
	static json op_div (json value){
		return {'op': BayrellCode::OP_DIV,'value': value};
	}
	static json op_mod (json value){
		return {'op': BayrellCode::OP_MOD,'value': value};
	}
	static json op_not (json value){
		return {'op': BayrellCode::OP_NOT,'value': value};
	}
	static json op_pow (json value){
		return {'op': BayrellCode::OP_POW,'value': value};
	}
	static json op_and (json value){
		return {'op': BayrellCode::OP_AND,'value': value};
	}
	static json op_or (json value){
		return {'op': BayrellCode::OP_OR, 'value': value};
	}
	static json op_ternary (json expr, json expr_true, json expr_false){
		return {'op': BayrellCode::OP_TERNARY, 'expr':expr, 'expr_true':expr_true, 'expr_false':expr_false};
	}
	static json op_cmp (string cond, json left, json right){
		return {'op': BayrellCode::OP_CMP, 'cond':cond, 'left':left, 'right':right};
	}
	static json op_instanceof (string cond, json left, json right){
		return {'op': BayrellCode::OP_INSTANCEOF, 'cond':cond, 'left':left, 'right':right};
	}
	static json op_pre_inc (json value){
		return {'op': BayrellCode::OP_PRE_INC, 'value': value};
	}
	static json op_pre_dec (json value){
		return {'op': BayrellCode::OP_PRE_DEC, 'value': value};
	}
	static json op_post_inc (json value){
		return {'op': BayrellCode::OP_POST_INC, 'value': value};
	}
	static json op_post_dec (json value){
		return {'op': BayrellCode::OP_POST_DEC, 'value': value};
	}
	static json op_inc (json value){
		return {'op': BayrellCode::OP_INC, 'value': value};
	}
	static json op_dec (json value){
		return {'op': BayrellCode::OP_DEC, 'value': value};
	}
	static json op_concat (json value){
		return {'op': BayrellCode::OP_CONCAT, 'value': value};
	}
	
	/* Операторы */
	static json op_nope(array arr){
		return {'op': BayrellCode::OP_NOPE,'arr': arr};
	}
	static json op_call (array args){
		return {'op': BayrellCode::OP_CALL,'args':args};
	}
	static json op_ret (json value){
		return {'op': BayrellCode::OP_RET,'value': value};
	}
	static json op_assign (json name, json value){
		return {'op': BayrellCode::OP_ASSIGN,'name':name,'value':value};
	}
	static json op_assign_inc (json name, json value){
		return {'op': BayrellCode::OP_ASSIGN_INC,'name':name,'value':value};
	}
	static json op_assign_dec (json name, json value){
		return {'op': BayrellCode::OP_ASSIGN_DEC,'name':name,'value':value};
	}
	static json op_assign_concat (json name, json value){
		return {'op': BayrellCode::OP_ASSIGN_CONCAT,'name':name,'value':value};
	}
	static json op_if (json expr, array childs_true, array childs_false, array else_if){
		return {'op': BayrellCode::OP_IF,'expr':expr,'childs_true':childs_true,'childs_false':childs_false, 'else_if': else_if};
	}
	static json op_while (json expr, array childs){
		return {'op': BayrellCode::OP_WHILE,'expr':expr, 'childs':childs};
	}
	static json op_for (json loop_init, json loop_expression, json loop_inc, array childs){
		return {'op': BayrellCode::OP_FOR,'init':loop_init,'inc':loop_inc,'expr':loop_expression,'childs':childs};
	}
	static json op_foreach (string key_type, string key_name, string value_type, string value_name, json name, array childs){
		return {'op': BayrellCode::OP_FOREACH,'key_type':key_type,'key_name':key_name,
		'value_type':value_type,'value_name':value_name,'name':name,'childs':childs};
	}
	static json op_throw (json value){
		return {'op': BayrellCode::OP_THROW,'value':value};
	}
	static json op_break (){
		return {'op': BayrellCode::OP_BREAK};
	}
	static json op_continue (){
		return {'op': BayrellCode::OP_CONTINUE};
	}
	static json op_namespace (string name){
		return {'op': BayrellCode::OP_NAMESPACE, 'str_name': name};
	}
	static json op_package (string name){
		return {'op': BayrellCode::OP_PACKAGE, 'str_name': name};
	}
	static json op_use (string name, array arr){
		return {'op': BayrellCode::OP_USE, 'str_name': name, 'arr': arr};
	}
	

	/* Объявление переменных */
	static json op_declare_var (string name, json type, json value, json flags){
		return {'op': BayrellCode::OP_DECLARE_VAR,'str_name':name,'value':value,'type':type, 'flags': flags};
	}
	static json op_declare_func (string name, json type, array args, array childs, json flags){
		return {'op': BayrellCode::OP_DECLARE_FUNC,'str_name':name,'args':args,'childs':childs, 'type':type, 'flags': flags};
	}
	static json op_declare_class (string name, string extend_name, array childs, json flags){
		return {'op': BayrellCode::OP_DECLARE_CLASS,'str_name':name, 'extend_name': extend_name, 'childs':childs, 'flags': flags};
	}
	
	
	/* Процессорные директивы */
	static json op_ifcode(json expr, string code_str){
		return {'op': BayrellCode::OP_DIRECTIVE_IFCODE, 'expr':expr, 'code_str': code_str};
	}
	
	
	
	/**
	 * Патчим code_tree с помощью синонимов
	 */
	static json patchCodeTreeByAlias(json code_tree, json &aliases){
		
		if (!rtl::exists(code_tree))
			return null;
		
		bool is_json = rtl::is_json(code_tree);
		bool is_array = rtl::is_array(code_tree);
		
		if (!is_json and !is_array)
			return null;
		
		string op = rtl::attr(code_tree, 'op');
		
		if (is_json and op == BayrellCode::OP_LOAD){
			string str_name = code_tree['str_name'];
			if (rtl::key_exists(aliases, str_name)){
				code_tree = aliases[str_name];
			}
		}
		
		else if (is_json and rtl::in_array(op, [BayrellCode::OP_LOAD_NAMES, BayrellCode::OP_LOAD_NAMES_CALC])){
			array arr = &code_tree['arr'];
			int arr_sz = rtl::count(arr);
			
			if (arr_sz > 0){
			
				/* Меняем первый элемент */
				json code = &arr[0];
				if (code['op'] == BayrellCode::OP_LOAD){
					string str_name = code['str_name'];
					
					if (rtl::key_exists(aliases, str_name)){
						array arr2 = [];
						json code2 = aliases[str_name];
						
						if (code2 != null){
							
							/* Синоним существует, его код code2. Теперь его нужно поместить вместо arr[0] */
							if (code2['op'] == BayrellCode::OP_LOAD){
								arr[0]['str_name'] = code2['str_name'];
							}
							else if (rtl::in_array(code2['op'], [BayrellCode::OP_LOAD_NAMES, BayrellCode::OP_LOAD_NAMES_CALC])){
								array arr2 = code2['arr'];
								arr2 = rtl::array_merge(arr2, rtl::array_slice(arr, 1));
								
								code_tree['arr'] = arr2;
							}
							
						}
						
					}
					
				}
				
				
				array arr = &code_tree['arr'];
				int arr_sz = rtl::count(arr);
				for (int i=0;i<arr_sz;i++){
					json code = &arr[i];
					
					if (code['op'] == BayrellCode::OP_LOAD_ARR){
						code['pos'] = self::patchCodeTreeByAlias(code['pos'], aliases);
					}
					else if (code['op'] == BayrellCode::OP_CALL){
						array args = &code['args'];
						int args_sz = rtl::count(args);
						
						for (int j=0;j<args_sz;j++){
							args[j] = self::patchCodeTreeByAlias(args[j], aliases);
						}
					}
				}
				
				
			}
		}
		
		if (is_json and op == BayrellCode::OP_CALL){
			string str_name = code_tree['str_name'];
			if (rtl::key_exists(aliases, str_name)){
				code_tree = aliases[str_name];
			}
		}
		
		else if (is_json and op == BayrellCode::OP_CMP){
			code_tree['left'] = self::patchCodeTreeByAlias(code_tree['left'], aliases);
			code_tree['right'] = self::patchCodeTreeByAlias(code_tree['right'], aliases);
		}
		
		else if (is_json and op == BayrellCode::OP_TERNARY){
			code_tree['expr'] = self::patchCodeTreeByAlias(code_tree['expr'], aliases);
			code_tree['expr_false'] = self::patchCodeTreeByAlias(code_tree['expr_false'], aliases);
			code_tree['expr_true'] = self::patchCodeTreeByAlias(code_tree['expr_true'], aliases);
		}
		
		else if (is_json and rtl::key_exists(code_tree, 'childs')){
			array childs = &code_tree['childs'];
			int i = 0;
			int sz = rtl::count(childs);
			for (int i=0; i<sz; i++){
				childs[i] = self::patchCodeTreeByAlias(childs[i], aliases);
			}
		}
		
		else if (is_array){
			int i = 0;
			int sz = rtl::count(code_tree);
			for (int i=0; i<sz; i++){
				code_tree[i] = self::patchCodeTreeByAlias(code_tree[i], aliases);
			}
		}
		
		return code_tree;
	}
	
	
	
	/* Типы данных */
	static const string TYPES = [
		'int32', 'uint32', 'int64', 'uint64', 'double', 'int',  
		'string', 'array', 'var', 'json', 'pointer'
	];
	
	static const array FLAGS = ['export', 'static', 'const', 'public', 'private', 'declare', 'protected', 'pointer'];
	static const json FLAGS_OBJ = {
		'export': false,
		'static': false,
		'const': false,
		'public': false,
		'private': false,
		'protected': false,
		'declare': false,
		'pointer': false,
	};
	
	static string _ident = "  ";
	static string _crlf = "\n";
	static bool _prev_nope = false;
	static bool _minifi = false;
	
	static string out(string s, int level, bool crlf = true, bool ident = true){
		string res = "";
		
		if (ident)
			res = res + rtl::str_repeat(BayrellCode::_ident, level);
			
		res = res + s;
		
		if (crlf)
			res = res + BayrellCode::_crlf;
		
		return res;
	}
	
	static string dump_flags(json flags, int level){
		string result = BayrellCode::out('{', level, true, false);
		
		/* Флаги */
		array names = BayrellCode::FLAGS;
		int i = 0;
		int sz = rtl::count(names);
		while (i < sz){
			string name = names[i];
			if (rtl::key_exists(flags, name)){
				result = result + 
					BayrellCode::out('"' + name + '": ' + rtl::json_encode(flags[name]) + ",", level + 1);
			}
			i = i + 1;
		}
		result = result + BayrellCode::out('}', level, false);
		
		return result;
	}
	
	
	static string dump_arr(array arr, int level){
		string result = "";
		int i = 0;
		int sz = rtl::count(arr);
		while (i < sz){
			json code = arr[i];
			if (code != null){
				string res = BayrellCode::dump(code, level);
				if (res != ""){
					result = result + res + "," + BayrellCode::_crlf;
				}
			}
			i = i + 1;
		}
		return result;
	}
	
	
	static string dump(json code_tree, int level, bool ident = true){
		string result = '';
		
		if (code_tree == null){
			return "null";
		}
		
		bool old_prev_nope = BayrellCode::_prev_nope;
		BayrellCode::_prev_nope = false;
		
		if (rtl::is_array(code_tree)){
			result = BayrellCode::dump_arr(code_tree, level);
		}
		
		else if (code_tree['op'] == BayrellCode::OP_NOPE){
			BayrellCode::_prev_nope = BayrellCode::_minifi and true;
			
			if (!old_prev_nope){
				result = result + BayrellCode::out('{', level, true, ident);
				result = result + BayrellCode::out('"' + 'op' + '": '+ rtl::json_encode(code_tree['op']) +",", level + 1);
				result = result + BayrellCode::out('"' + 'childs' + '": [', level+1);
			}
			
			array childs = code_tree.childs;
			if (old_prev_nope)
				result = result + BayrellCode::dump_arr(childs, level);
			else
				result = result + BayrellCode::dump_arr(childs, level + 2);
			
			if (!old_prev_nope){
				result = result + BayrellCode::out("],", level+1);
				result = result + BayrellCode::out('}', level, false);
			}
		}
		
		else if (code_tree['op'] == BayrellCode::OP_CALC){
			result = result + BayrellCode::out('{', level, true, ident);
			result = result + BayrellCode::out('"' + 'op' + '": '+ rtl::json_encode(code_tree['op']) +",", level + 1);
			result = result + BayrellCode::out('"' + 'childs' + '": [', level+1);
			
			array childs = code_tree.childs;
			result = result + BayrellCode::dump_arr(childs, level + 2);
			
			result = result + BayrellCode::out("],", level+1);
			result = result + BayrellCode::out('}', level, false);
		}
		
		else if (code_tree['op'] == BayrellCode::OP_CALC_NOPE){
			if (!BayrellCode::_minifi){
				result = result + BayrellCode::out('{', level, true, ident);
				result = result + BayrellCode::out('"' + 'op' + '": '+ rtl::json_encode(code_tree['op']) +",", level + 1);
				result = result + BayrellCode::out('"' + 'childs' + '": [', level+1);
			}
			
			array childs = code_tree.childs;
			if (!BayrellCode::_minifi)
				result = result + BayrellCode::dump_arr(childs, level + 2);
			else
				result = result + BayrellCode::dump_arr(childs, level);
			
			if (!BayrellCode::_minifi){
				result = result + BayrellCode::out("],", level + 1);
				result = result + BayrellCode::out('}', level, false);
			}
		}
		
		else if (code_tree['op'] == BayrellCode::OP_JSON){
			result = result + BayrellCode::out('{', level, true, ident);
			result = result + BayrellCode::out('"' + 'op' + '": '+ rtl::json_encode(code_tree['op']) +",", level + 1);
			result = result + BayrellCode::out('"' + 'value' + '": ' + rtl::json_encode(code_tree['value']) + ",", level + 1);
			result = result + BayrellCode::out('}', level, false);
		}
	
		else{
			result = result + BayrellCode::out('{', level, true, ident);
			result = result + BayrellCode::out('"' + 'op' + '": '+ rtl::json_encode(code_tree['op']) +",", level + 1);
			
			/* Строки */
			array names = ['cond', 'key_type', 'key_name', 'value_type', 'value_name', 'arr_name', 'code_str', 'str_name'];
			int i = 0;
			int sz = rtl::count(names);
			while (i < sz){
				string name = names[i];
				if (rtl::key_exists(code_tree, name)){
					result = result + 
						BayrellCode::out('"' + name + '": ' + rtl::json_encode(code_tree[name]) + ",", level + 1);
				}
				i = i + 1;
			}
			
			
			/* Массивы */
			array names = ['arr', 'values', 'names', 'args', 'else_if', 'childs', 'childs_true', 'childs_false'];
			int i = 0;
			int sz = rtl::count(names);
			while (i < sz){
				string name = names[i];
				if (rtl::key_exists(code_tree, name)){
					array arr = code_tree[name];
					result = result + BayrellCode::out('"'+name+'": [', level + 1);
					result = result + BayrellCode::dump_arr(arr, level + 2);
					result = result + BayrellCode::out("],", level + 1);
				}
				i = i + 1;
			}
			
			
			/* Объекты */
			array names = ['value', 'expr', 'pos', 'expr_true', 'expr_false', 'left', 'right', 'init', 'inc', 'type', 'name'];
			int i = 0;
			int sz = rtl::count(names);
			while (i < sz){
				string name = names[i];
				if (rtl::key_exists(code_tree, name)){
					json obj = code_tree[name];
					result = result + 
						BayrellCode::out('"' + name + '": ' + 
							BayrellCode::dump(obj, level + 1, false) + ",", 
							level + 1
						);
				}
				i = i + 1;
			}
			
			if (rtl::key_exists(code_tree, 'flags')){
				result = result + 
					BayrellCode::out('"' + 'flags' + '": '+ BayrellCode::dump_flags(code_tree['flags'], level + 1) + ",", level + 1);
			}
			
			result = result + BayrellCode::out('}', level, false);
		}
		
		BayrellCode::_prev_nope = old_prev_nope;
		return result;
	}
	
	
	static boolean compare_arr(array arr1, array arr2){
		int i = 0;
		int sz1 = rtl::count(arr1);
		int sz2 = rtl::count(arr2);
		
		if (sz1 != sz2)
			return false;
		
		while (i < sz1){
			var code1 = arr1[i];
			var code2 = arr2[i];
			i = i + 1;
			
			if (!BayrellCode::compare(code1, code2))
				return false;
		}
		return true;
	}
	
	static boolean compare(json code1, json code2){
		if (code1 == null and code2 != null) return false;
		if (code1 != null and code2 == null) return false;
		if (code1 == null and code2 == null) return true;
		
		
		if (rtl::is_array(code1) and rtl::is_array(code2)){
			return BayrellCode::compare_arr(code1, code2);
		}
		
		else if (rtl::is_array(code1) and !rtl::is_array(code2)){
			return false;
		}
		
		else if (!rtl::is_array(code1) and rtl::is_array(code2)){
			return false;
		}
		
		else if (!rtl::is_json(code1) or !rtl::is_json(code2)){
			return false;
		}
		
		else if (!rtl::is_json(code1) or !rtl::is_json(code2)){
			return false;
		}
		
		else if (code1['op'] != code2['op']){
			return false;
		}
		
		else{
			
			/* Строки */
			array names = ['str', 'cond', 'key_type', 'key_name', 'value_type', 'value_name', 'arr_name', 'code_str', 'str_name'];
			int i = 0;
			int sz = rtl::count(names);
			while (i < sz){
				string name = names[i];
				i = i + 1;
				
				if (rtl::key_exists(code1, name) and rtl::key_exists(code2, name)){
					var value1 = code1[name];
					var value2 = code2[name];
					
					if (!rtl::is_string(value1) or !rtl::is_string(value2))
						return false;
					
					if (value1 != value2)
						return false;
				}
				else if (rtl::key_exists(code1, name) and !rtl::key_exists(code2, name) or !rtl::key_exists(code1, name) and rtl::exists(rtl::key_exists, name))
					return false;
			}
			
			
			
			/* Массивы */
			array names = ['arr', 'values', 'names', 'args', 'else_if', 'childs', 'true', 'false'];
			int i = 0;
			int sz = rtl::count(names);
			while (i < sz){
				string name = names[i];
				i = i + 1;
				
				if (rtl::key_exists(code1, name) and rtl::key_exists(code2, name)){
					var value1 = code1[name];
					var value2 = code2[name];
				
					if (!rtl::is_array(value1) or !rtl::is_array(value2))
						return false;
					
					if (!BayrellCode::compare_arr(value1, value2))
						return false;
				}
				else if (rtl::key_exists(code1,name) and !rtl::key_exists(code2, name) or !rtl::key_exists(code1, name) and rtl::key_exists(code2, name))
					return false;
			}
			
			
			/* Объекты */
			array names = ['value', 'expr', 'pos', 'expr_true', 'expr_false', 'left', 'right', 'init', 'inc', 'type', 'name'];
			int i = 0;
			int sz = rtl::count(names);
			while (i < sz){
				string name = names[i];
				i = i + 1;
				
				if (rtl::key_exists(code1, name) and rtl::key_exists(code2, name)){
					var value1 = code1[name];
					var value2 = code2[name];
				
					if (!rtl::is_json(value1) or !rtl::is_json(value2))
						return false;
					
					if (!BayrellCode::compare(value1, value2))
						return false;
				}
				else if (rtl::key_exists(code1, name) and !rtl::key_exists(code2, name) or !rtl::key_exists(code1, name) and rtl::key_exists(code2, name))
					return false;
			}
			
			
			if (rtl::key_exists(code1, 'flags') and rtl::key_exists(code2, 'flags')){
				array flags1 = code1['flags'];
				array flags2 = code2['flags'];
				array names = BayrellCode::FLAGS;
				int i = 0;
				int sz = rtl::count(names);
				while (i < sz){
					string name = names[i];
					i = i + 1;
					
					if (rtl::key_exists(flags1, name) and rtl::key_exists(flags2, name)){
						var value1 = flags1[name];
						var value2 = flags2[name];
						
						if (value1 != value2)
							return false;
					}
					
					else if (rtl::key_exists(flags1, name) and flags1[name] == true)
						return false;
					
					else if (rtl::key_exists(flags2, name) and flags2[name] == true)
						return false;
				}
			}
			else if (rtl::key_exists(code1, 'flags') and !rtl::key_exists(code2, 'flags') or !rtl::key_exists(code1, 'flags') and rtl::key_exists(code2, 'flags'))
				return false;
		}
		
		return true;
	}
	
}